/**
 * Generated by orval v7.4.1 🍺
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query'
import type {
  Activities,
  Activity,
  ActivityConnection,
  ActivityConnections,
  AdditionalCost,
  AssignmentCard,
  AssignmentTransaction,
  Bank,
  BankAccount,
  BankBranch,
  Branch,
  CashAccount,
  CashAccountBalanceResult,
  CashAccountTransaction,
  CashAccountTransactionEntity,
  Company,
  CurrentAccount,
  CurrentAccountBankAccount,
  CurrentAccountTransaction,
  Department,
  Depot,
  DepotTransaction,
  DepotTransactions,
  Employee,
  EmployeeOvertime,
  EmployeeOvertimes,
  EmployeePayment,
  EmployeePayments,
  ErrorResponse,
  ExpenseCard,
  ExpenseInvoice,
  ExpenseInvoiceCalculationResult,
  FilteringRequest,
  FixtureCard,
  FixtureGroup,
  FixtureGroupTreeDataResponse,
  Invoice,
  InvoiceCalculationResult,
  LoginRequest,
  LoginResponse,
  Logout200,
  Machine,
  MaterialCard,
  MaterialGroup,
  MaterialGroupTreeDataResponse,
  MaterialRequest,
  MaterialRequestFulfillment,
  MaterialRequestFulfillments,
  MaterialRequests,
  PaymentMethod,
  ProductCard,
  ProductGroup,
  ProductGroupTreeDataResponse,
  ProductPlan,
  ProductPlans,
  ProductionPlanProduct,
  ProductionPlanProducts,
  Project,
  Proposal,
  ProposalRequest,
  ProposalRequestCalculationResult,
  ProposalRequests,
  PublicHoliday,
  PurchaseOrder,
  RefreshResponse,
  ResponseBase,
  Role,
  Section,
  ServiceCard,
  ServiceGroup,
  ServiceGroupTreeDataResponse,
  Shelf,
  TimeKeeping,
  TimeKeepingCalculationResult,
  TimeOff,
  TimeOffStatus,
  Unit,
  UpdateUserRoles204,
  User,
  UserAdd,
  UserRolesRequest,
  UserRolesResponse,
  UserUpdate,
  WBSList,
  Wbs,
  WorkOrder,
  WorkOrderConnection,
  WorkOrderConnections,
  WorkOrders
} from './model'
import { customMutator } from './customMutator';



/**
 * Get User
 */
export const getUser = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<User>(
      {url: `/api/users/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetUserQueryKey = (id: number,) => {
    return [`/api/users/${id}`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = ErrorResponse


export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserSuspenseQueryError = ErrorResponse


export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update User
 */
export const updateUser = (
    id: number,
    userUpdate: UserUpdate,
 ) => {
      
      
      return customMutator<User>(
      {url: `/api/users/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
      );
    }
  


export const getUpdateUserMutationOptions = <TData = Awaited<ReturnType<typeof updateUser>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: UserUpdate}, TContext>, }
) => {
const mutationKey = ['updateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {id: number;data: UserUpdate}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUser(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: UserUpdate}, TContext>}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UserUpdate
    export type UpdateUserMutationError = ErrorResponse

    export const useUpdateUser = <TData = Awaited<ReturnType<typeof updateUser>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: UserUpdate}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: UserUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete User
 */
export const deleteUser = (
    id: number,
 ) => {
      
      
      return customMutator<User>(
      {url: `/api/users/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUserMutationOptions = <TData = Awaited<ReturnType<typeof deleteUser>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = ResponseBase

    export const useDeleteUser = <TData = Awaited<ReturnType<typeof deleteUser>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const updateUserRoles = (
    id: number,
    userRolesRequest: UserRolesRequest,
 ) => {
      
      
      return customMutator<UpdateUserRoles204>(
      {url: `/api/users/${id}/roles`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userRolesRequest
    },
      );
    }
  


export const getUpdateUserRolesMutationOptions = <TData = Awaited<ReturnType<typeof updateUserRoles>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: UserRolesRequest}, TContext>, }
) => {
const mutationKey = ['updateUserRoles'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserRoles>>, {id: number;data: UserRolesRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUserRoles(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: UserRolesRequest}, TContext>}

    export type UpdateUserRolesMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserRoles>>>
    export type UpdateUserRolesMutationBody = UserRolesRequest
    export type UpdateUserRolesMutationError = ResponseBase

    export const useUpdateUserRoles = <TData = Awaited<ReturnType<typeof updateUserRoles>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: UserRolesRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: UserRolesRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserRolesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Unit
 */
export const getUnit = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Unit>(
      {url: `/api/storage/unit/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetUnitQueryKey = (id: number,) => {
    return [`/api/storage/unit/${id}`] as const;
    }

    
export const getGetUnitQueryOptions = <TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUnitQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnit>>> = ({ signal }) => getUnit(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUnitQueryResult = NonNullable<Awaited<ReturnType<typeof getUnit>>>
export type GetUnitQueryError = ErrorResponse


export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnit>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnit>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUnitQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUnitSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUnitQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnit>>> = ({ signal }) => getUnit(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUnitSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUnit>>>
export type GetUnitSuspenseQueryError = ErrorResponse


export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUnitSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Unit
 */
export const updateUnit = (
    id: number,
    unit: Unit,
 ) => {
      
      
      return customMutator<Unit>(
      {url: `/api/storage/unit/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: unit
    },
      );
    }
  


export const getUpdateUnitMutationOptions = <TData = Awaited<ReturnType<typeof updateUnit>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Unit}, TContext>, }
) => {
const mutationKey = ['updateUnit'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUnit>>, {id: number;data: Unit}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUnit(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Unit}, TContext>}

    export type UpdateUnitMutationResult = NonNullable<Awaited<ReturnType<typeof updateUnit>>>
    export type UpdateUnitMutationBody = Unit
    export type UpdateUnitMutationError = ErrorResponse

    export const useUpdateUnit = <TData = Awaited<ReturnType<typeof updateUnit>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Unit}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Unit},
        TContext
      > => {

      const mutationOptions = getUpdateUnitMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Unit
 */
export const deleteUnit = (
    id: number,
 ) => {
      
      
      return customMutator<Unit>(
      {url: `/api/storage/unit/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUnitMutationOptions = <TData = Awaited<ReturnType<typeof deleteUnit>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteUnit'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUnit>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteUnit(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteUnitMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUnit>>>
    
    export type DeleteUnitMutationError = ResponseBase

    export const useDeleteUnit = <TData = Awaited<ReturnType<typeof deleteUnit>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteUnitMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Shelf
 */
export const getShelf = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Shelf>(
      {url: `/api/storage/shelf/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetShelfQueryKey = (id: number,) => {
    return [`/api/storage/shelf/${id}`] as const;
    }

    
export const getGetShelfQueryOptions = <TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetShelfQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getShelf>>> = ({ signal }) => getShelf(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetShelfQueryResult = NonNullable<Awaited<ReturnType<typeof getShelf>>>
export type GetShelfQueryError = ErrorResponse


export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShelf>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShelf>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetShelfQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetShelfSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetShelfQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getShelf>>> = ({ signal }) => getShelf(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetShelfSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getShelf>>>
export type GetShelfSuspenseQueryError = ErrorResponse


export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetShelfSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Shelf
 */
export const updateShelf = (
    id: number,
    shelf: Shelf,
 ) => {
      
      
      return customMutator<Shelf>(
      {url: `/api/storage/shelf/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: shelf
    },
      );
    }
  


export const getUpdateShelfMutationOptions = <TData = Awaited<ReturnType<typeof updateShelf>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Shelf}, TContext>, }
) => {
const mutationKey = ['updateShelf'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateShelf>>, {id: number;data: Shelf}> = (props) => {
          const {id,data} = props ?? {};

          return  updateShelf(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Shelf}, TContext>}

    export type UpdateShelfMutationResult = NonNullable<Awaited<ReturnType<typeof updateShelf>>>
    export type UpdateShelfMutationBody = Shelf
    export type UpdateShelfMutationError = ErrorResponse

    export const useUpdateShelf = <TData = Awaited<ReturnType<typeof updateShelf>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Shelf}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Shelf},
        TContext
      > => {

      const mutationOptions = getUpdateShelfMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Shelf
 */
export const deleteShelf = (
    id: number,
 ) => {
      
      
      return customMutator<Shelf>(
      {url: `/api/storage/shelf/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteShelfMutationOptions = <TData = Awaited<ReturnType<typeof deleteShelf>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteShelf'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteShelf>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteShelf(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteShelfMutationResult = NonNullable<Awaited<ReturnType<typeof deleteShelf>>>
    
    export type DeleteShelfMutationError = ResponseBase

    export const useDeleteShelf = <TData = Awaited<ReturnType<typeof deleteShelf>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteShelfMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ServiceGroup
 */
export const getServiceGroup = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceGroup>(
      {url: `/api/storage/serviceGroup/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetServiceGroupQueryKey = (id: number,) => {
    return [`/api/storage/serviceGroup/${id}`] as const;
    }

    
export const getGetServiceGroupQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroup>>> = ({ signal }) => getServiceGroup(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroup>>>
export type GetServiceGroupQueryError = ErrorResponse


export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroup>>> = ({ signal }) => getServiceGroup(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroup>>>
export type GetServiceGroupSuspenseQueryError = ErrorResponse


export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ServiceGroup
 */
export const updateServiceGroup = (
    id: number,
    serviceGroup: ServiceGroup,
 ) => {
      
      
      return customMutator<ServiceGroup>(
      {url: `/api/storage/serviceGroup/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: serviceGroup
    },
      );
    }
  


export const getUpdateServiceGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateServiceGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceGroup}, TContext>, }
) => {
const mutationKey = ['updateServiceGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceGroup>>, {id: number;data: ServiceGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateServiceGroup(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ServiceGroup}, TContext>}

    export type UpdateServiceGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceGroup>>>
    export type UpdateServiceGroupMutationBody = ServiceGroup
    export type UpdateServiceGroupMutationError = ErrorResponse

    export const useUpdateServiceGroup = <TData = Awaited<ReturnType<typeof updateServiceGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ServiceGroup},
        TContext
      > => {

      const mutationOptions = getUpdateServiceGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ServiceGroup
 */
export const deleteServiceGroup = (
    id: number,
 ) => {
      
      
      return customMutator<ServiceGroup>(
      {url: `/api/storage/serviceGroup/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteServiceGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteServiceGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteServiceGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteServiceGroup(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteServiceGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceGroup>>>
    
    export type DeleteServiceGroupMutationError = ResponseBase

    export const useDeleteServiceGroup = <TData = Awaited<ReturnType<typeof deleteServiceGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteServiceGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ServiceCard
 */
export const getServiceCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<string>(
      {url: `/api/storage/serviceCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetServiceCardQueryKey = (id: number,) => {
    return [`/api/storage/serviceCard/${id}`] as const;
    }

    
export const getGetServiceCardQueryOptions = <TData = Awaited<ReturnType<typeof getServiceCard>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceCard>>> = ({ signal }) => getServiceCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceCardQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceCard>>>
export type GetServiceCardQueryError = unknown


export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getServiceCard>>, TError = unknown>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceCard>>> = ({ signal }) => getServiceCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceCard>>>
export type GetServiceCardSuspenseQueryError = unknown


export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = unknown>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ServiceCard
 */
export const updateServiceCard = (
    id: number,
    serviceCard: ServiceCard,
 ) => {
      
      
      return customMutator<ServiceCard>(
      {url: `/api/storage/serviceCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: serviceCard
    },
      );
    }
  


export const getUpdateServiceCardMutationOptions = <TData = Awaited<ReturnType<typeof updateServiceCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceCard}, TContext>, }
) => {
const mutationKey = ['updateServiceCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceCard>>, {id: number;data: ServiceCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateServiceCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ServiceCard}, TContext>}

    export type UpdateServiceCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceCard>>>
    export type UpdateServiceCardMutationBody = ServiceCard
    export type UpdateServiceCardMutationError = ErrorResponse

    export const useUpdateServiceCard = <TData = Awaited<ReturnType<typeof updateServiceCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ServiceCard},
        TContext
      > => {

      const mutationOptions = getUpdateServiceCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ServiceCard
 */
export const deleteServiceCard = (
    id: number,
 ) => {
      
      
      return customMutator<ServiceCard>(
      {url: `/api/storage/serviceCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteServiceCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteServiceCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteServiceCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteServiceCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteServiceCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceCard>>>
    
    export type DeleteServiceCardMutationError = ResponseBase

    export const useDeleteServiceCard = <TData = Awaited<ReturnType<typeof deleteServiceCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteServiceCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ProductGroup
 */
export const getProductGroup = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductGroup>(
      {url: `/api/storage/productGroup/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProductGroupQueryKey = (id: number,) => {
    return [`/api/storage/productGroup/${id}`] as const;
    }

    
export const getGetProductGroupQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroup>>> = ({ signal }) => getProductGroup(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroup>>>
export type GetProductGroupQueryError = ErrorResponse


export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroup>>> = ({ signal }) => getProductGroup(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroup>>>
export type GetProductGroupSuspenseQueryError = ErrorResponse


export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ProductGroup
 */
export const updateProductGroup = (
    id: number,
    productGroup: ProductGroup,
 ) => {
      
      
      return customMutator<ProductGroup>(
      {url: `/api/storage/productGroup/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: productGroup
    },
      );
    }
  


export const getUpdateProductGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateProductGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductGroup}, TContext>, }
) => {
const mutationKey = ['updateProductGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProductGroup>>, {id: number;data: ProductGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProductGroup(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ProductGroup}, TContext>}

    export type UpdateProductGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateProductGroup>>>
    export type UpdateProductGroupMutationBody = ProductGroup
    export type UpdateProductGroupMutationError = ErrorResponse

    export const useUpdateProductGroup = <TData = Awaited<ReturnType<typeof updateProductGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ProductGroup},
        TContext
      > => {

      const mutationOptions = getUpdateProductGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ProductGroup
 */
export const deleteProductGroup = (
    id: number,
 ) => {
      
      
      return customMutator<ProductGroup>(
      {url: `/api/storage/productGroup/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProductGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteProductGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteProductGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProductGroup(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProductGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductGroup>>>
    
    export type DeleteProductGroupMutationError = ResponseBase

    export const useDeleteProductGroup = <TData = Awaited<ReturnType<typeof deleteProductGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProductGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ProductCard
 */
export const getProductCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductCard>(
      {url: `/api/storage/productCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProductCardQueryKey = (id: number,) => {
    return [`/api/storage/productCard/${id}`] as const;
    }

    
export const getGetProductCardQueryOptions = <TData = Awaited<ReturnType<typeof getProductCard>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductCard>>> = ({ signal }) => getProductCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductCardQueryResult = NonNullable<Awaited<ReturnType<typeof getProductCard>>>
export type GetProductCardQueryError = unknown


export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductCard>>, TError = unknown>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductCard>>> = ({ signal }) => getProductCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductCard>>>
export type GetProductCardSuspenseQueryError = unknown


export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = unknown>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ProductCard
 */
export const updateProductCard = (
    id: number,
    productCard: ProductCard,
 ) => {
      
      
      return customMutator<ProductCard>(
      {url: `/api/storage/productCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: productCard
    },
      );
    }
  


export const getUpdateProductCardMutationOptions = <TData = Awaited<ReturnType<typeof updateProductCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductCard}, TContext>, }
) => {
const mutationKey = ['updateProductCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProductCard>>, {id: number;data: ProductCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProductCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ProductCard}, TContext>}

    export type UpdateProductCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateProductCard>>>
    export type UpdateProductCardMutationBody = ProductCard
    export type UpdateProductCardMutationError = ErrorResponse

    export const useUpdateProductCard = <TData = Awaited<ReturnType<typeof updateProductCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ProductCard},
        TContext
      > => {

      const mutationOptions = getUpdateProductCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ProductCard
 */
export const deleteProductCard = (
    id: number,
 ) => {
      
      
      return customMutator<ProductCard>(
      {url: `/api/storage/productCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProductCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteProductCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteProductCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProductCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProductCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductCard>>>
    
    export type DeleteProductCardMutationError = ResponseBase

    export const useDeleteProductCard = <TData = Awaited<ReturnType<typeof deleteProductCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProductCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Material Request Fulfillment
 */
export const getMaterialRequestFulfillment = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialRequestFulfillment>(
      {url: `/api/storage/materialRequestFulfillment/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetMaterialRequestFulfillmentQueryKey = (id: number,) => {
    return [`/api/storage/materialRequestFulfillment/${id}`] as const;
    }

    
export const getGetMaterialRequestFulfillmentQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialRequestFulfillmentQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>> = ({ signal }) => getMaterialRequestFulfillment(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialRequestFulfillmentQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>>
export type GetMaterialRequestFulfillmentQueryError = ErrorResponse


export function useGetMaterialRequestFulfillment<TData = Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialRequestFulfillment>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialRequestFulfillment<TData = Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialRequestFulfillment>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialRequestFulfillment<TData = Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialRequestFulfillment<TData = Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialRequestFulfillmentQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialRequestFulfillmentSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialRequestFulfillmentQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>> = ({ signal }) => getMaterialRequestFulfillment(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialRequestFulfillmentSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>>
export type GetMaterialRequestFulfillmentSuspenseQueryError = ErrorResponse


export function useGetMaterialRequestFulfillmentSuspense<TData = Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialRequestFulfillmentSuspense<TData = Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialRequestFulfillmentSuspense<TData = Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialRequestFulfillmentSuspense<TData = Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequestFulfillment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialRequestFulfillmentSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Material Request Fulfillment
 */
export const updateMaterialRequestFulfillment = (
    id: number,
    materialRequestFulfillment: MaterialRequestFulfillment,
 ) => {
      
      
      return customMutator<MaterialRequestFulfillment>(
      {url: `/api/storage/materialRequestFulfillment/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: materialRequestFulfillment
    },
      );
    }
  


export const getUpdateMaterialRequestFulfillmentMutationOptions = <TData = Awaited<ReturnType<typeof updateMaterialRequestFulfillment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialRequestFulfillment}, TContext>, }
) => {
const mutationKey = ['updateMaterialRequestFulfillment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMaterialRequestFulfillment>>, {id: number;data: MaterialRequestFulfillment}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMaterialRequestFulfillment(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: MaterialRequestFulfillment}, TContext>}

    export type UpdateMaterialRequestFulfillmentMutationResult = NonNullable<Awaited<ReturnType<typeof updateMaterialRequestFulfillment>>>
    export type UpdateMaterialRequestFulfillmentMutationBody = MaterialRequestFulfillment
    export type UpdateMaterialRequestFulfillmentMutationError = ErrorResponse

    export const useUpdateMaterialRequestFulfillment = <TData = Awaited<ReturnType<typeof updateMaterialRequestFulfillment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialRequestFulfillment}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: MaterialRequestFulfillment},
        TContext
      > => {

      const mutationOptions = getUpdateMaterialRequestFulfillmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete MaterialRequestFulfillment
 */
export const deleteMaterialRequestFulfillment = (
    id: number,
 ) => {
      
      
      return customMutator<MaterialRequestFulfillment>(
      {url: `/api/storage/materialRequestFulfillment/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteMaterialRequestFulfillmentMutationOptions = <TData = Awaited<ReturnType<typeof deleteMaterialRequestFulfillment>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteMaterialRequestFulfillment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMaterialRequestFulfillment>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMaterialRequestFulfillment(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteMaterialRequestFulfillmentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMaterialRequestFulfillment>>>
    
    export type DeleteMaterialRequestFulfillmentMutationError = ResponseBase

    export const useDeleteMaterialRequestFulfillment = <TData = Awaited<ReturnType<typeof deleteMaterialRequestFulfillment>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMaterialRequestFulfillmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get MaterialGroup
 */
export const getMaterialGroup = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialGroup>(
      {url: `/api/storage/materialGroup/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetMaterialGroupQueryKey = (id: number,) => {
    return [`/api/storage/materialGroup/${id}`] as const;
    }

    
export const getGetMaterialGroupQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroup>>> = ({ signal }) => getMaterialGroup(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroup>>>
export type GetMaterialGroupQueryError = ErrorResponse


export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroup>>> = ({ signal }) => getMaterialGroup(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroup>>>
export type GetMaterialGroupSuspenseQueryError = ErrorResponse


export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update MaterialGroup
 */
export const updateMaterialGroup = (
    id: number,
    materialGroup: MaterialGroup,
 ) => {
      
      
      return customMutator<MaterialGroup>(
      {url: `/api/storage/materialGroup/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: materialGroup
    },
      );
    }
  


export const getUpdateMaterialGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateMaterialGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialGroup}, TContext>, }
) => {
const mutationKey = ['updateMaterialGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMaterialGroup>>, {id: number;data: MaterialGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMaterialGroup(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: MaterialGroup}, TContext>}

    export type UpdateMaterialGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateMaterialGroup>>>
    export type UpdateMaterialGroupMutationBody = MaterialGroup
    export type UpdateMaterialGroupMutationError = ErrorResponse

    export const useUpdateMaterialGroup = <TData = Awaited<ReturnType<typeof updateMaterialGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: MaterialGroup},
        TContext
      > => {

      const mutationOptions = getUpdateMaterialGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete MaterialGroup
 */
export const deleteMaterialGroup = (
    id: number,
 ) => {
      
      
      return customMutator<MaterialGroup>(
      {url: `/api/storage/materialGroup/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteMaterialGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteMaterialGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteMaterialGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMaterialGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMaterialGroup(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteMaterialGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMaterialGroup>>>
    
    export type DeleteMaterialGroupMutationError = ResponseBase

    export const useDeleteMaterialGroup = <TData = Awaited<ReturnType<typeof deleteMaterialGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMaterialGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get MaterialCard
 */
export const getMaterialCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialCard>(
      {url: `/api/storage/materialCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetMaterialCardQueryKey = (id: number,) => {
    return [`/api/storage/materialCard/${id}`] as const;
    }

    
export const getGetMaterialCardQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialCard>>> = ({ signal }) => getMaterialCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialCardQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialCard>>>
export type GetMaterialCardQueryError = unknown


export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = unknown>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialCard>>> = ({ signal }) => getMaterialCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialCard>>>
export type GetMaterialCardSuspenseQueryError = unknown


export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = unknown>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update MaterialCard
 */
export const updateMaterialCard = (
    id: number,
    materialCard: MaterialCard,
 ) => {
      
      
      return customMutator<MaterialCard>(
      {url: `/api/storage/materialCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: materialCard
    },
      );
    }
  


export const getUpdateMaterialCardMutationOptions = <TData = Awaited<ReturnType<typeof updateMaterialCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialCard}, TContext>, }
) => {
const mutationKey = ['updateMaterialCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMaterialCard>>, {id: number;data: MaterialCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMaterialCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: MaterialCard}, TContext>}

    export type UpdateMaterialCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateMaterialCard>>>
    export type UpdateMaterialCardMutationBody = MaterialCard
    export type UpdateMaterialCardMutationError = ErrorResponse

    export const useUpdateMaterialCard = <TData = Awaited<ReturnType<typeof updateMaterialCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: MaterialCard},
        TContext
      > => {

      const mutationOptions = getUpdateMaterialCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete MaterialCard
 */
export const deleteMaterialCard = (
    id: number,
 ) => {
      
      
      return customMutator<MaterialCard>(
      {url: `/api/storage/materialCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteMaterialCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteMaterialCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteMaterialCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMaterialCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMaterialCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteMaterialCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMaterialCard>>>
    
    export type DeleteMaterialCardMutationError = ResponseBase

    export const useDeleteMaterialCard = <TData = Awaited<ReturnType<typeof deleteMaterialCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMaterialCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get FixtureGroup
 */
export const getFixtureGroup = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureGroup>(
      {url: `/api/storage/fixtureGroup/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetFixtureGroupQueryKey = (id: number,) => {
    return [`/api/storage/fixtureGroup/${id}`] as const;
    }

    
export const getGetFixtureGroupQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroup>>> = ({ signal }) => getFixtureGroup(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroup>>>
export type GetFixtureGroupQueryError = ErrorResponse


export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFixtureGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroup>>> = ({ signal }) => getFixtureGroup(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroup>>>
export type GetFixtureGroupSuspenseQueryError = ErrorResponse


export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update FixtureGroup
 */
export const updateFixtureGroup = (
    id: number,
    fixtureGroup: FixtureGroup,
 ) => {
      
      
      return customMutator<FixtureGroup>(
      {url: `/api/storage/fixtureGroup/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: fixtureGroup
    },
      );
    }
  


export const getUpdateFixtureGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateFixtureGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureGroup}, TContext>, }
) => {
const mutationKey = ['updateFixtureGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFixtureGroup>>, {id: number;data: FixtureGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateFixtureGroup(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: FixtureGroup}, TContext>}

    export type UpdateFixtureGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateFixtureGroup>>>
    export type UpdateFixtureGroupMutationBody = FixtureGroup
    export type UpdateFixtureGroupMutationError = ErrorResponse

    export const useUpdateFixtureGroup = <TData = Awaited<ReturnType<typeof updateFixtureGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: FixtureGroup},
        TContext
      > => {

      const mutationOptions = getUpdateFixtureGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete FixtureGroup
 */
export const deleteFixtureGroup = (
    id: number,
 ) => {
      
      
      return customMutator<FixtureGroup>(
      {url: `/api/storage/fixtureGroup/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteFixtureGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteFixtureGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteFixtureGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFixtureGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteFixtureGroup(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteFixtureGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFixtureGroup>>>
    
    export type DeleteFixtureGroupMutationError = ResponseBase

    export const useDeleteFixtureGroup = <TData = Awaited<ReturnType<typeof deleteFixtureGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteFixtureGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get FixtureCard
 */
export const getFixtureCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<string>(
      {url: `/api/storage/fixtureCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetFixtureCardQueryKey = (id: number,) => {
    return [`/api/storage/fixtureCard/${id}`] as const;
    }

    
export const getGetFixtureCardQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureCard>>> = ({ signal }) => getFixtureCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureCardQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureCard>>>
export type GetFixtureCardQueryError = unknown


export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFixtureCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = unknown>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureCard>>> = ({ signal }) => getFixtureCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureCard>>>
export type GetFixtureCardSuspenseQueryError = unknown


export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = unknown>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update FixtureCard
 */
export const updateFixtureCard = (
    id: number,
    fixtureCard: FixtureCard,
 ) => {
      
      
      return customMutator<FixtureCard>(
      {url: `/api/storage/fixtureCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: fixtureCard
    },
      );
    }
  


export const getUpdateFixtureCardMutationOptions = <TData = Awaited<ReturnType<typeof updateFixtureCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureCard}, TContext>, }
) => {
const mutationKey = ['updateFixtureCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFixtureCard>>, {id: number;data: FixtureCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateFixtureCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: FixtureCard}, TContext>}

    export type UpdateFixtureCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateFixtureCard>>>
    export type UpdateFixtureCardMutationBody = FixtureCard
    export type UpdateFixtureCardMutationError = ErrorResponse

    export const useUpdateFixtureCard = <TData = Awaited<ReturnType<typeof updateFixtureCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: FixtureCard},
        TContext
      > => {

      const mutationOptions = getUpdateFixtureCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete FixtureCard
 */
export const deleteFixtureCard = (
    id: number,
 ) => {
      
      
      return customMutator<FixtureCard>(
      {url: `/api/storage/fixtureCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteFixtureCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteFixtureCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteFixtureCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFixtureCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteFixtureCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteFixtureCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFixtureCard>>>
    
    export type DeleteFixtureCardMutationError = ResponseBase

    export const useDeleteFixtureCard = <TData = Awaited<ReturnType<typeof deleteFixtureCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteFixtureCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get DepotTransaction
 */
export const getDepotTransaction = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<DepotTransaction>(
      {url: `/api/storage/depotTransaction/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDepotTransactionQueryKey = (id: number,) => {
    return [`/api/storage/depotTransaction/${id}`] as const;
    }

    
export const getGetDepotTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getDepotTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepotTransaction>>> = ({ signal }) => getDepotTransaction(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getDepotTransaction>>>
export type GetDepotTransactionQueryError = ErrorResponse


export function useGetDepotTransaction<TData = Awaited<ReturnType<typeof getDepotTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepotTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotTransaction<TData = Awaited<ReturnType<typeof getDepotTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepotTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotTransaction<TData = Awaited<ReturnType<typeof getDepotTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepotTransaction<TData = Awaited<ReturnType<typeof getDepotTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotTransactionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepotTransactionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepotTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepotTransaction>>> = ({ signal }) => getDepotTransaction(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotTransactionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepotTransaction>>>
export type GetDepotTransactionSuspenseQueryError = ErrorResponse


export function useGetDepotTransactionSuspense<TData = Awaited<ReturnType<typeof getDepotTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotTransactionSuspense<TData = Awaited<ReturnType<typeof getDepotTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotTransactionSuspense<TData = Awaited<ReturnType<typeof getDepotTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepotTransactionSuspense<TData = Awaited<ReturnType<typeof getDepotTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotTransactionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update DepotTransaction
 */
export const updateDepotTransaction = (
    id: number,
    depotTransaction: DepotTransaction,
 ) => {
      
      
      return customMutator<DepotTransaction>(
      {url: `/api/storage/depotTransaction/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: depotTransaction
    },
      );
    }
  


export const getUpdateDepotTransactionMutationOptions = <TData = Awaited<ReturnType<typeof updateDepotTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: DepotTransaction}, TContext>, }
) => {
const mutationKey = ['updateDepotTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDepotTransaction>>, {id: number;data: DepotTransaction}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDepotTransaction(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: DepotTransaction}, TContext>}

    export type UpdateDepotTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof updateDepotTransaction>>>
    export type UpdateDepotTransactionMutationBody = DepotTransaction
    export type UpdateDepotTransactionMutationError = ErrorResponse

    export const useUpdateDepotTransaction = <TData = Awaited<ReturnType<typeof updateDepotTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: DepotTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: DepotTransaction},
        TContext
      > => {

      const mutationOptions = getUpdateDepotTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete DepotTransaction
 */
export const deleteDepotTransaction = (
    id: number,
 ) => {
      
      
      return customMutator<DepotTransaction>(
      {url: `/api/storage/depotTransaction/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDepotTransactionMutationOptions = <TData = Awaited<ReturnType<typeof deleteDepotTransaction>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteDepotTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDepotTransaction>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteDepotTransaction(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteDepotTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDepotTransaction>>>
    
    export type DeleteDepotTransactionMutationError = ResponseBase

    export const useDeleteDepotTransaction = <TData = Awaited<ReturnType<typeof deleteDepotTransaction>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteDepotTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get AssignmentTransaction
 */
export const getAssignmentTransaction = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AssignmentTransaction>(
      {url: `/api/storage/assignmentTransaction/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAssignmentTransactionQueryKey = (id: number,) => {
    return [`/api/storage/assignmentTransaction/${id}`] as const;
    }

    
export const getGetAssignmentTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentTransaction>>> = ({ signal }) => getAssignmentTransaction(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentTransaction>>>
export type GetAssignmentTransactionQueryError = ErrorResponse


export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentTransactionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssignmentTransactionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentTransaction>>> = ({ signal }) => getAssignmentTransaction(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentTransactionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentTransaction>>>
export type GetAssignmentTransactionSuspenseQueryError = ErrorResponse


export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentTransactionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update AssignmentTransaction
 */
export const updateAssignmentTransaction = (
    id: number,
    assignmentTransaction: AssignmentTransaction,
 ) => {
      
      
      return customMutator<AssignmentTransaction>(
      {url: `/api/storage/assignmentTransaction/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assignmentTransaction
    },
      );
    }
  


export const getUpdateAssignmentTransactionMutationOptions = <TData = Awaited<ReturnType<typeof updateAssignmentTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentTransaction}, TContext>, }
) => {
const mutationKey = ['updateAssignmentTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssignmentTransaction>>, {id: number;data: AssignmentTransaction}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAssignmentTransaction(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: AssignmentTransaction}, TContext>}

    export type UpdateAssignmentTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssignmentTransaction>>>
    export type UpdateAssignmentTransactionMutationBody = AssignmentTransaction
    export type UpdateAssignmentTransactionMutationError = ErrorResponse

    export const useUpdateAssignmentTransaction = <TData = Awaited<ReturnType<typeof updateAssignmentTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: AssignmentTransaction},
        TContext
      > => {

      const mutationOptions = getUpdateAssignmentTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete AssignmentTransaction
 */
export const deleteAssignmentTransaction = (
    id: number,
 ) => {
      
      
      return customMutator<AssignmentTransaction>(
      {url: `/api/storage/assignmentTransaction/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAssignmentTransactionMutationOptions = <TData = Awaited<ReturnType<typeof deleteAssignmentTransaction>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteAssignmentTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssignmentTransaction>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAssignmentTransaction(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteAssignmentTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssignmentTransaction>>>
    
    export type DeleteAssignmentTransactionMutationError = ResponseBase

    export const useDeleteAssignmentTransaction = <TData = Awaited<ReturnType<typeof deleteAssignmentTransaction>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAssignmentTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get AssignmentCard
 */
export const getAssignmentCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AssignmentCard>(
      {url: `/api/storage/assignmentCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAssignmentCardQueryKey = (id: number,) => {
    return [`/api/storage/assignmentCard/${id}`] as const;
    }

    
export const getGetAssignmentCardQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentCard>>> = ({ signal }) => getAssignmentCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentCardQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentCard>>>
export type GetAssignmentCardQueryError = ErrorResponse


export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssignmentCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentCard>>> = ({ signal }) => getAssignmentCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentCard>>>
export type GetAssignmentCardSuspenseQueryError = ErrorResponse


export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update AssignmentCard
 */
export const updateAssignmentCard = (
    id: number,
    assignmentCard: AssignmentCard,
 ) => {
      
      
      return customMutator<AssignmentCard>(
      {url: `/api/storage/assignmentCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assignmentCard
    },
      );
    }
  


export const getUpdateAssignmentCardMutationOptions = <TData = Awaited<ReturnType<typeof updateAssignmentCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentCard}, TContext>, }
) => {
const mutationKey = ['updateAssignmentCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssignmentCard>>, {id: number;data: AssignmentCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAssignmentCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: AssignmentCard}, TContext>}

    export type UpdateAssignmentCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssignmentCard>>>
    export type UpdateAssignmentCardMutationBody = AssignmentCard
    export type UpdateAssignmentCardMutationError = ErrorResponse

    export const useUpdateAssignmentCard = <TData = Awaited<ReturnType<typeof updateAssignmentCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: AssignmentCard},
        TContext
      > => {

      const mutationOptions = getUpdateAssignmentCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete AssignmentCard
 */
export const deleteAssignmentCard = (
    id: number,
 ) => {
      
      
      return customMutator<AssignmentCard>(
      {url: `/api/storage/assignmentCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAssignmentCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteAssignmentCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteAssignmentCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssignmentCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAssignmentCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteAssignmentCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssignmentCard>>>
    
    export type DeleteAssignmentCardMutationError = ResponseBase

    export const useDeleteAssignmentCard = <TData = Awaited<ReturnType<typeof deleteAssignmentCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAssignmentCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Proposal
 */
export const getProposal = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Proposal>(
      {url: `/api/sales/proposal/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProposalQueryKey = (id: number,) => {
    return [`/api/sales/proposal/${id}`] as const;
    }

    
export const getGetProposalQueryOptions = <TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProposalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProposal>>> = ({ signal }) => getProposal(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProposalQueryResult = NonNullable<Awaited<ReturnType<typeof getProposal>>>
export type GetProposalQueryError = ErrorResponse


export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProposal>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProposal>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProposalQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProposalSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProposalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProposal>>> = ({ signal }) => getProposal(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProposalSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProposal>>>
export type GetProposalSuspenseQueryError = ErrorResponse


export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProposalSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Proposal
 */
export const updateProposal = (
    id: number,
    proposal: Proposal,
 ) => {
      
      
      return customMutator<Proposal>(
      {url: `/api/sales/proposal/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: proposal
    },
      );
    }
  


export const getUpdateProposalMutationOptions = <TData = Awaited<ReturnType<typeof updateProposal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Proposal}, TContext>, }
) => {
const mutationKey = ['updateProposal'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProposal>>, {id: number;data: Proposal}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProposal(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Proposal}, TContext>}

    export type UpdateProposalMutationResult = NonNullable<Awaited<ReturnType<typeof updateProposal>>>
    export type UpdateProposalMutationBody = Proposal
    export type UpdateProposalMutationError = ErrorResponse

    export const useUpdateProposal = <TData = Awaited<ReturnType<typeof updateProposal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Proposal}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Proposal},
        TContext
      > => {

      const mutationOptions = getUpdateProposalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Proposal
 */
export const deleteProposal = (
    id: number,
 ) => {
      
      
      return customMutator<Proposal>(
      {url: `/api/sales/proposal/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProposalMutationOptions = <TData = Awaited<ReturnType<typeof deleteProposal>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteProposal'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProposal>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProposal(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProposalMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProposal>>>
    
    export type DeleteProposalMutationError = ResponseBase

    export const useDeleteProposal = <TData = Awaited<ReturnType<typeof deleteProposal>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProposalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Purchase Order
 */
export const getPurchaseOrder = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PurchaseOrder>(
      {url: `/api/purchasing/purchaseOrder/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetPurchaseOrderQueryKey = (id: number,) => {
    return [`/api/purchasing/purchaseOrder/${id}`] as const;
    }

    
export const getGetPurchaseOrderQueryOptions = <TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPurchaseOrderQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPurchaseOrder>>> = ({ signal }) => getPurchaseOrder(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPurchaseOrderQueryResult = NonNullable<Awaited<ReturnType<typeof getPurchaseOrder>>>
export type GetPurchaseOrderQueryError = ErrorResponse


export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseOrder>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseOrder>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPurchaseOrderQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPurchaseOrderSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPurchaseOrderQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPurchaseOrder>>> = ({ signal }) => getPurchaseOrder(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPurchaseOrderSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPurchaseOrder>>>
export type GetPurchaseOrderSuspenseQueryError = ErrorResponse


export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPurchaseOrderSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update PurchaseOrder
 */
export const updatePurchaseOrder = (
    id: number,
    purchaseOrder: PurchaseOrder,
 ) => {
      
      
      return customMutator<PurchaseOrder>(
      {url: `/api/purchasing/purchaseOrder/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: purchaseOrder
    },
      );
    }
  


export const getUpdatePurchaseOrderMutationOptions = <TData = Awaited<ReturnType<typeof updatePurchaseOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PurchaseOrder}, TContext>, }
) => {
const mutationKey = ['updatePurchaseOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePurchaseOrder>>, {id: number;data: PurchaseOrder}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePurchaseOrder(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: PurchaseOrder}, TContext>}

    export type UpdatePurchaseOrderMutationResult = NonNullable<Awaited<ReturnType<typeof updatePurchaseOrder>>>
    export type UpdatePurchaseOrderMutationBody = PurchaseOrder
    export type UpdatePurchaseOrderMutationError = ErrorResponse

    export const useUpdatePurchaseOrder = <TData = Awaited<ReturnType<typeof updatePurchaseOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PurchaseOrder}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: PurchaseOrder},
        TContext
      > => {

      const mutationOptions = getUpdatePurchaseOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete PurchaseOrder
 */
export const deletePurchaseOrder = (
    id: number,
 ) => {
      
      
      return customMutator<PurchaseOrder>(
      {url: `/api/purchasing/purchaseOrder/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePurchaseOrderMutationOptions = <TData = Awaited<ReturnType<typeof deletePurchaseOrder>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deletePurchaseOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePurchaseOrder>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deletePurchaseOrder(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeletePurchaseOrderMutationResult = NonNullable<Awaited<ReturnType<typeof deletePurchaseOrder>>>
    
    export type DeletePurchaseOrderMutationError = ResponseBase

    export const useDeletePurchaseOrder = <TData = Awaited<ReturnType<typeof deletePurchaseOrder>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeletePurchaseOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ProposalRequest
 */
export const getProposalRequest = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProposalRequest>(
      {url: `/api/purchasing/proposalRequest/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProposalRequestQueryKey = (id: number,) => {
    return [`/api/purchasing/proposalRequest/${id}`] as const;
    }

    
export const getGetProposalRequestQueryOptions = <TData = Awaited<ReturnType<typeof getProposalRequest>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProposalRequestQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProposalRequest>>> = ({ signal }) => getProposalRequest(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProposalRequestQueryResult = NonNullable<Awaited<ReturnType<typeof getProposalRequest>>>
export type GetProposalRequestQueryError = ErrorResponse


export function useGetProposalRequest<TData = Awaited<ReturnType<typeof getProposalRequest>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProposalRequest>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposalRequest<TData = Awaited<ReturnType<typeof getProposalRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProposalRequest>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposalRequest<TData = Awaited<ReturnType<typeof getProposalRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProposalRequest<TData = Awaited<ReturnType<typeof getProposalRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProposalRequestQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProposalRequestSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProposalRequest>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProposalRequestQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProposalRequest>>> = ({ signal }) => getProposalRequest(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProposalRequestSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProposalRequest>>>
export type GetProposalRequestSuspenseQueryError = ErrorResponse


export function useGetProposalRequestSuspense<TData = Awaited<ReturnType<typeof getProposalRequest>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposalRequestSuspense<TData = Awaited<ReturnType<typeof getProposalRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposalRequestSuspense<TData = Awaited<ReturnType<typeof getProposalRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProposalRequestSuspense<TData = Awaited<ReturnType<typeof getProposalRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposalRequest>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProposalRequestSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ProposalRequest
 */
export const updateProposalRequest = (
    id: number,
    proposalRequest: ProposalRequest,
 ) => {
      
      
      return customMutator<ProposalRequest>(
      {url: `/api/purchasing/proposalRequest/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: proposalRequest
    },
      );
    }
  


export const getUpdateProposalRequestMutationOptions = <TData = Awaited<ReturnType<typeof updateProposalRequest>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProposalRequest}, TContext>, }
) => {
const mutationKey = ['updateProposalRequest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProposalRequest>>, {id: number;data: ProposalRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProposalRequest(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ProposalRequest}, TContext>}

    export type UpdateProposalRequestMutationResult = NonNullable<Awaited<ReturnType<typeof updateProposalRequest>>>
    export type UpdateProposalRequestMutationBody = ProposalRequest
    export type UpdateProposalRequestMutationError = ErrorResponse

    export const useUpdateProposalRequest = <TData = Awaited<ReturnType<typeof updateProposalRequest>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProposalRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ProposalRequest},
        TContext
      > => {

      const mutationOptions = getUpdateProposalRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ProposalRequest
 */
export const deleteProposalRequest = (
    id: number,
 ) => {
      
      
      return customMutator<ProposalRequest>(
      {url: `/api/purchasing/proposalRequest/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProposalRequestMutationOptions = <TData = Awaited<ReturnType<typeof deleteProposalRequest>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteProposalRequest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProposalRequest>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProposalRequest(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProposalRequestMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProposalRequest>>>
    
    export type DeleteProposalRequestMutationError = ResponseBase

    export const useDeleteProposalRequest = <TData = Awaited<ReturnType<typeof deleteProposalRequest>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProposalRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Invoice
 */
export const getInvoice = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Invoice>(
      {url: `/api/purchasing/invoice/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetInvoiceQueryKey = (id: number,) => {
    return [`/api/purchasing/invoice/${id}`] as const;
    }

    
export const getGetInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInvoice>>> = ({ signal }) => getInvoice(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof getInvoice>>>
export type GetInvoiceQueryError = ErrorResponse


export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetInvoiceQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetInvoiceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInvoice>>> = ({ signal }) => getInvoice(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInvoiceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getInvoice>>>
export type GetInvoiceSuspenseQueryError = ErrorResponse


export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetInvoiceSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Invoice
 */
export const updateInvoice = (
    id: number,
    invoice: Invoice,
 ) => {
      
      
      return customMutator<Invoice>(
      {url: `/api/purchasing/invoice/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: invoice
    },
      );
    }
  


export const getUpdateInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof updateInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Invoice}, TContext>, }
) => {
const mutationKey = ['updateInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateInvoice>>, {id: number;data: Invoice}> = (props) => {
          const {id,data} = props ?? {};

          return  updateInvoice(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Invoice}, TContext>}

    export type UpdateInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof updateInvoice>>>
    export type UpdateInvoiceMutationBody = Invoice
    export type UpdateInvoiceMutationError = ErrorResponse

    export const useUpdateInvoice = <TData = Awaited<ReturnType<typeof updateInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Invoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Invoice},
        TContext
      > => {

      const mutationOptions = getUpdateInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Invoice by document reference
 */
export const deleteInvoice = (
    id: number,
 ) => {
      
      
      return customMutator<Invoice>(
      {url: `/api/purchasing/invoice/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof deleteInvoice>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteInvoice>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteInvoice(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteInvoice>>>
    
    export type DeleteInvoiceMutationError = unknown

    export const useDeleteInvoice = <TData = Awaited<ReturnType<typeof deleteInvoice>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Current Account Transaction
 */
export const getCurrentAccountTransaction = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccountTransaction>(
      {url: `/api/purchasing/currentAccountTransaction/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurrentAccountTransactionQueryKey = (id: number,) => {
    return [`/api/purchasing/currentAccountTransaction/${id}`] as const;
    }

    
export const getGetCurrentAccountTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountTransaction>>> = ({ signal }) => getCurrentAccountTransaction(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountTransaction>>>
export type GetCurrentAccountTransactionQueryError = ErrorResponse


export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountTransactionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentAccountTransactionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountTransaction>>> = ({ signal }) => getCurrentAccountTransaction(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountTransactionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountTransaction>>>
export type GetCurrentAccountTransactionSuspenseQueryError = ErrorResponse


export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountTransactionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Current Account Transaction
 */
export const updateCurrentAccountTransaction = (
    id: number,
    currentAccountTransaction: CurrentAccountTransaction,
 ) => {
      
      
      return customMutator<CurrentAccountTransaction>(
      {url: `/api/purchasing/currentAccountTransaction/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: currentAccountTransaction
    },
      );
    }
  


export const getUpdateCurrentAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof updateCurrentAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountTransaction}, TContext>, }
) => {
const mutationKey = ['updateCurrentAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentAccountTransaction>>, {id: number;data: CurrentAccountTransaction}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurrentAccountTransaction(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CurrentAccountTransaction}, TContext>}

    export type UpdateCurrentAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentAccountTransaction>>>
    export type UpdateCurrentAccountTransactionMutationBody = CurrentAccountTransaction
    export type UpdateCurrentAccountTransactionMutationError = ErrorResponse

    export const useUpdateCurrentAccountTransaction = <TData = Awaited<ReturnType<typeof updateCurrentAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CurrentAccountTransaction},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Current Account Transaction by document reference
 */
export const deleteCurrentAccountTransaction = (
    id: number,
 ) => {
      
      
      return customMutator<CurrentAccountTransaction>(
      {url: `/api/purchasing/currentAccountTransaction/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCurrentAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCurrentAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurrentAccountTransaction(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCurrentAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>>
    
    export type DeleteCurrentAccountTransactionMutationError = unknown

    export const useDeleteCurrentAccountTransaction = <TData = Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurrentAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get CurrentAccountBankAccount
 */
export const getCurrentAccountBankAccount = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccountBankAccount>(
      {url: `/api/purchasing/currentAccountBankAccount/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurrentAccountBankAccountQueryKey = (id: number,) => {
    return [`/api/purchasing/currentAccountBankAccount/${id}`] as const;
    }

    
export const getGetCurrentAccountBankAccountQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>> = ({ signal }) => getCurrentAccountBankAccount(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountBankAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>>
export type GetCurrentAccountBankAccountQueryError = ErrorResponse


export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountBankAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentAccountBankAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>> = ({ signal }) => getCurrentAccountBankAccount(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountBankAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>>
export type GetCurrentAccountBankAccountSuspenseQueryError = ErrorResponse


export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountBankAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update CurrentAccountBankAccount
 */
export const updateCurrentAccountBankAccount = (
    id: number,
    currentAccountBankAccount: CurrentAccountBankAccount,
 ) => {
      
      
      return customMutator<CurrentAccountBankAccount>(
      {url: `/api/purchasing/currentAccountBankAccount/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: currentAccountBankAccount
    },
      );
    }
  


export const getUpdateCurrentAccountBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountBankAccount}, TContext>, }
) => {
const mutationKey = ['updateCurrentAccountBankAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>, {id: number;data: CurrentAccountBankAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurrentAccountBankAccount(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CurrentAccountBankAccount}, TContext>}

    export type UpdateCurrentAccountBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>>
    export type UpdateCurrentAccountBankAccountMutationBody = CurrentAccountBankAccount
    export type UpdateCurrentAccountBankAccountMutationError = ErrorResponse

    export const useUpdateCurrentAccountBankAccount = <TData = Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountBankAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CurrentAccountBankAccount},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentAccountBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete CurrentAccountBankAccount
 */
export const deleteCurrentAccountBankAccount = (
    id: number,
 ) => {
      
      
      return customMutator<CurrentAccountBankAccount>(
      {url: `/api/purchasing/currentAccountBankAccount/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCurrentAccountBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCurrentAccountBankAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurrentAccountBankAccount(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCurrentAccountBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>>
    
    export type DeleteCurrentAccountBankAccountMutationError = ResponseBase

    export const useDeleteCurrentAccountBankAccount = <TData = Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurrentAccountBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Current Account
 */
export const getCurrentAccount = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccount>(
      {url: `/api/purchasing/currentAccount/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurrentAccountQueryKey = (id: number,) => {
    return [`/api/purchasing/currentAccount/${id}`] as const;
    }

    
export const getGetCurrentAccountQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccount>>> = ({ signal }) => getCurrentAccount(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccount>>>
export type GetCurrentAccountQueryError = ErrorResponse


export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccount>>> = ({ signal }) => getCurrentAccount(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccount>>>
export type GetCurrentAccountSuspenseQueryError = ErrorResponse


export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Current Account
 */
export const updateCurrentAccount = (
    id: number,
    currentAccount: CurrentAccount,
 ) => {
      
      
      return customMutator<CurrentAccount>(
      {url: `/api/purchasing/currentAccount/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: currentAccount
    },
      );
    }
  


export const getUpdateCurrentAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateCurrentAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccount}, TContext>, }
) => {
const mutationKey = ['updateCurrentAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentAccount>>, {id: number;data: CurrentAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurrentAccount(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CurrentAccount}, TContext>}

    export type UpdateCurrentAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentAccount>>>
    export type UpdateCurrentAccountMutationBody = CurrentAccount
    export type UpdateCurrentAccountMutationError = ErrorResponse

    export const useUpdateCurrentAccount = <TData = Awaited<ReturnType<typeof updateCurrentAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CurrentAccount},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Current Account by document reference
 */
export const deleteCurrentAccount = (
    id: number,
 ) => {
      
      
      return customMutator<CurrentAccount>(
      {url: `/api/purchasing/currentAccount/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCurrentAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteCurrentAccount>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCurrentAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrentAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurrentAccount(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCurrentAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrentAccount>>>
    
    export type DeleteCurrentAccountMutationError = unknown

    export const useDeleteCurrentAccount = <TData = Awaited<ReturnType<typeof deleteCurrentAccount>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurrentAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get AdditionalCost
 */
export const getAdditionalCost = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AdditionalCost>(
      {url: `/api/purchasing/additionalCost/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAdditionalCostQueryKey = (id: number,) => {
    return [`/api/purchasing/additionalCost/${id}`] as const;
    }

    
export const getGetAdditionalCostQueryOptions = <TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdditionalCostQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdditionalCost>>> = ({ signal }) => getAdditionalCost(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdditionalCostQueryResult = NonNullable<Awaited<ReturnType<typeof getAdditionalCost>>>
export type GetAdditionalCostQueryError = ErrorResponse


export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdditionalCost>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdditionalCost>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdditionalCostQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdditionalCostSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdditionalCostQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdditionalCost>>> = ({ signal }) => getAdditionalCost(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdditionalCostSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdditionalCost>>>
export type GetAdditionalCostSuspenseQueryError = ErrorResponse


export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdditionalCostSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update AdditionalCost
 */
export const updateAdditionalCost = (
    id: number,
    additionalCost: AdditionalCost,
 ) => {
      
      
      return customMutator<AdditionalCost>(
      {url: `/api/purchasing/additionalCost/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: additionalCost
    },
      );
    }
  


export const getUpdateAdditionalCostMutationOptions = <TData = Awaited<ReturnType<typeof updateAdditionalCost>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AdditionalCost}, TContext>, }
) => {
const mutationKey = ['updateAdditionalCost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdditionalCost>>, {id: number;data: AdditionalCost}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAdditionalCost(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: AdditionalCost}, TContext>}

    export type UpdateAdditionalCostMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdditionalCost>>>
    export type UpdateAdditionalCostMutationBody = AdditionalCost
    export type UpdateAdditionalCostMutationError = ErrorResponse

    export const useUpdateAdditionalCost = <TData = Awaited<ReturnType<typeof updateAdditionalCost>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AdditionalCost}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: AdditionalCost},
        TContext
      > => {

      const mutationOptions = getUpdateAdditionalCostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete AdditionalCost
 */
export const deleteAdditionalCost = (
    id: number,
 ) => {
      
      
      return customMutator<AdditionalCost>(
      {url: `/api/purchasing/additionalCost/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAdditionalCostMutationOptions = <TData = Awaited<ReturnType<typeof deleteAdditionalCost>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteAdditionalCost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAdditionalCost>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAdditionalCost(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteAdditionalCostMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAdditionalCost>>>
    
    export type DeleteAdditionalCostMutationError = ResponseBase

    export const useDeleteAdditionalCost = <TData = Awaited<ReturnType<typeof deleteAdditionalCost>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAdditionalCostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Project
 */
export const getProject = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Project>(
      {url: `/api/production/project/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProjectQueryKey = (id: number,) => {
    return [`/api/production/project/${id}`] as const;
    }

    
export const getGetProjectQueryOptions = <TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({ signal }) => getProject(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProjectQueryResult = NonNullable<Awaited<ReturnType<typeof getProject>>>
export type GetProjectQueryError = ErrorResponse


export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProjectQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProjectSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({ signal }) => getProject(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProjectSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProject>>>
export type GetProjectSuspenseQueryError = ErrorResponse


export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProjectSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Project
 */
export const updateProject = (
    id: number,
    project: Project,
 ) => {
      
      
      return customMutator<Project>(
      {url: `/api/production/project/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: project
    },
      );
    }
  


export const getUpdateProjectMutationOptions = <TData = Awaited<ReturnType<typeof updateProject>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Project}, TContext>, }
) => {
const mutationKey = ['updateProject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProject>>, {id: number;data: Project}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProject(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Project}, TContext>}

    export type UpdateProjectMutationResult = NonNullable<Awaited<ReturnType<typeof updateProject>>>
    export type UpdateProjectMutationBody = Project
    export type UpdateProjectMutationError = ErrorResponse

    export const useUpdateProject = <TData = Awaited<ReturnType<typeof updateProject>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Project}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Project},
        TContext
      > => {

      const mutationOptions = getUpdateProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Project
 */
export const deleteProject = (
    id: number,
 ) => {
      
      
      return customMutator<Project>(
      {url: `/api/production/project/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProjectMutationOptions = <TData = Awaited<ReturnType<typeof deleteProject>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteProject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProject>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProject(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProject>>>
    
    export type DeleteProjectMutationError = ResponseBase

    export const useDeleteProject = <TData = Awaited<ReturnType<typeof deleteProject>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get WorkOrderConnection
 */
export const getWorkOrderConnection = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<WorkOrderConnection>(
      {url: `/api/planning/workOrderConnection/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetWorkOrderConnectionQueryKey = (id: number,) => {
    return [`/api/planning/workOrderConnection/${id}`] as const;
    }

    
export const getGetWorkOrderConnectionQueryOptions = <TData = Awaited<ReturnType<typeof getWorkOrderConnection>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkOrderConnectionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkOrderConnection>>> = ({ signal }) => getWorkOrderConnection(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkOrderConnectionQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkOrderConnection>>>
export type GetWorkOrderConnectionQueryError = ErrorResponse


export function useGetWorkOrderConnection<TData = Awaited<ReturnType<typeof getWorkOrderConnection>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkOrderConnection>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkOrderConnection<TData = Awaited<ReturnType<typeof getWorkOrderConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkOrderConnection>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkOrderConnection<TData = Awaited<ReturnType<typeof getWorkOrderConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetWorkOrderConnection<TData = Awaited<ReturnType<typeof getWorkOrderConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkOrderConnectionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWorkOrderConnectionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getWorkOrderConnection>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkOrderConnectionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkOrderConnection>>> = ({ signal }) => getWorkOrderConnection(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkOrderConnectionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkOrderConnection>>>
export type GetWorkOrderConnectionSuspenseQueryError = ErrorResponse


export function useGetWorkOrderConnectionSuspense<TData = Awaited<ReturnType<typeof getWorkOrderConnection>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkOrderConnectionSuspense<TData = Awaited<ReturnType<typeof getWorkOrderConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkOrderConnectionSuspense<TData = Awaited<ReturnType<typeof getWorkOrderConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetWorkOrderConnectionSuspense<TData = Awaited<ReturnType<typeof getWorkOrderConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrderConnection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkOrderConnectionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update WorkOrderConnection
 */
export const updateWorkOrderConnection = (
    id: number,
    workOrderConnection: WorkOrderConnection,
 ) => {
      
      
      return customMutator<WorkOrderConnection>(
      {url: `/api/planning/workOrderConnection/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: workOrderConnection
    },
      );
    }
  


export const getUpdateWorkOrderConnectionMutationOptions = <TData = Awaited<ReturnType<typeof updateWorkOrderConnection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: WorkOrderConnection}, TContext>, }
) => {
const mutationKey = ['updateWorkOrderConnection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWorkOrderConnection>>, {id: number;data: WorkOrderConnection}> = (props) => {
          const {id,data} = props ?? {};

          return  updateWorkOrderConnection(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: WorkOrderConnection}, TContext>}

    export type UpdateWorkOrderConnectionMutationResult = NonNullable<Awaited<ReturnType<typeof updateWorkOrderConnection>>>
    export type UpdateWorkOrderConnectionMutationBody = WorkOrderConnection
    export type UpdateWorkOrderConnectionMutationError = ErrorResponse

    export const useUpdateWorkOrderConnection = <TData = Awaited<ReturnType<typeof updateWorkOrderConnection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: WorkOrderConnection}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: WorkOrderConnection},
        TContext
      > => {

      const mutationOptions = getUpdateWorkOrderConnectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete WorkOrderConnection
 */
export const deleteWorkOrderConnection = (
    id: number,
 ) => {
      
      
      return customMutator<WorkOrderConnection>(
      {url: `/api/planning/workOrderConnection/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteWorkOrderConnectionMutationOptions = <TData = Awaited<ReturnType<typeof deleteWorkOrderConnection>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteWorkOrderConnection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWorkOrderConnection>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteWorkOrderConnection(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteWorkOrderConnectionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWorkOrderConnection>>>
    
    export type DeleteWorkOrderConnectionMutationError = ResponseBase

    export const useDeleteWorkOrderConnection = <TData = Awaited<ReturnType<typeof deleteWorkOrderConnection>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteWorkOrderConnectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get WorkOrder
 */
export const getWorkOrder = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<WorkOrder>(
      {url: `/api/planning/workOrder/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetWorkOrderQueryKey = (id: number,) => {
    return [`/api/planning/workOrder/${id}`] as const;
    }

    
export const getGetWorkOrderQueryOptions = <TData = Awaited<ReturnType<typeof getWorkOrder>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkOrderQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkOrder>>> = ({ signal }) => getWorkOrder(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkOrderQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkOrder>>>
export type GetWorkOrderQueryError = ErrorResponse


export function useGetWorkOrder<TData = Awaited<ReturnType<typeof getWorkOrder>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkOrder>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkOrder<TData = Awaited<ReturnType<typeof getWorkOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkOrder>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkOrder<TData = Awaited<ReturnType<typeof getWorkOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetWorkOrder<TData = Awaited<ReturnType<typeof getWorkOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkOrderQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWorkOrderSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getWorkOrder>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkOrderQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkOrder>>> = ({ signal }) => getWorkOrder(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkOrderSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkOrder>>>
export type GetWorkOrderSuspenseQueryError = ErrorResponse


export function useGetWorkOrderSuspense<TData = Awaited<ReturnType<typeof getWorkOrder>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkOrderSuspense<TData = Awaited<ReturnType<typeof getWorkOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkOrderSuspense<TData = Awaited<ReturnType<typeof getWorkOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetWorkOrderSuspense<TData = Awaited<ReturnType<typeof getWorkOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWorkOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkOrderSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update WorkOrder
 */
export const updateWorkOrder = (
    id: number,
    workOrder: WorkOrder,
 ) => {
      
      
      return customMutator<WorkOrder>(
      {url: `/api/planning/workOrder/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: workOrder
    },
      );
    }
  


export const getUpdateWorkOrderMutationOptions = <TData = Awaited<ReturnType<typeof updateWorkOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: WorkOrder}, TContext>, }
) => {
const mutationKey = ['updateWorkOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWorkOrder>>, {id: number;data: WorkOrder}> = (props) => {
          const {id,data} = props ?? {};

          return  updateWorkOrder(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: WorkOrder}, TContext>}

    export type UpdateWorkOrderMutationResult = NonNullable<Awaited<ReturnType<typeof updateWorkOrder>>>
    export type UpdateWorkOrderMutationBody = WorkOrder
    export type UpdateWorkOrderMutationError = ErrorResponse

    export const useUpdateWorkOrder = <TData = Awaited<ReturnType<typeof updateWorkOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: WorkOrder}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: WorkOrder},
        TContext
      > => {

      const mutationOptions = getUpdateWorkOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete WorkOrder
 */
export const deleteWorkOrder = (
    id: number,
 ) => {
      
      
      return customMutator<WorkOrder>(
      {url: `/api/planning/workOrder/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteWorkOrderMutationOptions = <TData = Awaited<ReturnType<typeof deleteWorkOrder>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteWorkOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWorkOrder>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteWorkOrder(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteWorkOrderMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWorkOrder>>>
    
    export type DeleteWorkOrderMutationError = ResponseBase

    export const useDeleteWorkOrder = <TData = Awaited<ReturnType<typeof deleteWorkOrder>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteWorkOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get WBS
 */
export const getWBS = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Wbs>(
      {url: `/api/planning/wbs/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetWBSQueryKey = (id: number,) => {
    return [`/api/planning/wbs/${id}`] as const;
    }

    
export const getGetWBSQueryOptions = <TData = Awaited<ReturnType<typeof getWBS>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWBSQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWBS>>> = ({ signal }) => getWBS(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWBSQueryResult = NonNullable<Awaited<ReturnType<typeof getWBS>>>
export type GetWBSQueryError = ErrorResponse


export function useGetWBS<TData = Awaited<ReturnType<typeof getWBS>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWBS>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWBS<TData = Awaited<ReturnType<typeof getWBS>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWBS>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWBS<TData = Awaited<ReturnType<typeof getWBS>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetWBS<TData = Awaited<ReturnType<typeof getWBS>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWBSQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWBSSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getWBS>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWBSQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWBS>>> = ({ signal }) => getWBS(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWBSSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getWBS>>>
export type GetWBSSuspenseQueryError = ErrorResponse


export function useGetWBSSuspense<TData = Awaited<ReturnType<typeof getWBS>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWBSSuspense<TData = Awaited<ReturnType<typeof getWBS>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWBSSuspense<TData = Awaited<ReturnType<typeof getWBS>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetWBSSuspense<TData = Awaited<ReturnType<typeof getWBS>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getWBS>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWBSSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update WBS
 */
export const updateWBS = (
    id: number,
    wbs: Wbs,
 ) => {
      
      
      return customMutator<Wbs>(
      {url: `/api/planning/wbs/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: wbs
    },
      );
    }
  


export const getUpdateWBSMutationOptions = <TData = Awaited<ReturnType<typeof updateWBS>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Wbs}, TContext>, }
) => {
const mutationKey = ['updateWBS'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWBS>>, {id: number;data: Wbs}> = (props) => {
          const {id,data} = props ?? {};

          return  updateWBS(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Wbs}, TContext>}

    export type UpdateWBSMutationResult = NonNullable<Awaited<ReturnType<typeof updateWBS>>>
    export type UpdateWBSMutationBody = Wbs
    export type UpdateWBSMutationError = ErrorResponse

    export const useUpdateWBS = <TData = Awaited<ReturnType<typeof updateWBS>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Wbs}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Wbs},
        TContext
      > => {

      const mutationOptions = getUpdateWBSMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete WBS
 */
export const deleteWBS = (
    id: number,
 ) => {
      
      
      return customMutator<Wbs>(
      {url: `/api/planning/wbs/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteWBSMutationOptions = <TData = Awaited<ReturnType<typeof deleteWBS>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteWBS'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWBS>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteWBS(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteWBSMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWBS>>>
    
    export type DeleteWBSMutationError = ResponseBase

    export const useDeleteWBS = <TData = Awaited<ReturnType<typeof deleteWBS>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteWBSMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ProductionPlanProduct
 */
export const getProductionPlanProduct = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductionPlanProduct>(
      {url: `/api/planning/productionPlanProduct/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProductionPlanProductQueryKey = (id: number,) => {
    return [`/api/planning/productionPlanProduct/${id}`] as const;
    }

    
export const getGetProductionPlanProductQueryOptions = <TData = Awaited<ReturnType<typeof getProductionPlanProduct>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductionPlanProductQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductionPlanProduct>>> = ({ signal }) => getProductionPlanProduct(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductionPlanProductQueryResult = NonNullable<Awaited<ReturnType<typeof getProductionPlanProduct>>>
export type GetProductionPlanProductQueryError = ErrorResponse


export function useGetProductionPlanProduct<TData = Awaited<ReturnType<typeof getProductionPlanProduct>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductionPlanProduct>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductionPlanProduct<TData = Awaited<ReturnType<typeof getProductionPlanProduct>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductionPlanProduct>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductionPlanProduct<TData = Awaited<ReturnType<typeof getProductionPlanProduct>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductionPlanProduct<TData = Awaited<ReturnType<typeof getProductionPlanProduct>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductionPlanProductQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductionPlanProductSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductionPlanProduct>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductionPlanProductQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductionPlanProduct>>> = ({ signal }) => getProductionPlanProduct(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductionPlanProductSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductionPlanProduct>>>
export type GetProductionPlanProductSuspenseQueryError = ErrorResponse


export function useGetProductionPlanProductSuspense<TData = Awaited<ReturnType<typeof getProductionPlanProduct>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductionPlanProductSuspense<TData = Awaited<ReturnType<typeof getProductionPlanProduct>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductionPlanProductSuspense<TData = Awaited<ReturnType<typeof getProductionPlanProduct>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductionPlanProductSuspense<TData = Awaited<ReturnType<typeof getProductionPlanProduct>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductionPlanProduct>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductionPlanProductSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ProductionPlanProduct
 */
export const updateProductionPlanProduct = (
    id: number,
    productionPlanProduct: ProductionPlanProduct,
 ) => {
      
      
      return customMutator<ProductionPlanProduct>(
      {url: `/api/planning/productionPlanProduct/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: productionPlanProduct
    },
      );
    }
  


export const getUpdateProductionPlanProductMutationOptions = <TData = Awaited<ReturnType<typeof updateProductionPlanProduct>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductionPlanProduct}, TContext>, }
) => {
const mutationKey = ['updateProductionPlanProduct'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProductionPlanProduct>>, {id: number;data: ProductionPlanProduct}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProductionPlanProduct(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ProductionPlanProduct}, TContext>}

    export type UpdateProductionPlanProductMutationResult = NonNullable<Awaited<ReturnType<typeof updateProductionPlanProduct>>>
    export type UpdateProductionPlanProductMutationBody = ProductionPlanProduct
    export type UpdateProductionPlanProductMutationError = ErrorResponse

    export const useUpdateProductionPlanProduct = <TData = Awaited<ReturnType<typeof updateProductionPlanProduct>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductionPlanProduct}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ProductionPlanProduct},
        TContext
      > => {

      const mutationOptions = getUpdateProductionPlanProductMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ProductionPlanProduct
 */
export const deleteProductionPlanProduct = (
    id: number,
 ) => {
      
      
      return customMutator<ProductionPlanProduct>(
      {url: `/api/planning/productionPlanProduct/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProductionPlanProductMutationOptions = <TData = Awaited<ReturnType<typeof deleteProductionPlanProduct>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteProductionPlanProduct'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductionPlanProduct>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProductionPlanProduct(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProductionPlanProductMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductionPlanProduct>>>
    
    export type DeleteProductionPlanProductMutationError = ResponseBase

    export const useDeleteProductionPlanProduct = <TData = Awaited<ReturnType<typeof deleteProductionPlanProduct>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProductionPlanProductMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ProductPlan
 */
export const getProductPlan = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductPlan>(
      {url: `/api/planning/productPlan/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProductPlanQueryKey = (id: number,) => {
    return [`/api/planning/productPlan/${id}`] as const;
    }

    
export const getGetProductPlanQueryOptions = <TData = Awaited<ReturnType<typeof getProductPlan>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductPlanQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductPlan>>> = ({ signal }) => getProductPlan(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductPlanQueryResult = NonNullable<Awaited<ReturnType<typeof getProductPlan>>>
export type GetProductPlanQueryError = ErrorResponse


export function useGetProductPlan<TData = Awaited<ReturnType<typeof getProductPlan>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductPlan>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductPlan<TData = Awaited<ReturnType<typeof getProductPlan>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductPlan>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductPlan<TData = Awaited<ReturnType<typeof getProductPlan>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductPlan<TData = Awaited<ReturnType<typeof getProductPlan>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductPlanQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductPlanSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductPlan>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductPlanQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductPlan>>> = ({ signal }) => getProductPlan(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductPlanSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductPlan>>>
export type GetProductPlanSuspenseQueryError = ErrorResponse


export function useGetProductPlanSuspense<TData = Awaited<ReturnType<typeof getProductPlan>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductPlanSuspense<TData = Awaited<ReturnType<typeof getProductPlan>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductPlanSuspense<TData = Awaited<ReturnType<typeof getProductPlan>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductPlanSuspense<TData = Awaited<ReturnType<typeof getProductPlan>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductPlan>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductPlanSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ProductPlan
 */
export const updateProductPlan = (
    id: number,
    productPlan: ProductPlan,
 ) => {
      
      
      return customMutator<ProductPlan>(
      {url: `/api/planning/productPlan/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: productPlan
    },
      );
    }
  


export const getUpdateProductPlanMutationOptions = <TData = Awaited<ReturnType<typeof updateProductPlan>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductPlan}, TContext>, }
) => {
const mutationKey = ['updateProductPlan'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProductPlan>>, {id: number;data: ProductPlan}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProductPlan(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ProductPlan}, TContext>}

    export type UpdateProductPlanMutationResult = NonNullable<Awaited<ReturnType<typeof updateProductPlan>>>
    export type UpdateProductPlanMutationBody = ProductPlan
    export type UpdateProductPlanMutationError = ErrorResponse

    export const useUpdateProductPlan = <TData = Awaited<ReturnType<typeof updateProductPlan>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductPlan}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ProductPlan},
        TContext
      > => {

      const mutationOptions = getUpdateProductPlanMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ProductPlan
 */
export const deleteProductPlan = (
    id: number,
 ) => {
      
      
      return customMutator<ProductPlan>(
      {url: `/api/planning/productPlan/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProductPlanMutationOptions = <TData = Awaited<ReturnType<typeof deleteProductPlan>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteProductPlan'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductPlan>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProductPlan(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProductPlanMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductPlan>>>
    
    export type DeleteProductPlanMutationError = ResponseBase

    export const useDeleteProductPlan = <TData = Awaited<ReturnType<typeof deleteProductPlan>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProductPlanMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ActivityConnection
 */
export const getActivityConnection = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ActivityConnection>(
      {url: `/api/planning/activityConnection/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetActivityConnectionQueryKey = (id: number,) => {
    return [`/api/planning/activityConnection/${id}`] as const;
    }

    
export const getGetActivityConnectionQueryOptions = <TData = Awaited<ReturnType<typeof getActivityConnection>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivityConnectionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivityConnection>>> = ({ signal }) => getActivityConnection(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetActivityConnectionQueryResult = NonNullable<Awaited<ReturnType<typeof getActivityConnection>>>
export type GetActivityConnectionQueryError = ErrorResponse


export function useGetActivityConnection<TData = Awaited<ReturnType<typeof getActivityConnection>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityConnection>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActivityConnection<TData = Awaited<ReturnType<typeof getActivityConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityConnection>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActivityConnection<TData = Awaited<ReturnType<typeof getActivityConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetActivityConnection<TData = Awaited<ReturnType<typeof getActivityConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetActivityConnectionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActivityConnectionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getActivityConnection>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivityConnectionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivityConnection>>> = ({ signal }) => getActivityConnection(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetActivityConnectionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getActivityConnection>>>
export type GetActivityConnectionSuspenseQueryError = ErrorResponse


export function useGetActivityConnectionSuspense<TData = Awaited<ReturnType<typeof getActivityConnection>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActivityConnectionSuspense<TData = Awaited<ReturnType<typeof getActivityConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActivityConnectionSuspense<TData = Awaited<ReturnType<typeof getActivityConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetActivityConnectionSuspense<TData = Awaited<ReturnType<typeof getActivityConnection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivityConnection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetActivityConnectionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ActivityConnection
 */
export const updateActivityConnection = (
    id: number,
    activityConnection: ActivityConnection,
 ) => {
      
      
      return customMutator<ActivityConnection>(
      {url: `/api/planning/activityConnection/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: activityConnection
    },
      );
    }
  


export const getUpdateActivityConnectionMutationOptions = <TData = Awaited<ReturnType<typeof updateActivityConnection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ActivityConnection}, TContext>, }
) => {
const mutationKey = ['updateActivityConnection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateActivityConnection>>, {id: number;data: ActivityConnection}> = (props) => {
          const {id,data} = props ?? {};

          return  updateActivityConnection(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ActivityConnection}, TContext>}

    export type UpdateActivityConnectionMutationResult = NonNullable<Awaited<ReturnType<typeof updateActivityConnection>>>
    export type UpdateActivityConnectionMutationBody = ActivityConnection
    export type UpdateActivityConnectionMutationError = ErrorResponse

    export const useUpdateActivityConnection = <TData = Awaited<ReturnType<typeof updateActivityConnection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ActivityConnection}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ActivityConnection},
        TContext
      > => {

      const mutationOptions = getUpdateActivityConnectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ActivityConnection
 */
export const deleteActivityConnection = (
    id: number,
 ) => {
      
      
      return customMutator<ActivityConnection>(
      {url: `/api/planning/activityConnection/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteActivityConnectionMutationOptions = <TData = Awaited<ReturnType<typeof deleteActivityConnection>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteActivityConnection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteActivityConnection>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteActivityConnection(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteActivityConnectionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteActivityConnection>>>
    
    export type DeleteActivityConnectionMutationError = ResponseBase

    export const useDeleteActivityConnection = <TData = Awaited<ReturnType<typeof deleteActivityConnection>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteActivityConnectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Activity
 */
export const getActivity = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Activity>(
      {url: `/api/planning/activity/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetActivityQueryKey = (id: number,) => {
    return [`/api/planning/activity/${id}`] as const;
    }

    
export const getGetActivityQueryOptions = <TData = Awaited<ReturnType<typeof getActivity>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivityQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivity>>> = ({ signal }) => getActivity(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetActivityQueryResult = NonNullable<Awaited<ReturnType<typeof getActivity>>>
export type GetActivityQueryError = ErrorResponse


export function useGetActivity<TData = Awaited<ReturnType<typeof getActivity>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivity>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActivity<TData = Awaited<ReturnType<typeof getActivity>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivity>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActivity<TData = Awaited<ReturnType<typeof getActivity>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetActivity<TData = Awaited<ReturnType<typeof getActivity>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetActivityQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActivitySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getActivity>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivityQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivity>>> = ({ signal }) => getActivity(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetActivitySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getActivity>>>
export type GetActivitySuspenseQueryError = ErrorResponse


export function useGetActivitySuspense<TData = Awaited<ReturnType<typeof getActivity>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActivitySuspense<TData = Awaited<ReturnType<typeof getActivity>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActivitySuspense<TData = Awaited<ReturnType<typeof getActivity>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetActivitySuspense<TData = Awaited<ReturnType<typeof getActivity>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActivity>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetActivitySuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Activity
 */
export const updateActivity = (
    id: number,
    activity: Activity,
 ) => {
      
      
      return customMutator<Activity>(
      {url: `/api/planning/activity/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: activity
    },
      );
    }
  


export const getUpdateActivityMutationOptions = <TData = Awaited<ReturnType<typeof updateActivity>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Activity}, TContext>, }
) => {
const mutationKey = ['updateActivity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateActivity>>, {id: number;data: Activity}> = (props) => {
          const {id,data} = props ?? {};

          return  updateActivity(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Activity}, TContext>}

    export type UpdateActivityMutationResult = NonNullable<Awaited<ReturnType<typeof updateActivity>>>
    export type UpdateActivityMutationBody = Activity
    export type UpdateActivityMutationError = ErrorResponse

    export const useUpdateActivity = <TData = Awaited<ReturnType<typeof updateActivity>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Activity}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Activity},
        TContext
      > => {

      const mutationOptions = getUpdateActivityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Activity
 */
export const deleteActivity = (
    id: number,
 ) => {
      
      
      return customMutator<Activity>(
      {url: `/api/planning/activity/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteActivityMutationOptions = <TData = Awaited<ReturnType<typeof deleteActivity>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteActivity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteActivity>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteActivity(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteActivityMutationResult = NonNullable<Awaited<ReturnType<typeof deleteActivity>>>
    
    export type DeleteActivityMutationError = ResponseBase

    export const useDeleteActivity = <TData = Awaited<ReturnType<typeof deleteActivity>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteActivityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Time Keeping
 */
export const getTimeKeeping = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeKeeping>(
      {url: `/api/hr/timekeeping/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetTimeKeepingQueryKey = (id: number,) => {
    return [`/api/hr/timekeeping/${id}`] as const;
    }

    
export const getGetTimeKeepingQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeeping>>> = ({ signal }) => getTimeKeeping(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeeping>>>
export type GetTimeKeepingQueryError = ErrorResponse


export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeeping>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeeping>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeKeepingSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeeping>>> = ({ signal }) => getTimeKeeping(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeeping>>>
export type GetTimeKeepingSuspenseQueryError = ErrorResponse


export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Time Keeping
 */
export const updateTimeKeeping = (
    id: number,
    timeKeeping: TimeKeeping,
 ) => {
      
      
      return customMutator<TimeKeeping>(
      {url: `/api/hr/timekeeping/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: timeKeeping
    },
      );
    }
  


export const getUpdateTimeKeepingMutationOptions = <TData = Awaited<ReturnType<typeof updateTimeKeeping>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeKeeping}, TContext>, }
) => {
const mutationKey = ['updateTimeKeeping'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTimeKeeping>>, {id: number;data: TimeKeeping}> = (props) => {
          const {id,data} = props ?? {};

          return  updateTimeKeeping(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: TimeKeeping}, TContext>}

    export type UpdateTimeKeepingMutationResult = NonNullable<Awaited<ReturnType<typeof updateTimeKeeping>>>
    export type UpdateTimeKeepingMutationBody = TimeKeeping
    export type UpdateTimeKeepingMutationError = ErrorResponse

    export const useUpdateTimeKeeping = <TData = Awaited<ReturnType<typeof updateTimeKeeping>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeKeeping}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: TimeKeeping},
        TContext
      > => {

      const mutationOptions = getUpdateTimeKeepingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Time Keeping by document reference
 */
export const deleteTimeKeeping = (
    id: number,
 ) => {
      
      
      return customMutator<TimeKeeping>(
      {url: `/api/hr/timekeeping/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteTimeKeepingMutationOptions = <TData = Awaited<ReturnType<typeof deleteTimeKeeping>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteTimeKeeping'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTimeKeeping>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteTimeKeeping(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteTimeKeepingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTimeKeeping>>>
    
    export type DeleteTimeKeepingMutationError = ResponseBase

    export const useDeleteTimeKeeping = <TData = Awaited<ReturnType<typeof deleteTimeKeeping>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteTimeKeepingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Employee
 */
export const getEmployee = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Employee>(
      {url: `/api/hr/employee/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetEmployeeQueryKey = (id: number,) => {
    return [`/api/hr/employee/${id}`] as const;
    }

    
export const getGetEmployeeQueryOptions = <TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployee>>> = ({ signal }) => getEmployee(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployee>>>
export type GetEmployeeQueryError = ErrorResponse


export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployee>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployee>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetEmployeeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployee>>> = ({ signal }) => getEmployee(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployee>>>
export type GetEmployeeSuspenseQueryError = ErrorResponse


export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Employee
 */
export const updateEmployee = (
    id: number,
    employee: Employee,
 ) => {
      
      
      return customMutator<Employee>(
      {url: `/api/hr/employee/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: employee
    },
      );
    }
  


export const getUpdateEmployeeMutationOptions = <TData = Awaited<ReturnType<typeof updateEmployee>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Employee}, TContext>, }
) => {
const mutationKey = ['updateEmployee'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEmployee>>, {id: number;data: Employee}> = (props) => {
          const {id,data} = props ?? {};

          return  updateEmployee(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Employee}, TContext>}

    export type UpdateEmployeeMutationResult = NonNullable<Awaited<ReturnType<typeof updateEmployee>>>
    export type UpdateEmployeeMutationBody = Employee
    export type UpdateEmployeeMutationError = ErrorResponse

    export const useUpdateEmployee = <TData = Awaited<ReturnType<typeof updateEmployee>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Employee}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Employee},
        TContext
      > => {

      const mutationOptions = getUpdateEmployeeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Employee by document reference
 */
export const deleteEmployee = (
    id: number,
 ) => {
      
      
      return customMutator<Employee>(
      {url: `/api/hr/employee/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEmployeeMutationOptions = <TData = Awaited<ReturnType<typeof deleteEmployee>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteEmployee'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEmployee>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteEmployee(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteEmployeeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEmployee>>>
    
    export type DeleteEmployeeMutationError = unknown

    export const useDeleteEmployee = <TData = Awaited<ReturnType<typeof deleteEmployee>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteEmployeeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get TimeOff
 */
export const getTimeOff = (
    id: number,
    timeOffId: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeOff>(
      {url: `/api/hr/employee/${id}/timeoff/${timeOffId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetTimeOffQueryKey = (id: number,
    timeOffId: number,) => {
    return [`/api/hr/employee/${id}/timeoff/${timeOffId}`] as const;
    }

    
export const getGetTimeOffQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffQueryKey(id,timeOffId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOff>>> = ({ signal }) => getTimeOff(id,timeOffId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id && timeOffId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOff>>>
export type GetTimeOffQueryError = ResponseBase


export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOff>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOff>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffQueryOptions(id,timeOffId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeOffSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffQueryKey(id,timeOffId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOff>>> = ({ signal }) => getTimeOff(id,timeOffId, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOff>>>
export type GetTimeOffSuspenseQueryError = ResponseBase


export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffSuspenseQueryOptions(id,timeOffId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Timeoff
 */
export const updateTimeoff = (
    id: number,
    timeOffId: number,
    timeOff: TimeOff,
 ) => {
      
      
      return customMutator<TimeOff>(
      {url: `/api/hr/employee/${id}/timeoff/${timeOffId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: timeOff
    },
      );
    }
  


export const getUpdateTimeoffMutationOptions = <TData = Awaited<ReturnType<typeof updateTimeoff>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number;data: TimeOff}, TContext>, }
) => {
const mutationKey = ['updateTimeoff'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTimeoff>>, {id: number;timeOffId: number;data: TimeOff}> = (props) => {
          const {id,timeOffId,data} = props ?? {};

          return  updateTimeoff(id,timeOffId,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;timeOffId: number;data: TimeOff}, TContext>}

    export type UpdateTimeoffMutationResult = NonNullable<Awaited<ReturnType<typeof updateTimeoff>>>
    export type UpdateTimeoffMutationBody = TimeOff
    export type UpdateTimeoffMutationError = ErrorResponse

    export const useUpdateTimeoff = <TData = Awaited<ReturnType<typeof updateTimeoff>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number;data: TimeOff}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;timeOffId: number;data: TimeOff},
        TContext
      > => {

      const mutationOptions = getUpdateTimeoffMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete TimeOff
 */
export const deleteTimeOff = (
    id: number,
    timeOffId: number,
 ) => {
      
      
      return customMutator<TimeOff>(
      {url: `/api/hr/employee/${id}/timeoff/${timeOffId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteTimeOffMutationOptions = <TData = Awaited<ReturnType<typeof deleteTimeOff>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number}, TContext>, }
) => {
const mutationKey = ['deleteTimeOff'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTimeOff>>, {id: number;timeOffId: number}> = (props) => {
          const {id,timeOffId} = props ?? {};

          return  deleteTimeOff(id,timeOffId,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;timeOffId: number}, TContext>}

    export type DeleteTimeOffMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTimeOff>>>
    
    export type DeleteTimeOffMutationError = ResponseBase

    export const useDeleteTimeOff = <TData = Awaited<ReturnType<typeof deleteTimeOff>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;timeOffId: number},
        TContext
      > => {

      const mutationOptions = getDeleteTimeOffMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update Employee Payment
 */
export const updateEmployeePayments = (
    id: number,
    employeePayment: EmployeePayment[],
 ) => {
      
      
      return customMutator<EmployeePayment[]>(
      {url: `/api/hr/employee/${id}/payment`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: employeePayment
    },
      );
    }
  


export const getUpdateEmployeePaymentsMutationOptions = <TData = Awaited<ReturnType<typeof updateEmployeePayments>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, }
) => {
const mutationKey = ['updateEmployeePayments'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEmployeePayments>>, {id: number;data: EmployeePayment[]}> = (props) => {
          const {id,data} = props ?? {};

          return  updateEmployeePayments(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>}

    export type UpdateEmployeePaymentsMutationResult = NonNullable<Awaited<ReturnType<typeof updateEmployeePayments>>>
    export type UpdateEmployeePaymentsMutationBody = EmployeePayment[]
    export type UpdateEmployeePaymentsMutationError = ErrorResponse

    export const useUpdateEmployeePayments = <TData = Awaited<ReturnType<typeof updateEmployeePayments>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeePayment[]},
        TContext
      > => {

      const mutationOptions = getUpdateEmployeePaymentsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Employee Payments
 */
export const addEmployeePayment = (
    id: number,
    employeePayment: EmployeePayment[],
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeePayment[]>(
      {url: `/api/hr/employee/${id}/payment`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: employeePayment, signal
    },
      );
    }
  


export const getAddEmployeePaymentMutationOptions = <TData = Awaited<ReturnType<typeof addEmployeePayment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, }
) => {
const mutationKey = ['addEmployeePayment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addEmployeePayment>>, {id: number;data: EmployeePayment[]}> = (props) => {
          const {id,data} = props ?? {};

          return  addEmployeePayment(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>}

    export type AddEmployeePaymentMutationResult = NonNullable<Awaited<ReturnType<typeof addEmployeePayment>>>
    export type AddEmployeePaymentMutationBody = EmployeePayment[]
    export type AddEmployeePaymentMutationError = ErrorResponse

    export const useAddEmployeePayment = <TData = Awaited<ReturnType<typeof addEmployeePayment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeePayment[]},
        TContext
      > => {

      const mutationOptions = getAddEmployeePaymentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update Employee Overtime
 */
export const updateEmployeeOvertimes = (
    id: number,
    employeeOvertime: EmployeeOvertime[],
 ) => {
      
      
      return customMutator<EmployeeOvertime[]>(
      {url: `/api/hr/employee/${id}/overtime`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: employeeOvertime
    },
      );
    }
  


export const getUpdateEmployeeOvertimesMutationOptions = <TData = Awaited<ReturnType<typeof updateEmployeeOvertimes>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, }
) => {
const mutationKey = ['updateEmployeeOvertimes'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEmployeeOvertimes>>, {id: number;data: EmployeeOvertime[]}> = (props) => {
          const {id,data} = props ?? {};

          return  updateEmployeeOvertimes(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>}

    export type UpdateEmployeeOvertimesMutationResult = NonNullable<Awaited<ReturnType<typeof updateEmployeeOvertimes>>>
    export type UpdateEmployeeOvertimesMutationBody = EmployeeOvertime[]
    export type UpdateEmployeeOvertimesMutationError = ErrorResponse

    export const useUpdateEmployeeOvertimes = <TData = Awaited<ReturnType<typeof updateEmployeeOvertimes>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeeOvertime[]},
        TContext
      > => {

      const mutationOptions = getUpdateEmployeeOvertimesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Employee Overtimes
 */
export const addEmployeeOvertimes = (
    id: number,
    employeeOvertime: EmployeeOvertime[],
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeeOvertime[]>(
      {url: `/api/hr/employee/${id}/overtime`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: employeeOvertime, signal
    },
      );
    }
  


export const getAddEmployeeOvertimesMutationOptions = <TData = Awaited<ReturnType<typeof addEmployeeOvertimes>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, }
) => {
const mutationKey = ['addEmployeeOvertimes'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addEmployeeOvertimes>>, {id: number;data: EmployeeOvertime[]}> = (props) => {
          const {id,data} = props ?? {};

          return  addEmployeeOvertimes(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>}

    export type AddEmployeeOvertimesMutationResult = NonNullable<Awaited<ReturnType<typeof addEmployeeOvertimes>>>
    export type AddEmployeeOvertimesMutationBody = EmployeeOvertime[]
    export type AddEmployeeOvertimesMutationError = ErrorResponse

    export const useAddEmployeeOvertimes = <TData = Awaited<ReturnType<typeof addEmployeeOvertimes>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeeOvertime[]},
        TContext
      > => {

      const mutationOptions = getAddEmployeeOvertimesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get MaterialRequest
 */
export const getMaterialRequest = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialRequest>(
      {url: `/api/general/materialRequest/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetMaterialRequestQueryKey = (id: number,) => {
    return [`/api/general/materialRequest/${id}`] as const;
    }

    
export const getGetMaterialRequestQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialRequest>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialRequestQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialRequest>>> = ({ signal }) => getMaterialRequest(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialRequestQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialRequest>>>
export type GetMaterialRequestQueryError = ErrorResponse


export function useGetMaterialRequest<TData = Awaited<ReturnType<typeof getMaterialRequest>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialRequest>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialRequest<TData = Awaited<ReturnType<typeof getMaterialRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialRequest>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialRequest<TData = Awaited<ReturnType<typeof getMaterialRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialRequest<TData = Awaited<ReturnType<typeof getMaterialRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialRequestQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialRequestSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialRequest>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialRequestQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialRequest>>> = ({ signal }) => getMaterialRequest(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialRequestSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialRequest>>>
export type GetMaterialRequestSuspenseQueryError = ErrorResponse


export function useGetMaterialRequestSuspense<TData = Awaited<ReturnType<typeof getMaterialRequest>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialRequestSuspense<TData = Awaited<ReturnType<typeof getMaterialRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialRequestSuspense<TData = Awaited<ReturnType<typeof getMaterialRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialRequestSuspense<TData = Awaited<ReturnType<typeof getMaterialRequest>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialRequest>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialRequestSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update MaterialRequest
 */
export const updateMaterialRequest = (
    id: number,
    materialRequest: MaterialRequest,
 ) => {
      
      
      return customMutator<MaterialRequest>(
      {url: `/api/general/materialRequest/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: materialRequest
    },
      );
    }
  


export const getUpdateMaterialRequestMutationOptions = <TData = Awaited<ReturnType<typeof updateMaterialRequest>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialRequest}, TContext>, }
) => {
const mutationKey = ['updateMaterialRequest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMaterialRequest>>, {id: number;data: MaterialRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMaterialRequest(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: MaterialRequest}, TContext>}

    export type UpdateMaterialRequestMutationResult = NonNullable<Awaited<ReturnType<typeof updateMaterialRequest>>>
    export type UpdateMaterialRequestMutationBody = MaterialRequest
    export type UpdateMaterialRequestMutationError = ErrorResponse

    export const useUpdateMaterialRequest = <TData = Awaited<ReturnType<typeof updateMaterialRequest>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: MaterialRequest},
        TContext
      > => {

      const mutationOptions = getUpdateMaterialRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete MaterialRequest
 */
export const deleteMaterialRequest = (
    id: number,
 ) => {
      
      
      return customMutator<MaterialRequest>(
      {url: `/api/general/materialRequest/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteMaterialRequestMutationOptions = <TData = Awaited<ReturnType<typeof deleteMaterialRequest>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteMaterialRequest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMaterialRequest>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMaterialRequest(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteMaterialRequestMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMaterialRequest>>>
    
    export type DeleteMaterialRequestMutationError = ResponseBase

    export const useDeleteMaterialRequest = <TData = Awaited<ReturnType<typeof deleteMaterialRequest>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMaterialRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Bank Branch
 */
export const getBankBranch = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<BankBranch>(
      {url: `/api/finance/bankBranch/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetBankBranchQueryKey = (id: number,) => {
    return [`/api/finance/bankBranch/${id}`] as const;
    }

    
export const getGetBankBranchQueryOptions = <TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankBranch>>> = ({ signal }) => getBankBranch(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankBranchQueryResult = NonNullable<Awaited<ReturnType<typeof getBankBranch>>>
export type GetBankBranchQueryError = unknown


export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankBranch>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankBranch>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankBranchQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBankBranchSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankBranch>>> = ({ signal }) => getBankBranch(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankBranchSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBankBranch>>>
export type GetBankBranchSuspenseQueryError = unknown


export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankBranchSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Bank Branch
 */
export const updateBankbranch = (
    id: number,
    bankBranch: BankBranch,
 ) => {
      
      
      return customMutator<BankBranch>(
      {url: `/api/finance/bankBranch/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: bankBranch
    },
      );
    }
  


export const getUpdateBankbranchMutationOptions = <TData = Awaited<ReturnType<typeof updateBankbranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankBranch}, TContext>, }
) => {
const mutationKey = ['updateBankbranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBankbranch>>, {id: number;data: BankBranch}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBankbranch(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: BankBranch}, TContext>}

    export type UpdateBankbranchMutationResult = NonNullable<Awaited<ReturnType<typeof updateBankbranch>>>
    export type UpdateBankbranchMutationBody = BankBranch
    export type UpdateBankbranchMutationError = ErrorResponse

    export const useUpdateBankbranch = <TData = Awaited<ReturnType<typeof updateBankbranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankBranch}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: BankBranch},
        TContext
      > => {

      const mutationOptions = getUpdateBankbranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Bank Branch
 */
export const deleteBankBranch = (
    id: number,
 ) => {
      
      
      return customMutator<BankBranch>(
      {url: `/api/finance/bankBranch/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBankBranchMutationOptions = <TData = Awaited<ReturnType<typeof deleteBankBranch>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteBankBranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBankBranch>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBankBranch(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBankBranchMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBankBranch>>>
    
    export type DeleteBankBranchMutationError = ResponseBase

    export const useDeleteBankBranch = <TData = Awaited<ReturnType<typeof deleteBankBranch>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBankBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Bank Account
 */
export const getBankAccount = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<BankAccount>(
      {url: `/api/finance/bankAccount/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetBankAccountQueryKey = (id: number,) => {
    return [`/api/finance/bankAccount/${id}`] as const;
    }

    
export const getGetBankAccountQueryOptions = <TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankAccount>>> = ({ signal }) => getBankAccount(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getBankAccount>>>
export type GetBankAccountQueryError = unknown


export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBankAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankAccount>>> = ({ signal }) => getBankAccount(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBankAccount>>>
export type GetBankAccountSuspenseQueryError = unknown


export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Bank Account
 */
export const updateBankAccount = (
    id: number,
    bankAccount: BankAccount,
 ) => {
      
      
      return customMutator<BankAccount>(
      {url: `/api/finance/bankAccount/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: bankAccount
    },
      );
    }
  


export const getUpdateBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankAccount}, TContext>, }
) => {
const mutationKey = ['updateBankAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBankAccount>>, {id: number;data: BankAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBankAccount(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: BankAccount}, TContext>}

    export type UpdateBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateBankAccount>>>
    export type UpdateBankAccountMutationBody = BankAccount
    export type UpdateBankAccountMutationError = ErrorResponse

    export const useUpdateBankAccount = <TData = Awaited<ReturnType<typeof updateBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: BankAccount},
        TContext
      > => {

      const mutationOptions = getUpdateBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Bank Account
 */
export const deleteBankAccount = (
    id: number,
 ) => {
      
      
      return customMutator<BankAccount>(
      {url: `/api/finance/bankAccount/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteBankAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteBankAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBankAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBankAccount(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBankAccount>>>
    
    export type DeleteBankAccountMutationError = ResponseBase

    export const useDeleteBankAccount = <TData = Awaited<ReturnType<typeof deleteBankAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Bank
 */
export const getDepartment = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Bank>(
      {url: `/api/finance/bank/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDepartmentQueryKey = (id: number,) => {
    return [`/api/finance/bank/${id}`] as const;
    }

    
export const getGetDepartmentQueryOptions = <TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartmentQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment>>> = ({ signal }) => getDepartment(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartmentQueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment>>>
export type GetDepartmentQueryError = ErrorResponse


export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartmentQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepartmentSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartmentQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment>>> = ({ signal }) => getDepartment(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartmentSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment>>>
export type GetDepartmentSuspenseQueryError = ErrorResponse


export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartmentSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Bank
 */
export const updateBank = (
    id: number,
    bank: Bank,
 ) => {
      
      
      return customMutator<Bank>(
      {url: `/api/finance/bank/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: bank
    },
      );
    }
  


export const getUpdateBankMutationOptions = <TData = Awaited<ReturnType<typeof updateBank>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Bank}, TContext>, }
) => {
const mutationKey = ['updateBank'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBank>>, {id: number;data: Bank}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBank(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Bank}, TContext>}

    export type UpdateBankMutationResult = NonNullable<Awaited<ReturnType<typeof updateBank>>>
    export type UpdateBankMutationBody = Bank
    export type UpdateBankMutationError = ErrorResponse

    export const useUpdateBank = <TData = Awaited<ReturnType<typeof updateBank>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Bank}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Bank},
        TContext
      > => {

      const mutationOptions = getUpdateBankMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete bank
 */
export const deleteBank = (
    id: number,
 ) => {
      
      
      return customMutator<Bank>(
      {url: `/api/finance/bank/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBankMutationOptions = <TData = Awaited<ReturnType<typeof deleteBank>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteBank'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBank>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBank(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBankMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBank>>>
    
    export type DeleteBankMutationError = ResponseBase

    export const useDeleteBank = <TData = Awaited<ReturnType<typeof deleteBank>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBankMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Department
 */
export const getDepartment1 = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Department>(
      {url: `/api/company/department/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDepartment1QueryKey = (id: number,) => {
    return [`/api/company/department/${id}`] as const;
    }

    
export const getGetDepartment1QueryOptions = <TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartment1QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment1>>> = ({ signal }) => getDepartment1(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartment1QueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment1>>>
export type GetDepartment1QueryError = ErrorResponse


export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment1>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment1>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartment1QueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepartment1SuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartment1QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment1>>> = ({ signal }) => getDepartment1(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartment1SuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment1>>>
export type GetDepartment1SuspenseQueryError = ErrorResponse


export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartment1SuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Department
 */
export const updateDepartment = (
    id: number,
    department: Department,
 ) => {
      
      
      return customMutator<Department>(
      {url: `/api/company/department/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: department
    },
      );
    }
  


export const getUpdateDepartmentMutationOptions = <TData = Awaited<ReturnType<typeof updateDepartment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Department}, TContext>, }
) => {
const mutationKey = ['updateDepartment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDepartment>>, {id: number;data: Department}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDepartment(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Department}, TContext>}

    export type UpdateDepartmentMutationResult = NonNullable<Awaited<ReturnType<typeof updateDepartment>>>
    export type UpdateDepartmentMutationBody = Department
    export type UpdateDepartmentMutationError = ErrorResponse

    export const useUpdateDepartment = <TData = Awaited<ReturnType<typeof updateDepartment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Department}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Department},
        TContext
      > => {

      const mutationOptions = getUpdateDepartmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Department
 */
export const deleteDepartment = (
    id: number,
 ) => {
      
      
      return customMutator<Department>(
      {url: `/api/company/department/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDepartmentMutationOptions = <TData = Awaited<ReturnType<typeof deleteDepartment>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteDepartment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDepartment>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteDepartment(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteDepartmentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDepartment>>>
    
    export type DeleteDepartmentMutationError = ResponseBase

    export const useDeleteDepartment = <TData = Awaited<ReturnType<typeof deleteDepartment>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteDepartmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Branch
 */
export const getBranch = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Branch>(
      {url: `/api/company/branch/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetBranchQueryKey = (id: number,) => {
    return [`/api/company/branch/${id}`] as const;
    }

    
export const getGetBranchQueryOptions = <TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranch>>> = ({ signal }) => getBranch(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBranchQueryResult = NonNullable<Awaited<ReturnType<typeof getBranch>>>
export type GetBranchQueryError = ErrorResponse


export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranch>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranch>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBranchQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBranchSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranch>>> = ({ signal }) => getBranch(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBranchSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBranch>>>
export type GetBranchSuspenseQueryError = ErrorResponse


export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBranchSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Branch
 */
export const updateBranch = (
    id: number,
    branch: Branch,
 ) => {
      
      
      return customMutator<Branch>(
      {url: `/api/company/branch/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: branch
    },
      );
    }
  


export const getUpdateBranchMutationOptions = <TData = Awaited<ReturnType<typeof updateBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Branch}, TContext>, }
) => {
const mutationKey = ['updateBranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBranch>>, {id: number;data: Branch}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBranch(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Branch}, TContext>}

    export type UpdateBranchMutationResult = NonNullable<Awaited<ReturnType<typeof updateBranch>>>
    export type UpdateBranchMutationBody = Branch
    export type UpdateBranchMutationError = ErrorResponse

    export const useUpdateBranch = <TData = Awaited<ReturnType<typeof updateBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Branch}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Branch},
        TContext
      > => {

      const mutationOptions = getUpdateBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Branch
 */
export const deleteBranch = (
    id: number,
 ) => {
      
      
      return customMutator<Branch>(
      {url: `/api/company/branch/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBranchMutationOptions = <TData = Awaited<ReturnType<typeof deleteBranch>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteBranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBranch>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBranch(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBranchMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBranch>>>
    
    export type DeleteBranchMutationError = ResponseBase

    export const useDeleteBranch = <TData = Awaited<ReturnType<typeof deleteBranch>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Section
 */
export const getSection = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Section>(
      {url: `/api/admin/section/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetSectionQueryKey = (id: number,) => {
    return [`/api/admin/section/${id}`] as const;
    }

    
export const getGetSectionQueryOptions = <TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSectionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSection>>> = ({ signal }) => getSection(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSectionQueryResult = NonNullable<Awaited<ReturnType<typeof getSection>>>
export type GetSectionQueryError = ErrorResponse


export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSection>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSection>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSectionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSectionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSectionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSection>>> = ({ signal }) => getSection(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSectionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSection>>>
export type GetSectionSuspenseQueryError = ErrorResponse


export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSectionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Section
 */
export const updateSection = (
    id: number,
    section: Section,
 ) => {
      
      
      return customMutator<Section>(
      {url: `/api/admin/section/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: section
    },
      );
    }
  


export const getUpdateSectionMutationOptions = <TData = Awaited<ReturnType<typeof updateSection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Section}, TContext>, }
) => {
const mutationKey = ['updateSection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSection>>, {id: number;data: Section}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSection(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Section}, TContext>}

    export type UpdateSectionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSection>>>
    export type UpdateSectionMutationBody = Section
    export type UpdateSectionMutationError = ErrorResponse

    export const useUpdateSection = <TData = Awaited<ReturnType<typeof updateSection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Section}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Section},
        TContext
      > => {

      const mutationOptions = getUpdateSectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Section
 */
export const deleteSection = (
    id: number,
 ) => {
      
      
      return customMutator<Section>(
      {url: `/api/admin/section/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSectionMutationOptions = <TData = Awaited<ReturnType<typeof deleteSection>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteSection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSection>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteSection(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteSectionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSection>>>
    
    export type DeleteSectionMutationError = ResponseBase

    export const useDeleteSection = <TData = Awaited<ReturnType<typeof deleteSection>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteSectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Role
 */
export const getRole = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Role>(
      {url: `/api/admin/role/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetRoleQueryKey = (id: number,) => {
    return [`/api/admin/role/${id}`] as const;
    }

    
export const getGetRoleQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoleQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleQueryError = ErrorResponse


export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoleQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoleSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleSuspenseQueryError = ErrorResponse


export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoleSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Role
 */
export const updateRole = (
    id: number,
    role: Role,
 ) => {
      
      
      return customMutator<Role>(
      {url: `/api/admin/role/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: role
    },
      );
    }
  


export const getUpdateRoleMutationOptions = <TData = Awaited<ReturnType<typeof updateRole>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Role}, TContext>, }
) => {
const mutationKey = ['updateRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRole>>, {id: number;data: Role}> = (props) => {
          const {id,data} = props ?? {};

          return  updateRole(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Role}, TContext>}

    export type UpdateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateRole>>>
    export type UpdateRoleMutationBody = Role
    export type UpdateRoleMutationError = ErrorResponse

    export const useUpdateRole = <TData = Awaited<ReturnType<typeof updateRole>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Role}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Role},
        TContext
      > => {

      const mutationOptions = getUpdateRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Role
 */
export const deleteRole = (
    id: number,
 ) => {
      
      
      return customMutator<Role>(
      {url: `/api/admin/role/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteRoleMutationOptions = <TData = Awaited<ReturnType<typeof deleteRole>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRole>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteRole(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteRoleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRole>>>
    
    export type DeleteRoleMutationError = ResponseBase

    export const useDeleteRole = <TData = Awaited<ReturnType<typeof deleteRole>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Public Holiday
 */
export const getPublicHoliday = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PublicHoliday>(
      {url: `/api/admin/publicHoliday/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetPublicHolidayQueryKey = (id: number,) => {
    return [`/api/admin/publicHoliday/${id}`] as const;
    }

    
export const getGetPublicHolidayQueryOptions = <TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublicHolidayQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicHoliday>>> = ({ signal }) => getPublicHoliday(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPublicHolidayQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicHoliday>>>
export type GetPublicHolidayQueryError = ErrorResponse


export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicHoliday>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicHoliday>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPublicHolidayQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPublicHolidaySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublicHolidayQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicHoliday>>> = ({ signal }) => getPublicHoliday(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPublicHolidaySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicHoliday>>>
export type GetPublicHolidaySuspenseQueryError = ErrorResponse


export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPublicHolidaySuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Public Holiday
 */
export const updatePublicHoliday = (
    id: number,
    publicHoliday: PublicHoliday,
 ) => {
      
      
      return customMutator<PublicHoliday>(
      {url: `/api/admin/publicHoliday/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: publicHoliday
    },
      );
    }
  


export const getUpdatePublicHolidayMutationOptions = <TData = Awaited<ReturnType<typeof updatePublicHoliday>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PublicHoliday}, TContext>, }
) => {
const mutationKey = ['updatePublicHoliday'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePublicHoliday>>, {id: number;data: PublicHoliday}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePublicHoliday(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: PublicHoliday}, TContext>}

    export type UpdatePublicHolidayMutationResult = NonNullable<Awaited<ReturnType<typeof updatePublicHoliday>>>
    export type UpdatePublicHolidayMutationBody = PublicHoliday
    export type UpdatePublicHolidayMutationError = ErrorResponse

    export const useUpdatePublicHoliday = <TData = Awaited<ReturnType<typeof updatePublicHoliday>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PublicHoliday}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: PublicHoliday},
        TContext
      > => {

      const mutationOptions = getUpdatePublicHolidayMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete PublicHoliday
 */
export const deletePublicHoliday = (
    id: number,
 ) => {
      
      
      return customMutator<PublicHoliday>(
      {url: `/api/admin/publicHoliday/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePublicHolidayMutationOptions = <TData = Awaited<ReturnType<typeof deletePublicHoliday>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deletePublicHoliday'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePublicHoliday>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deletePublicHoliday(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeletePublicHolidayMutationResult = NonNullable<Awaited<ReturnType<typeof deletePublicHoliday>>>
    
    export type DeletePublicHolidayMutationError = ResponseBase

    export const useDeletePublicHoliday = <TData = Awaited<ReturnType<typeof deletePublicHoliday>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeletePublicHolidayMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get PaymentMethod
 */
export const getPaymentMethod = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PaymentMethod>(
      {url: `/api/admin/paymentMethod/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetPaymentMethodQueryKey = (id: number,) => {
    return [`/api/admin/paymentMethod/${id}`] as const;
    }

    
export const getGetPaymentMethodQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentMethodQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentMethod>>> = ({ signal }) => getPaymentMethod(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPaymentMethodQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentMethod>>>
export type GetPaymentMethodQueryError = ErrorResponse


export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentMethod>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentMethod>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPaymentMethodQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPaymentMethodSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentMethodQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentMethod>>> = ({ signal }) => getPaymentMethod(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPaymentMethodSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentMethod>>>
export type GetPaymentMethodSuspenseQueryError = ErrorResponse


export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPaymentMethodSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update PaymentMethod
 */
export const updatePaymentMethod = (
    id: number,
    paymentMethod: PaymentMethod,
 ) => {
      
      
      return customMutator<PaymentMethod>(
      {url: `/api/admin/paymentMethod/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: paymentMethod
    },
      );
    }
  


export const getUpdatePaymentMethodMutationOptions = <TData = Awaited<ReturnType<typeof updatePaymentMethod>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PaymentMethod}, TContext>, }
) => {
const mutationKey = ['updatePaymentMethod'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePaymentMethod>>, {id: number;data: PaymentMethod}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePaymentMethod(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: PaymentMethod}, TContext>}

    export type UpdatePaymentMethodMutationResult = NonNullable<Awaited<ReturnType<typeof updatePaymentMethod>>>
    export type UpdatePaymentMethodMutationBody = PaymentMethod
    export type UpdatePaymentMethodMutationError = ErrorResponse

    export const useUpdatePaymentMethod = <TData = Awaited<ReturnType<typeof updatePaymentMethod>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PaymentMethod}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: PaymentMethod},
        TContext
      > => {

      const mutationOptions = getUpdatePaymentMethodMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete PaymentMethod
 */
export const deletePaymentMethod = (
    id: number,
 ) => {
      
      
      return customMutator<PaymentMethod>(
      {url: `/api/admin/paymentMethod/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePaymentMethodMutationOptions = <TData = Awaited<ReturnType<typeof deletePaymentMethod>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deletePaymentMethod'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePaymentMethod>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deletePaymentMethod(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeletePaymentMethodMutationResult = NonNullable<Awaited<ReturnType<typeof deletePaymentMethod>>>
    
    export type DeletePaymentMethodMutationError = ResponseBase

    export const useDeletePaymentMethod = <TData = Awaited<ReturnType<typeof deletePaymentMethod>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeletePaymentMethodMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Machine
 */
export const getMachine = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Machine>(
      {url: `/api/admin/machine/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetMachineQueryKey = (id: number,) => {
    return [`/api/admin/machine/${id}`] as const;
    }

    
export const getGetMachineQueryOptions = <TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMachineQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMachine>>> = ({ signal }) => getMachine(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMachineQueryResult = NonNullable<Awaited<ReturnType<typeof getMachine>>>
export type GetMachineQueryError = ErrorResponse


export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMachine>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMachine>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMachineQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMachineSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMachineQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMachine>>> = ({ signal }) => getMachine(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMachineSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMachine>>>
export type GetMachineSuspenseQueryError = ErrorResponse


export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMachineSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Machine
 */
export const updateMachine = (
    id: number,
    machine: Machine,
 ) => {
      
      
      return customMutator<Machine>(
      {url: `/api/admin/machine/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: machine
    },
      );
    }
  


export const getUpdateMachineMutationOptions = <TData = Awaited<ReturnType<typeof updateMachine>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Machine}, TContext>, }
) => {
const mutationKey = ['updateMachine'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMachine>>, {id: number;data: Machine}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMachine(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Machine}, TContext>}

    export type UpdateMachineMutationResult = NonNullable<Awaited<ReturnType<typeof updateMachine>>>
    export type UpdateMachineMutationBody = Machine
    export type UpdateMachineMutationError = ErrorResponse

    export const useUpdateMachine = <TData = Awaited<ReturnType<typeof updateMachine>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Machine}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Machine},
        TContext
      > => {

      const mutationOptions = getUpdateMachineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Machine
 */
export const deleteMachine = (
    id: number,
 ) => {
      
      
      return customMutator<Machine>(
      {url: `/api/admin/machine/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteMachineMutationOptions = <TData = Awaited<ReturnType<typeof deleteMachine>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteMachine'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMachine>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMachine(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteMachineMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMachine>>>
    
    export type DeleteMachineMutationError = ResponseBase

    export const useDeleteMachine = <TData = Awaited<ReturnType<typeof deleteMachine>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMachineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Depot
 */
export const getDepot = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Depot>(
      {url: `/api/admin/depot/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDepotQueryKey = (id: number,) => {
    return [`/api/admin/depot/${id}`] as const;
    }

    
export const getGetDepotQueryOptions = <TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepot>>> = ({ signal }) => getDepot(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotQueryResult = NonNullable<Awaited<ReturnType<typeof getDepot>>>
export type GetDepotQueryError = ErrorResponse


export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepot>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepot>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepotSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepot>>> = ({ signal }) => getDepot(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepot>>>
export type GetDepotSuspenseQueryError = ErrorResponse


export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Depot
 */
export const updateDepot = (
    id: number,
    depot: Depot,
 ) => {
      
      
      return customMutator<Depot>(
      {url: `/api/admin/depot/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: depot
    },
      );
    }
  


export const getUpdateDepotMutationOptions = <TData = Awaited<ReturnType<typeof updateDepot>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Depot}, TContext>, }
) => {
const mutationKey = ['updateDepot'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDepot>>, {id: number;data: Depot}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDepot(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Depot}, TContext>}

    export type UpdateDepotMutationResult = NonNullable<Awaited<ReturnType<typeof updateDepot>>>
    export type UpdateDepotMutationBody = Depot
    export type UpdateDepotMutationError = ErrorResponse

    export const useUpdateDepot = <TData = Awaited<ReturnType<typeof updateDepot>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Depot}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Depot},
        TContext
      > => {

      const mutationOptions = getUpdateDepotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Depot
 */
export const deleteDepot = (
    id: number,
 ) => {
      
      
      return customMutator<Depot>(
      {url: `/api/admin/depot/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDepotMutationOptions = <TData = Awaited<ReturnType<typeof deleteDepot>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteDepot'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDepot>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteDepot(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteDepotMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDepot>>>
    
    export type DeleteDepotMutationError = ResponseBase

    export const useDeleteDepot = <TData = Awaited<ReturnType<typeof deleteDepot>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteDepotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Company
 */
export const getCompany = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Company>(
      {url: `/api/admin/company/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCompanyQueryKey = (id: number,) => {
    return [`/api/admin/company/${id}`] as const;
    }

    
export const getGetCompanyQueryOptions = <TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCompanyQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompany>>> = ({ signal }) => getCompany(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCompanyQueryResult = NonNullable<Awaited<ReturnType<typeof getCompany>>>
export type GetCompanyQueryError = ErrorResponse


export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompany>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompany>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCompanyQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCompanySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCompanyQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompany>>> = ({ signal }) => getCompany(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCompanySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCompany>>>
export type GetCompanySuspenseQueryError = ErrorResponse


export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCompanySuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Company
 */
export const updateCompany = (
    id: number,
    company: Company,
 ) => {
      
      
      return customMutator<Company>(
      {url: `/api/admin/company/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: company
    },
      );
    }
  


export const getUpdateCompanyMutationOptions = <TData = Awaited<ReturnType<typeof updateCompany>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Company}, TContext>, }
) => {
const mutationKey = ['updateCompany'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCompany>>, {id: number;data: Company}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCompany(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Company}, TContext>}

    export type UpdateCompanyMutationResult = NonNullable<Awaited<ReturnType<typeof updateCompany>>>
    export type UpdateCompanyMutationBody = Company
    export type UpdateCompanyMutationError = ErrorResponse

    export const useUpdateCompany = <TData = Awaited<ReturnType<typeof updateCompany>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Company}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Company},
        TContext
      > => {

      const mutationOptions = getUpdateCompanyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Company
 */
export const deleteCompany = (
    id: number,
 ) => {
      
      
      return customMutator<Company>(
      {url: `/api/admin/company/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCompanyMutationOptions = <TData = Awaited<ReturnType<typeof deleteCompany>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCompany'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCompany>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCompany(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCompanyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCompany>>>
    
    export type DeleteCompanyMutationError = ResponseBase

    export const useDeleteCompany = <TData = Awaited<ReturnType<typeof deleteCompany>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCompanyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ExpenseInvoice
 */
export const getExpenseInvoice = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseInvoice>(
      {url: `/api/accounting/expenseInvoice/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetExpenseInvoiceQueryKey = (id: number,) => {
    return [`/api/accounting/expenseInvoice/${id}`] as const;
    }

    
export const getGetExpenseInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseInvoice>>> = ({ signal }) => getExpenseInvoice(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseInvoice>>>
export type GetExpenseInvoiceQueryError = ErrorResponse


export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseInvoiceQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExpenseInvoiceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseInvoice>>> = ({ signal }) => getExpenseInvoice(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseInvoiceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseInvoice>>>
export type GetExpenseInvoiceSuspenseQueryError = ErrorResponse


export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseInvoiceSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ExpenseInvoice
 */
export const updateExpenseInvoice = (
    id: number,
    expenseInvoice: ExpenseInvoice,
 ) => {
      
      
      return customMutator<ExpenseInvoice>(
      {url: `/api/accounting/expenseInvoice/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: expenseInvoice
    },
      );
    }
  


export const getUpdateExpenseInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof updateExpenseInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseInvoice}, TContext>, }
) => {
const mutationKey = ['updateExpenseInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExpenseInvoice>>, {id: number;data: ExpenseInvoice}> = (props) => {
          const {id,data} = props ?? {};

          return  updateExpenseInvoice(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ExpenseInvoice}, TContext>}

    export type UpdateExpenseInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof updateExpenseInvoice>>>
    export type UpdateExpenseInvoiceMutationBody = ExpenseInvoice
    export type UpdateExpenseInvoiceMutationError = ErrorResponse

    export const useUpdateExpenseInvoice = <TData = Awaited<ReturnType<typeof updateExpenseInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseInvoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ExpenseInvoice},
        TContext
      > => {

      const mutationOptions = getUpdateExpenseInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ExpenseInvoice
 */
export const deleteExpenseInvoice = (
    id: number,
 ) => {
      
      
      return customMutator<ExpenseInvoice>(
      {url: `/api/accounting/expenseInvoice/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteExpenseInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof deleteExpenseInvoice>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteExpenseInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteExpenseInvoice>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteExpenseInvoice(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteExpenseInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteExpenseInvoice>>>
    
    export type DeleteExpenseInvoiceMutationError = ResponseBase

    export const useDeleteExpenseInvoice = <TData = Awaited<ReturnType<typeof deleteExpenseInvoice>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteExpenseInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ExpenseCard
 */
export const getExpenseCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseCard>(
      {url: `/api/accounting/expenseCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetExpenseCardQueryKey = (id: number,) => {
    return [`/api/accounting/expenseCard/${id}`] as const;
    }

    
export const getGetExpenseCardQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseCard>>> = ({ signal }) => getExpenseCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseCardQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseCard>>>
export type GetExpenseCardQueryError = ErrorResponse


export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExpenseCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseCard>>> = ({ signal }) => getExpenseCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseCard>>>
export type GetExpenseCardSuspenseQueryError = ErrorResponse


export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ExpenseCard
 */
export const updateExpenseCard = (
    id: number,
    expenseCard: ExpenseCard,
 ) => {
      
      
      return customMutator<ExpenseCard>(
      {url: `/api/accounting/expenseCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: expenseCard
    },
      );
    }
  


export const getUpdateExpenseCardMutationOptions = <TData = Awaited<ReturnType<typeof updateExpenseCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseCard}, TContext>, }
) => {
const mutationKey = ['updateExpenseCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExpenseCard>>, {id: number;data: ExpenseCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateExpenseCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ExpenseCard}, TContext>}

    export type UpdateExpenseCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateExpenseCard>>>
    export type UpdateExpenseCardMutationBody = ExpenseCard
    export type UpdateExpenseCardMutationError = ErrorResponse

    export const useUpdateExpenseCard = <TData = Awaited<ReturnType<typeof updateExpenseCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ExpenseCard},
        TContext
      > => {

      const mutationOptions = getUpdateExpenseCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ExpenseCard
 */
export const deleteExpenseCard = (
    id: number,
 ) => {
      
      
      return customMutator<ExpenseCard>(
      {url: `/api/accounting/expenseCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteExpenseCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteExpenseCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteExpenseCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteExpenseCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteExpenseCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteExpenseCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteExpenseCard>>>
    
    export type DeleteExpenseCardMutationError = ResponseBase

    export const useDeleteExpenseCard = <TData = Awaited<ReturnType<typeof deleteExpenseCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteExpenseCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get CashAccountTransaction
 */
export const getCashAccountTransaction = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccountTransaction>(
      {url: `/api/accounting/cashAccountTransaction/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCashAccountTransactionQueryKey = (id: number,) => {
    return [`/api/accounting/cashAccountTransaction/${id}`] as const;
    }

    
export const getGetCashAccountTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccountTransaction>>> = ({ signal }) => getCashAccountTransaction(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccountTransaction>>>
export type GetCashAccountTransactionQueryError = ErrorResponse


export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountTransactionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCashAccountTransactionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccountTransaction>>> = ({ signal }) => getCashAccountTransaction(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountTransactionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccountTransaction>>>
export type GetCashAccountTransactionSuspenseQueryError = ErrorResponse


export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountTransactionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update CashAccountTransaction
 */
export const updateCashAccountTransaction = (
    id: number,
    cashAccountTransaction: CashAccountTransaction,
 ) => {
      
      
      return customMutator<CashAccountTransaction>(
      {url: `/api/accounting/cashAccountTransaction/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: cashAccountTransaction
    },
      );
    }
  


export const getUpdateCashAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof updateCashAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccountTransaction}, TContext>, }
) => {
const mutationKey = ['updateCashAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCashAccountTransaction>>, {id: number;data: CashAccountTransaction}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCashAccountTransaction(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CashAccountTransaction}, TContext>}

    export type UpdateCashAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof updateCashAccountTransaction>>>
    export type UpdateCashAccountTransactionMutationBody = CashAccountTransaction
    export type UpdateCashAccountTransactionMutationError = ErrorResponse

    export const useUpdateCashAccountTransaction = <TData = Awaited<ReturnType<typeof updateCashAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccountTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CashAccountTransaction},
        TContext
      > => {

      const mutationOptions = getUpdateCashAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete CashAccountTransaction
 */
export const deleteCashAccountTransaction = (
    id: number,
 ) => {
      
      
      return customMutator<CashAccountTransaction>(
      {url: `/api/accounting/cashAccountTransaction/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCashAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof deleteCashAccountTransaction>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCashAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCashAccountTransaction>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCashAccountTransaction(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCashAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCashAccountTransaction>>>
    
    export type DeleteCashAccountTransactionMutationError = ResponseBase

    export const useDeleteCashAccountTransaction = <TData = Awaited<ReturnType<typeof deleteCashAccountTransaction>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCashAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get CashAccount
 */
export const getCashAccount = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccount>(
      {url: `/api/accounting/cashAccount/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCashAccountQueryKey = (id: number,) => {
    return [`/api/accounting/cashAccount/${id}`] as const;
    }

    
export const getGetCashAccountQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccount>>> = ({ signal }) => getCashAccount(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccount>>>
export type GetCashAccountQueryError = ErrorResponse


export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCashAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccount>>> = ({ signal }) => getCashAccount(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccount>>>
export type GetCashAccountSuspenseQueryError = ErrorResponse


export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update CashAccount
 */
export const updateCashAccount = (
    id: number,
    cashAccount: CashAccount,
 ) => {
      
      
      return customMutator<CashAccount>(
      {url: `/api/accounting/cashAccount/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: cashAccount
    },
      );
    }
  


export const getUpdateCashAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateCashAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccount}, TContext>, }
) => {
const mutationKey = ['updateCashAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCashAccount>>, {id: number;data: CashAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCashAccount(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CashAccount}, TContext>}

    export type UpdateCashAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateCashAccount>>>
    export type UpdateCashAccountMutationBody = CashAccount
    export type UpdateCashAccountMutationError = ErrorResponse

    export const useUpdateCashAccount = <TData = Awaited<ReturnType<typeof updateCashAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CashAccount},
        TContext
      > => {

      const mutationOptions = getUpdateCashAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete CashAccount
 */
export const deleteCashAccount = (
    id: number,
 ) => {
      
      
      return customMutator<CashAccount>(
      {url: `/api/accounting/cashAccount/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCashAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteCashAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCashAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCashAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCashAccount(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCashAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCashAccount>>>
    
    export type DeleteCashAccountMutationError = ResponseBase

    export const useDeleteCashAccount = <TData = Awaited<ReturnType<typeof deleteCashAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCashAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add New User
 */
export const addUser = (
    userAdd: UserAdd,
 signal?: AbortSignal
) => {
      
      
      return customMutator<User>(
      {url: `/api/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userAdd, signal
    },
      );
    }
  


export const getAddUserMutationOptions = <TData = Awaited<ReturnType<typeof addUser>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: UserAdd}, TContext>, }
) => {
const mutationKey = ['addUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUser>>, {data: UserAdd}> = (props) => {
          const {data} = props ?? {};

          return  addUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: UserAdd}, TContext>}

    export type AddUserMutationResult = NonNullable<Awaited<ReturnType<typeof addUser>>>
    export type AddUserMutationBody = UserAdd
    export type AddUserMutationError = ErrorResponse

    export const useAddUser = <TData = Awaited<ReturnType<typeof addUser>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: UserAdd}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: UserAdd},
        TContext
      > => {

      const mutationOptions = getAddUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const refresh = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<RefreshResponse>(
      {url: `/api/user/refresh`, method: 'POST', signal
    },
      );
    }
  


export const getRefreshMutationOptions = <TData = Awaited<ReturnType<typeof refresh>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, }
) => {
const mutationKey = ['refresh'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refresh>>, void> = () => {
          

          return  refresh()
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type RefreshMutationResult = NonNullable<Awaited<ReturnType<typeof refresh>>>
    
    export type RefreshMutationError = ResponseBase

    export const useRefresh = <TData = Awaited<ReturnType<typeof refresh>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, }
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getRefreshMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const logout = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<Logout200>(
      {url: `/api/user/logout`, method: 'POST', signal
    },
      );
    }
  


export const getLogoutMutationOptions = <TData = Awaited<ReturnType<typeof logout>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, }
) => {
const mutationKey = ['logout'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout()
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = unknown

    export const useLogout = <TData = Awaited<ReturnType<typeof logout>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, }
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Login erp user
 */
export const login = (
    loginRequest: LoginRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<LoginResponse>(
      {url: `/api/user/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      );
    }
  


export const getLoginMutationOptions = <TData = Awaited<ReturnType<typeof login>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: LoginRequest}, TContext>, }
) => {
const mutationKey = ['login'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: LoginRequest}, TContext>}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = ResponseBase

    export const useLogin = <TData = Awaited<ReturnType<typeof login>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: LoginRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Unit
 */
export const addUnit = (
    unit: Unit,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Unit>(
      {url: `/api/storage/unit`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: unit, signal
    },
      );
    }
  


export const getAddUnitMutationOptions = <TData = Awaited<ReturnType<typeof addUnit>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Unit}, TContext>, }
) => {
const mutationKey = ['addUnit'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUnit>>, {data: Unit}> = (props) => {
          const {data} = props ?? {};

          return  addUnit(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Unit}, TContext>}

    export type AddUnitMutationResult = NonNullable<Awaited<ReturnType<typeof addUnit>>>
    export type AddUnitMutationBody = Unit
    export type AddUnitMutationError = ErrorResponse

    export const useAddUnit = <TData = Awaited<ReturnType<typeof addUnit>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Unit}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Unit},
        TContext
      > => {

      const mutationOptions = getAddUnitMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Shelf
 */
export const addShelf = (
    shelf: Shelf,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Shelf>(
      {url: `/api/storage/shelf`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: shelf, signal
    },
      );
    }
  


export const getAddShelfMutationOptions = <TData = Awaited<ReturnType<typeof addShelf>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Shelf}, TContext>, }
) => {
const mutationKey = ['addShelf'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addShelf>>, {data: Shelf}> = (props) => {
          const {data} = props ?? {};

          return  addShelf(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Shelf}, TContext>}

    export type AddShelfMutationResult = NonNullable<Awaited<ReturnType<typeof addShelf>>>
    export type AddShelfMutationBody = Shelf
    export type AddShelfMutationError = ErrorResponse

    export const useAddShelf = <TData = Awaited<ReturnType<typeof addShelf>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Shelf}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Shelf},
        TContext
      > => {

      const mutationOptions = getAddShelfMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ServiceGroup
 */
export const addServiceGroup = (
    serviceGroup: ServiceGroup,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceGroup>(
      {url: `/api/storage/serviceGroup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: serviceGroup, signal
    },
      );
    }
  


export const getAddServiceGroupMutationOptions = <TData = Awaited<ReturnType<typeof addServiceGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceGroup}, TContext>, }
) => {
const mutationKey = ['addServiceGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addServiceGroup>>, {data: ServiceGroup}> = (props) => {
          const {data} = props ?? {};

          return  addServiceGroup(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ServiceGroup}, TContext>}

    export type AddServiceGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addServiceGroup>>>
    export type AddServiceGroupMutationBody = ServiceGroup
    export type AddServiceGroupMutationError = ErrorResponse

    export const useAddServiceGroup = <TData = Awaited<ReturnType<typeof addServiceGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ServiceGroup},
        TContext
      > => {

      const mutationOptions = getAddServiceGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ServiceCard
 */
export const addServiceCard = (
    serviceCard: ServiceCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceCard>(
      {url: `/api/storage/serviceCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: serviceCard, signal
    },
      );
    }
  


export const getAddServiceCardMutationOptions = <TData = Awaited<ReturnType<typeof addServiceCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceCard}, TContext>, }
) => {
const mutationKey = ['addServiceCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addServiceCard>>, {data: ServiceCard}> = (props) => {
          const {data} = props ?? {};

          return  addServiceCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ServiceCard}, TContext>}

    export type AddServiceCardMutationResult = NonNullable<Awaited<ReturnType<typeof addServiceCard>>>
    export type AddServiceCardMutationBody = ServiceCard
    export type AddServiceCardMutationError = ErrorResponse

    export const useAddServiceCard = <TData = Awaited<ReturnType<typeof addServiceCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ServiceCard},
        TContext
      > => {

      const mutationOptions = getAddServiceCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ProductGroup
 */
export const addProductGroup = (
    productGroup: ProductGroup,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductGroup>(
      {url: `/api/storage/productGroup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productGroup, signal
    },
      );
    }
  


export const getAddProductGroupMutationOptions = <TData = Awaited<ReturnType<typeof addProductGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductGroup}, TContext>, }
) => {
const mutationKey = ['addProductGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProductGroup>>, {data: ProductGroup}> = (props) => {
          const {data} = props ?? {};

          return  addProductGroup(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ProductGroup}, TContext>}

    export type AddProductGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addProductGroup>>>
    export type AddProductGroupMutationBody = ProductGroup
    export type AddProductGroupMutationError = ErrorResponse

    export const useAddProductGroup = <TData = Awaited<ReturnType<typeof addProductGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ProductGroup},
        TContext
      > => {

      const mutationOptions = getAddProductGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ProductCard
 */
export const addProductCard = (
    productCard: ProductCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductCard>(
      {url: `/api/storage/productCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productCard, signal
    },
      );
    }
  


export const getAddProductCardMutationOptions = <TData = Awaited<ReturnType<typeof addProductCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductCard}, TContext>, }
) => {
const mutationKey = ['addProductCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProductCard>>, {data: ProductCard}> = (props) => {
          const {data} = props ?? {};

          return  addProductCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ProductCard}, TContext>}

    export type AddProductCardMutationResult = NonNullable<Awaited<ReturnType<typeof addProductCard>>>
    export type AddProductCardMutationBody = ProductCard
    export type AddProductCardMutationError = ErrorResponse

    export const useAddProductCard = <TData = Awaited<ReturnType<typeof addProductCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ProductCard},
        TContext
      > => {

      const mutationOptions = getAddProductCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Material Request Fulfillments. Supports filtering via rsql.
 */
export const materialRequestFulfillments = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialRequestFulfillments>(
      {url: `/api/storage/materialRequestFulfillments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getMaterialRequestFulfillmentsMutationOptions = <TData = Awaited<ReturnType<typeof materialRequestFulfillments>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['materialRequestFulfillments'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof materialRequestFulfillments>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  materialRequestFulfillments(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type MaterialRequestFulfillmentsMutationResult = NonNullable<Awaited<ReturnType<typeof materialRequestFulfillments>>>
    export type MaterialRequestFulfillmentsMutationBody = FilteringRequest
    export type MaterialRequestFulfillmentsMutationError = ErrorResponse

    export const useMaterialRequestFulfillments = <TData = Awaited<ReturnType<typeof materialRequestFulfillments>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getMaterialRequestFulfillmentsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new MaterialRequestFulfillment
 */
export const addMaterialRequestFulfillment = (
    materialRequestFulfillment: MaterialRequestFulfillment,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialRequestFulfillment>(
      {url: `/api/storage/materialRequestFulfillment`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: materialRequestFulfillment, signal
    },
      );
    }
  


export const getAddMaterialRequestFulfillmentMutationOptions = <TData = Awaited<ReturnType<typeof addMaterialRequestFulfillment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialRequestFulfillment}, TContext>, }
) => {
const mutationKey = ['addMaterialRequestFulfillment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMaterialRequestFulfillment>>, {data: MaterialRequestFulfillment}> = (props) => {
          const {data} = props ?? {};

          return  addMaterialRequestFulfillment(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: MaterialRequestFulfillment}, TContext>}

    export type AddMaterialRequestFulfillmentMutationResult = NonNullable<Awaited<ReturnType<typeof addMaterialRequestFulfillment>>>
    export type AddMaterialRequestFulfillmentMutationBody = MaterialRequestFulfillment
    export type AddMaterialRequestFulfillmentMutationError = ErrorResponse

    export const useAddMaterialRequestFulfillment = <TData = Awaited<ReturnType<typeof addMaterialRequestFulfillment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialRequestFulfillment}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: MaterialRequestFulfillment},
        TContext
      > => {

      const mutationOptions = getAddMaterialRequestFulfillmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new MaterialGroup
 */
export const addMaterialGroup = (
    materialGroup: MaterialGroup,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialGroup>(
      {url: `/api/storage/materialGroup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: materialGroup, signal
    },
      );
    }
  


export const getAddMaterialGroupMutationOptions = <TData = Awaited<ReturnType<typeof addMaterialGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialGroup}, TContext>, }
) => {
const mutationKey = ['addMaterialGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMaterialGroup>>, {data: MaterialGroup}> = (props) => {
          const {data} = props ?? {};

          return  addMaterialGroup(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: MaterialGroup}, TContext>}

    export type AddMaterialGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addMaterialGroup>>>
    export type AddMaterialGroupMutationBody = MaterialGroup
    export type AddMaterialGroupMutationError = ErrorResponse

    export const useAddMaterialGroup = <TData = Awaited<ReturnType<typeof addMaterialGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: MaterialGroup},
        TContext
      > => {

      const mutationOptions = getAddMaterialGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new MaterialCard
 */
export const addMaterialCard = (
    materialCard: MaterialCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialCard>(
      {url: `/api/storage/materialCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: materialCard, signal
    },
      );
    }
  


export const getAddMaterialCardMutationOptions = <TData = Awaited<ReturnType<typeof addMaterialCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialCard}, TContext>, }
) => {
const mutationKey = ['addMaterialCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMaterialCard>>, {data: MaterialCard}> = (props) => {
          const {data} = props ?? {};

          return  addMaterialCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: MaterialCard}, TContext>}

    export type AddMaterialCardMutationResult = NonNullable<Awaited<ReturnType<typeof addMaterialCard>>>
    export type AddMaterialCardMutationBody = MaterialCard
    export type AddMaterialCardMutationError = ErrorResponse

    export const useAddMaterialCard = <TData = Awaited<ReturnType<typeof addMaterialCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: MaterialCard},
        TContext
      > => {

      const mutationOptions = getAddMaterialCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new FixtureGroup
 */
export const addFixtureGroup = (
    fixtureGroup: FixtureGroup,
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureGroup>(
      {url: `/api/storage/fixtureGroup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: fixtureGroup, signal
    },
      );
    }
  


export const getAddFixtureGroupMutationOptions = <TData = Awaited<ReturnType<typeof addFixtureGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureGroup}, TContext>, }
) => {
const mutationKey = ['addFixtureGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFixtureGroup>>, {data: FixtureGroup}> = (props) => {
          const {data} = props ?? {};

          return  addFixtureGroup(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FixtureGroup}, TContext>}

    export type AddFixtureGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addFixtureGroup>>>
    export type AddFixtureGroupMutationBody = FixtureGroup
    export type AddFixtureGroupMutationError = ErrorResponse

    export const useAddFixtureGroup = <TData = Awaited<ReturnType<typeof addFixtureGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FixtureGroup},
        TContext
      > => {

      const mutationOptions = getAddFixtureGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new FixtureCard
 */
export const addFixtureCard = (
    fixtureCard: FixtureCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureCard>(
      {url: `/api/storage/fixtureCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: fixtureCard, signal
    },
      );
    }
  


export const getAddFixtureCardMutationOptions = <TData = Awaited<ReturnType<typeof addFixtureCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureCard}, TContext>, }
) => {
const mutationKey = ['addFixtureCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFixtureCard>>, {data: FixtureCard}> = (props) => {
          const {data} = props ?? {};

          return  addFixtureCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FixtureCard}, TContext>}

    export type AddFixtureCardMutationResult = NonNullable<Awaited<ReturnType<typeof addFixtureCard>>>
    export type AddFixtureCardMutationBody = FixtureCard
    export type AddFixtureCardMutationError = ErrorResponse

    export const useAddFixtureCard = <TData = Awaited<ReturnType<typeof addFixtureCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FixtureCard},
        TContext
      > => {

      const mutationOptions = getAddFixtureCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List DepotTransactions. Supports filtering via rsql.
 */
export const depotTransactions = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<DepotTransactions>(
      {url: `/api/storage/depotTransactions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getDepotTransactionsMutationOptions = <TData = Awaited<ReturnType<typeof depotTransactions>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['depotTransactions'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof depotTransactions>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  depotTransactions(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type DepotTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof depotTransactions>>>
    export type DepotTransactionsMutationBody = FilteringRequest
    export type DepotTransactionsMutationError = ErrorResponse

    export const useDepotTransactions = <TData = Awaited<ReturnType<typeof depotTransactions>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getDepotTransactionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new DepotTransaction
 */
export const addDepotTransaction = (
    depotTransaction: DepotTransaction,
 signal?: AbortSignal
) => {
      
      
      return customMutator<DepotTransaction>(
      {url: `/api/storage/depotTransaction`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: depotTransaction, signal
    },
      );
    }
  


export const getAddDepotTransactionMutationOptions = <TData = Awaited<ReturnType<typeof addDepotTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: DepotTransaction}, TContext>, }
) => {
const mutationKey = ['addDepotTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addDepotTransaction>>, {data: DepotTransaction}> = (props) => {
          const {data} = props ?? {};

          return  addDepotTransaction(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: DepotTransaction}, TContext>}

    export type AddDepotTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof addDepotTransaction>>>
    export type AddDepotTransactionMutationBody = DepotTransaction
    export type AddDepotTransactionMutationError = ErrorResponse

    export const useAddDepotTransaction = <TData = Awaited<ReturnType<typeof addDepotTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: DepotTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: DepotTransaction},
        TContext
      > => {

      const mutationOptions = getAddDepotTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new AssignmentTransaction
 */
export const addAssignmentTransaction = (
    assignmentTransaction: AssignmentTransaction,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AssignmentTransaction>(
      {url: `/api/storage/assignmentTransaction`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assignmentTransaction, signal
    },
      );
    }
  


export const getAddAssignmentTransactionMutationOptions = <TData = Awaited<ReturnType<typeof addAssignmentTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentTransaction}, TContext>, }
) => {
const mutationKey = ['addAssignmentTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAssignmentTransaction>>, {data: AssignmentTransaction}> = (props) => {
          const {data} = props ?? {};

          return  addAssignmentTransaction(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: AssignmentTransaction}, TContext>}

    export type AddAssignmentTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof addAssignmentTransaction>>>
    export type AddAssignmentTransactionMutationBody = AssignmentTransaction
    export type AddAssignmentTransactionMutationError = ErrorResponse

    export const useAddAssignmentTransaction = <TData = Awaited<ReturnType<typeof addAssignmentTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: AssignmentTransaction},
        TContext
      > => {

      const mutationOptions = getAddAssignmentTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new AssignmentCard
 */
export const addAssignmentCard = (
    assignmentCard: AssignmentCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AssignmentCard>(
      {url: `/api/storage/assignmentCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assignmentCard, signal
    },
      );
    }
  


export const getAddAssignmentCardMutationOptions = <TData = Awaited<ReturnType<typeof addAssignmentCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentCard}, TContext>, }
) => {
const mutationKey = ['addAssignmentCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAssignmentCard>>, {data: AssignmentCard}> = (props) => {
          const {data} = props ?? {};

          return  addAssignmentCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: AssignmentCard}, TContext>}

    export type AddAssignmentCardMutationResult = NonNullable<Awaited<ReturnType<typeof addAssignmentCard>>>
    export type AddAssignmentCardMutationBody = AssignmentCard
    export type AddAssignmentCardMutationError = ErrorResponse

    export const useAddAssignmentCard = <TData = Awaited<ReturnType<typeof addAssignmentCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: AssignmentCard},
        TContext
      > => {

      const mutationOptions = getAddAssignmentCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Proposal
 */
export const addProposal = (
    proposal: Proposal,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Proposal>(
      {url: `/api/sales/proposal`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: proposal, signal
    },
      );
    }
  


export const getAddProposalMutationOptions = <TData = Awaited<ReturnType<typeof addProposal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Proposal}, TContext>, }
) => {
const mutationKey = ['addProposal'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProposal>>, {data: Proposal}> = (props) => {
          const {data} = props ?? {};

          return  addProposal(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Proposal}, TContext>}

    export type AddProposalMutationResult = NonNullable<Awaited<ReturnType<typeof addProposal>>>
    export type AddProposalMutationBody = Proposal
    export type AddProposalMutationError = ErrorResponse

    export const useAddProposal = <TData = Awaited<ReturnType<typeof addProposal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Proposal}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Proposal},
        TContext
      > => {

      const mutationOptions = getAddProposalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new PurchaseOrder
 */
export const addPurchaseOrder = (
    purchaseOrder: PurchaseOrder,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PurchaseOrder>(
      {url: `/api/purchasing/purchaseOrder`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: purchaseOrder, signal
    },
      );
    }
  


export const getAddPurchaseOrderMutationOptions = <TData = Awaited<ReturnType<typeof addPurchaseOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PurchaseOrder}, TContext>, }
) => {
const mutationKey = ['addPurchaseOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPurchaseOrder>>, {data: PurchaseOrder}> = (props) => {
          const {data} = props ?? {};

          return  addPurchaseOrder(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: PurchaseOrder}, TContext>}

    export type AddPurchaseOrderMutationResult = NonNullable<Awaited<ReturnType<typeof addPurchaseOrder>>>
    export type AddPurchaseOrderMutationBody = PurchaseOrder
    export type AddPurchaseOrderMutationError = ErrorResponse

    export const useAddPurchaseOrder = <TData = Awaited<ReturnType<typeof addPurchaseOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PurchaseOrder}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: PurchaseOrder},
        TContext
      > => {

      const mutationOptions = getAddPurchaseOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List ProposalRequests. Supports filtering via rsql.
 */
export const proposalRequests = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProposalRequests>(
      {url: `/api/purchasing/proposalRequests`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getProposalRequestsMutationOptions = <TData = Awaited<ReturnType<typeof proposalRequests>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['proposalRequests'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof proposalRequests>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  proposalRequests(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ProposalRequestsMutationResult = NonNullable<Awaited<ReturnType<typeof proposalRequests>>>
    export type ProposalRequestsMutationBody = FilteringRequest
    export type ProposalRequestsMutationError = ErrorResponse

    export const useProposalRequests = <TData = Awaited<ReturnType<typeof proposalRequests>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getProposalRequestsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ProposalRequest
 */
export const addProposalRequest = (
    proposalRequest: ProposalRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProposalRequest>(
      {url: `/api/purchasing/proposalRequest`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: proposalRequest, signal
    },
      );
    }
  


export const getAddProposalRequestMutationOptions = <TData = Awaited<ReturnType<typeof addProposalRequest>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProposalRequest}, TContext>, }
) => {
const mutationKey = ['addProposalRequest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProposalRequest>>, {data: ProposalRequest}> = (props) => {
          const {data} = props ?? {};

          return  addProposalRequest(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ProposalRequest}, TContext>}

    export type AddProposalRequestMutationResult = NonNullable<Awaited<ReturnType<typeof addProposalRequest>>>
    export type AddProposalRequestMutationBody = ProposalRequest
    export type AddProposalRequestMutationError = ErrorResponse

    export const useAddProposalRequest = <TData = Awaited<ReturnType<typeof addProposalRequest>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProposalRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ProposalRequest},
        TContext
      > => {

      const mutationOptions = getAddProposalRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Proposal Request Total
 */
export const calculateProposalRequestSummary = (
    proposalRequest: ProposalRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProposalRequestCalculationResult>(
      {url: `/api/purchasing/proposalRequest/calculateSummary`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: proposalRequest, signal
    },
      );
    }
  


export const getCalculateProposalRequestSummaryMutationOptions = <TData = Awaited<ReturnType<typeof calculateProposalRequestSummary>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProposalRequest}, TContext>, }
) => {
const mutationKey = ['calculateProposalRequestSummary'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateProposalRequestSummary>>, {data: ProposalRequest}> = (props) => {
          const {data} = props ?? {};

          return  calculateProposalRequestSummary(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ProposalRequest}, TContext>}

    export type CalculateProposalRequestSummaryMutationResult = NonNullable<Awaited<ReturnType<typeof calculateProposalRequestSummary>>>
    export type CalculateProposalRequestSummaryMutationBody = ProposalRequest
    export type CalculateProposalRequestSummaryMutationError = ErrorResponse

    export const useCalculateProposalRequestSummary = <TData = Awaited<ReturnType<typeof calculateProposalRequestSummary>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProposalRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ProposalRequest},
        TContext
      > => {

      const mutationOptions = getCalculateProposalRequestSummaryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Invoice
 */
export const addInvoice = (
    invoice: Invoice,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Invoice>(
      {url: `/api/purchasing/invoice`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoice, signal
    },
      );
    }
  


export const getAddInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof addInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, }
) => {
const mutationKey = ['addInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addInvoice>>, {data: Invoice}> = (props) => {
          const {data} = props ?? {};

          return  addInvoice(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Invoice}, TContext>}

    export type AddInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof addInvoice>>>
    export type AddInvoiceMutationBody = Invoice
    export type AddInvoiceMutationError = ErrorResponse

    export const useAddInvoice = <TData = Awaited<ReturnType<typeof addInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Invoice},
        TContext
      > => {

      const mutationOptions = getAddInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Invoice Total
 */
export const calculateInvoiceTotal = (
    invoice: Invoice,
 signal?: AbortSignal
) => {
      
      
      return customMutator<InvoiceCalculationResult>(
      {url: `/api/purchasing/invoice/calculateTotal`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoice, signal
    },
      );
    }
  


export const getCalculateInvoiceTotalMutationOptions = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, }
) => {
const mutationKey = ['calculateInvoiceTotal'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateInvoiceTotal>>, {data: Invoice}> = (props) => {
          const {data} = props ?? {};

          return  calculateInvoiceTotal(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Invoice}, TContext>}

    export type CalculateInvoiceTotalMutationResult = NonNullable<Awaited<ReturnType<typeof calculateInvoiceTotal>>>
    export type CalculateInvoiceTotalMutationBody = Invoice
    export type CalculateInvoiceTotalMutationError = ErrorResponse

    export const useCalculateInvoiceTotal = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Invoice},
        TContext
      > => {

      const mutationOptions = getCalculateInvoiceTotalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Current Account
 */
export const addCurrentAccount = (
    currentAccount: CurrentAccount,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccount>(
      {url: `/api/purchasing/currentAccount`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: currentAccount, signal
    },
      );
    }
  


export const getAddCurrentAccountMutationOptions = <TData = Awaited<ReturnType<typeof addCurrentAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccount}, TContext>, }
) => {
const mutationKey = ['addCurrentAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCurrentAccount>>, {data: CurrentAccount}> = (props) => {
          const {data} = props ?? {};

          return  addCurrentAccount(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CurrentAccount}, TContext>}

    export type AddCurrentAccountMutationResult = NonNullable<Awaited<ReturnType<typeof addCurrentAccount>>>
    export type AddCurrentAccountMutationBody = CurrentAccount
    export type AddCurrentAccountMutationError = ErrorResponse

    export const useAddCurrentAccount = <TData = Awaited<ReturnType<typeof addCurrentAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CurrentAccount},
        TContext
      > => {

      const mutationOptions = getAddCurrentAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Current Account Transaction
 */
export const addCurrentAccountTransaction = (
    currentAccountTransaction: CurrentAccountTransaction,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccountTransaction>(
      {url: `/api/purchasing/currentAccountTransaction`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: currentAccountTransaction, signal
    },
      );
    }
  


export const getAddCurrentAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof addCurrentAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountTransaction}, TContext>, }
) => {
const mutationKey = ['addCurrentAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCurrentAccountTransaction>>, {data: CurrentAccountTransaction}> = (props) => {
          const {data} = props ?? {};

          return  addCurrentAccountTransaction(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CurrentAccountTransaction}, TContext>}

    export type AddCurrentAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof addCurrentAccountTransaction>>>
    export type AddCurrentAccountTransactionMutationBody = CurrentAccountTransaction
    export type AddCurrentAccountTransactionMutationError = ErrorResponse

    export const useAddCurrentAccountTransaction = <TData = Awaited<ReturnType<typeof addCurrentAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CurrentAccountTransaction},
        TContext
      > => {

      const mutationOptions = getAddCurrentAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new CurrentAccountBankAccount
 */
export const addCurrentAccountBankAccount = (
    currentAccountBankAccount: CurrentAccountBankAccount,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccountBankAccount>(
      {url: `/api/purchasing/currentAccountBankAccount`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: currentAccountBankAccount, signal
    },
      );
    }
  


export const getAddCurrentAccountBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof addCurrentAccountBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountBankAccount}, TContext>, }
) => {
const mutationKey = ['addCurrentAccountBankAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCurrentAccountBankAccount>>, {data: CurrentAccountBankAccount}> = (props) => {
          const {data} = props ?? {};

          return  addCurrentAccountBankAccount(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CurrentAccountBankAccount}, TContext>}

    export type AddCurrentAccountBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof addCurrentAccountBankAccount>>>
    export type AddCurrentAccountBankAccountMutationBody = CurrentAccountBankAccount
    export type AddCurrentAccountBankAccountMutationError = ErrorResponse

    export const useAddCurrentAccountBankAccount = <TData = Awaited<ReturnType<typeof addCurrentAccountBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountBankAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CurrentAccountBankAccount},
        TContext
      > => {

      const mutationOptions = getAddCurrentAccountBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new AdditionalCost
 */
export const addAdditionalCost = (
    additionalCost: AdditionalCost,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AdditionalCost>(
      {url: `/api/purchasing/additionalCost`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: additionalCost, signal
    },
      );
    }
  


export const getAddAdditionalCostMutationOptions = <TData = Awaited<ReturnType<typeof addAdditionalCost>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AdditionalCost}, TContext>, }
) => {
const mutationKey = ['addAdditionalCost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAdditionalCost>>, {data: AdditionalCost}> = (props) => {
          const {data} = props ?? {};

          return  addAdditionalCost(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: AdditionalCost}, TContext>}

    export type AddAdditionalCostMutationResult = NonNullable<Awaited<ReturnType<typeof addAdditionalCost>>>
    export type AddAdditionalCostMutationBody = AdditionalCost
    export type AddAdditionalCostMutationError = ErrorResponse

    export const useAddAdditionalCost = <TData = Awaited<ReturnType<typeof addAdditionalCost>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AdditionalCost}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: AdditionalCost},
        TContext
      > => {

      const mutationOptions = getAddAdditionalCostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Project
 */
export const addProject = (
    project: Project,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Project>(
      {url: `/api/production/project`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: project, signal
    },
      );
    }
  


export const getAddProjectMutationOptions = <TData = Awaited<ReturnType<typeof addProject>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Project}, TContext>, }
) => {
const mutationKey = ['addProject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProject>>, {data: Project}> = (props) => {
          const {data} = props ?? {};

          return  addProject(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Project}, TContext>}

    export type AddProjectMutationResult = NonNullable<Awaited<ReturnType<typeof addProject>>>
    export type AddProjectMutationBody = Project
    export type AddProjectMutationError = ErrorResponse

    export const useAddProject = <TData = Awaited<ReturnType<typeof addProject>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Project}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Project},
        TContext
      > => {

      const mutationOptions = getAddProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List WorkOrders. Supports filtering via rsql.
 */
export const workOrders = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<WorkOrders>(
      {url: `/api/planning/workOrders`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getWorkOrdersMutationOptions = <TData = Awaited<ReturnType<typeof workOrders>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['workOrders'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workOrders>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  workOrders(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type WorkOrdersMutationResult = NonNullable<Awaited<ReturnType<typeof workOrders>>>
    export type WorkOrdersMutationBody = FilteringRequest
    export type WorkOrdersMutationError = ErrorResponse

    export const useWorkOrders = <TData = Awaited<ReturnType<typeof workOrders>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getWorkOrdersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new WorkOrder
 */
export const addWorkOrder = (
    workOrder: WorkOrder,
 signal?: AbortSignal
) => {
      
      
      return customMutator<WorkOrder>(
      {url: `/api/planning/workOrder`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: workOrder, signal
    },
      );
    }
  


export const getAddWorkOrderMutationOptions = <TData = Awaited<ReturnType<typeof addWorkOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: WorkOrder}, TContext>, }
) => {
const mutationKey = ['addWorkOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addWorkOrder>>, {data: WorkOrder}> = (props) => {
          const {data} = props ?? {};

          return  addWorkOrder(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: WorkOrder}, TContext>}

    export type AddWorkOrderMutationResult = NonNullable<Awaited<ReturnType<typeof addWorkOrder>>>
    export type AddWorkOrderMutationBody = WorkOrder
    export type AddWorkOrderMutationError = ErrorResponse

    export const useAddWorkOrder = <TData = Awaited<ReturnType<typeof addWorkOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: WorkOrder}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: WorkOrder},
        TContext
      > => {

      const mutationOptions = getAddWorkOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List WorkOrderConnections. Supports filtering via rsql.
 */
export const workOrderConnections = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<WorkOrderConnections>(
      {url: `/api/planning/workOrderConnections`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getWorkOrderConnectionsMutationOptions = <TData = Awaited<ReturnType<typeof workOrderConnections>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['workOrderConnections'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof workOrderConnections>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  workOrderConnections(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type WorkOrderConnectionsMutationResult = NonNullable<Awaited<ReturnType<typeof workOrderConnections>>>
    export type WorkOrderConnectionsMutationBody = FilteringRequest
    export type WorkOrderConnectionsMutationError = ErrorResponse

    export const useWorkOrderConnections = <TData = Awaited<ReturnType<typeof workOrderConnections>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getWorkOrderConnectionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new WorkOrderConnection
 */
export const addWorkOrderConnection = (
    workOrderConnection: WorkOrderConnection,
 signal?: AbortSignal
) => {
      
      
      return customMutator<WorkOrderConnection>(
      {url: `/api/planning/workOrderConnection`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: workOrderConnection, signal
    },
      );
    }
  


export const getAddWorkOrderConnectionMutationOptions = <TData = Awaited<ReturnType<typeof addWorkOrderConnection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: WorkOrderConnection}, TContext>, }
) => {
const mutationKey = ['addWorkOrderConnection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addWorkOrderConnection>>, {data: WorkOrderConnection}> = (props) => {
          const {data} = props ?? {};

          return  addWorkOrderConnection(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: WorkOrderConnection}, TContext>}

    export type AddWorkOrderConnectionMutationResult = NonNullable<Awaited<ReturnType<typeof addWorkOrderConnection>>>
    export type AddWorkOrderConnectionMutationBody = WorkOrderConnection
    export type AddWorkOrderConnectionMutationError = ErrorResponse

    export const useAddWorkOrderConnection = <TData = Awaited<ReturnType<typeof addWorkOrderConnection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: WorkOrderConnection}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: WorkOrderConnection},
        TContext
      > => {

      const mutationOptions = getAddWorkOrderConnectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new WBS
 */
export const addWBS = (
    wbs: Wbs,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Wbs>(
      {url: `/api/planning/wbs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: wbs, signal
    },
      );
    }
  


export const getAddWBSMutationOptions = <TData = Awaited<ReturnType<typeof addWBS>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Wbs}, TContext>, }
) => {
const mutationKey = ['addWBS'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addWBS>>, {data: Wbs}> = (props) => {
          const {data} = props ?? {};

          return  addWBS(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Wbs}, TContext>}

    export type AddWBSMutationResult = NonNullable<Awaited<ReturnType<typeof addWBS>>>
    export type AddWBSMutationBody = Wbs
    export type AddWBSMutationError = ErrorResponse

    export const useAddWBS = <TData = Awaited<ReturnType<typeof addWBS>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Wbs}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Wbs},
        TContext
      > => {

      const mutationOptions = getAddWBSMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List WBS. Supports filtering via rsql.
 */
export const wbsList = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<WBSList>(
      {url: `/api/planning/wbsList`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getWbsListMutationOptions = <TData = Awaited<ReturnType<typeof wbsList>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['wbsList'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof wbsList>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  wbsList(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type WbsListMutationResult = NonNullable<Awaited<ReturnType<typeof wbsList>>>
    export type WbsListMutationBody = FilteringRequest
    export type WbsListMutationError = ErrorResponse

    export const useWbsList = <TData = Awaited<ReturnType<typeof wbsList>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getWbsListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List ProductionPlanProducts. Supports filtering via rsql.
 */
export const productionPlanProducts = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductionPlanProducts>(
      {url: `/api/planning/productionPlanProducts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getProductionPlanProductsMutationOptions = <TData = Awaited<ReturnType<typeof productionPlanProducts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['productionPlanProducts'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof productionPlanProducts>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  productionPlanProducts(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ProductionPlanProductsMutationResult = NonNullable<Awaited<ReturnType<typeof productionPlanProducts>>>
    export type ProductionPlanProductsMutationBody = FilteringRequest
    export type ProductionPlanProductsMutationError = ErrorResponse

    export const useProductionPlanProducts = <TData = Awaited<ReturnType<typeof productionPlanProducts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getProductionPlanProductsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ProductionPlanProduct
 */
export const addProductionPlanProduct = (
    productionPlanProduct: ProductionPlanProduct,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductionPlanProduct>(
      {url: `/api/planning/productionPlanProduct`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productionPlanProduct, signal
    },
      );
    }
  


export const getAddProductionPlanProductMutationOptions = <TData = Awaited<ReturnType<typeof addProductionPlanProduct>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductionPlanProduct}, TContext>, }
) => {
const mutationKey = ['addProductionPlanProduct'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProductionPlanProduct>>, {data: ProductionPlanProduct}> = (props) => {
          const {data} = props ?? {};

          return  addProductionPlanProduct(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ProductionPlanProduct}, TContext>}

    export type AddProductionPlanProductMutationResult = NonNullable<Awaited<ReturnType<typeof addProductionPlanProduct>>>
    export type AddProductionPlanProductMutationBody = ProductionPlanProduct
    export type AddProductionPlanProductMutationError = ErrorResponse

    export const useAddProductionPlanProduct = <TData = Awaited<ReturnType<typeof addProductionPlanProduct>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductionPlanProduct}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ProductionPlanProduct},
        TContext
      > => {

      const mutationOptions = getAddProductionPlanProductMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List ProductPlans. Supports filtering via rsql.
 */
export const productPlans = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductPlans>(
      {url: `/api/planning/productPlans`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getProductPlansMutationOptions = <TData = Awaited<ReturnType<typeof productPlans>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['productPlans'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof productPlans>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  productPlans(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ProductPlansMutationResult = NonNullable<Awaited<ReturnType<typeof productPlans>>>
    export type ProductPlansMutationBody = FilteringRequest
    export type ProductPlansMutationError = ErrorResponse

    export const useProductPlans = <TData = Awaited<ReturnType<typeof productPlans>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getProductPlansMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ProductPlan
 */
export const addProductPlan = (
    productPlan: ProductPlan,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductPlan>(
      {url: `/api/planning/productPlan`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productPlan, signal
    },
      );
    }
  


export const getAddProductPlanMutationOptions = <TData = Awaited<ReturnType<typeof addProductPlan>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductPlan}, TContext>, }
) => {
const mutationKey = ['addProductPlan'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProductPlan>>, {data: ProductPlan}> = (props) => {
          const {data} = props ?? {};

          return  addProductPlan(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ProductPlan}, TContext>}

    export type AddProductPlanMutationResult = NonNullable<Awaited<ReturnType<typeof addProductPlan>>>
    export type AddProductPlanMutationBody = ProductPlan
    export type AddProductPlanMutationError = ErrorResponse

    export const useAddProductPlan = <TData = Awaited<ReturnType<typeof addProductPlan>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductPlan}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ProductPlan},
        TContext
      > => {

      const mutationOptions = getAddProductPlanMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Activity
 */
export const addActivity = (
    activity: Activity,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Activity>(
      {url: `/api/planning/activity`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: activity, signal
    },
      );
    }
  


export const getAddActivityMutationOptions = <TData = Awaited<ReturnType<typeof addActivity>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Activity}, TContext>, }
) => {
const mutationKey = ['addActivity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addActivity>>, {data: Activity}> = (props) => {
          const {data} = props ?? {};

          return  addActivity(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Activity}, TContext>}

    export type AddActivityMutationResult = NonNullable<Awaited<ReturnType<typeof addActivity>>>
    export type AddActivityMutationBody = Activity
    export type AddActivityMutationError = ErrorResponse

    export const useAddActivity = <TData = Awaited<ReturnType<typeof addActivity>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Activity}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Activity},
        TContext
      > => {

      const mutationOptions = getAddActivityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List ActivityConnections. Supports filtering via rsql.
 */
export const activityConnections = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ActivityConnections>(
      {url: `/api/planning/activityConnections`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getActivityConnectionsMutationOptions = <TData = Awaited<ReturnType<typeof activityConnections>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['activityConnections'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof activityConnections>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  activityConnections(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ActivityConnectionsMutationResult = NonNullable<Awaited<ReturnType<typeof activityConnections>>>
    export type ActivityConnectionsMutationBody = FilteringRequest
    export type ActivityConnectionsMutationError = ErrorResponse

    export const useActivityConnections = <TData = Awaited<ReturnType<typeof activityConnections>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getActivityConnectionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ActivityConnection
 */
export const addActivityConnection = (
    activityConnection: ActivityConnection,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ActivityConnection>(
      {url: `/api/planning/activityConnection`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: activityConnection, signal
    },
      );
    }
  


export const getAddActivityConnectionMutationOptions = <TData = Awaited<ReturnType<typeof addActivityConnection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ActivityConnection}, TContext>, }
) => {
const mutationKey = ['addActivityConnection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addActivityConnection>>, {data: ActivityConnection}> = (props) => {
          const {data} = props ?? {};

          return  addActivityConnection(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ActivityConnection}, TContext>}

    export type AddActivityConnectionMutationResult = NonNullable<Awaited<ReturnType<typeof addActivityConnection>>>
    export type AddActivityConnectionMutationBody = ActivityConnection
    export type AddActivityConnectionMutationError = ErrorResponse

    export const useAddActivityConnection = <TData = Awaited<ReturnType<typeof addActivityConnection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ActivityConnection}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ActivityConnection},
        TContext
      > => {

      const mutationOptions = getAddActivityConnectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Activitys. Supports filtering via rsql.
 */
export const activities = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Activities>(
      {url: `/api/planning/activities`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getActivitiesMutationOptions = <TData = Awaited<ReturnType<typeof activities>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['activities'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof activities>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  activities(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ActivitiesMutationResult = NonNullable<Awaited<ReturnType<typeof activities>>>
    export type ActivitiesMutationBody = FilteringRequest
    export type ActivitiesMutationError = ErrorResponse

    export const useActivities = <TData = Awaited<ReturnType<typeof activities>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getActivitiesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create new Time Keeping
 */
export const createTimeKeeping = (
    timeKeeping: TimeKeeping,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeKeeping>(
      {url: `/api/hr/timekeeping`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: timeKeeping, signal
    },
      );
    }
  


export const getCreateTimeKeepingMutationOptions = <TData = Awaited<ReturnType<typeof createTimeKeeping>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, }
) => {
const mutationKey = ['createTimeKeeping'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTimeKeeping>>, {data: TimeKeeping}> = (props) => {
          const {data} = props ?? {};

          return  createTimeKeeping(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>}

    export type CreateTimeKeepingMutationResult = NonNullable<Awaited<ReturnType<typeof createTimeKeeping>>>
    export type CreateTimeKeepingMutationBody = TimeKeeping
    export type CreateTimeKeepingMutationError = ErrorResponse

    export const useCreateTimeKeeping = <TData = Awaited<ReturnType<typeof createTimeKeeping>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: TimeKeeping},
        TContext
      > => {

      const mutationOptions = getCreateTimeKeepingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Time Keeping Total
 */
export const calculateTimeKeepingTotal = (
    timeKeeping: TimeKeeping,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeKeepingCalculationResult>(
      {url: `/api/hr/timekeeping/calculateTotal`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: timeKeeping, signal
    },
      );
    }
  


export const getCalculateTimeKeepingTotalMutationOptions = <TData = Awaited<ReturnType<typeof calculateTimeKeepingTotal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, }
) => {
const mutationKey = ['calculateTimeKeepingTotal'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateTimeKeepingTotal>>, {data: TimeKeeping}> = (props) => {
          const {data} = props ?? {};

          return  calculateTimeKeepingTotal(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>}

    export type CalculateTimeKeepingTotalMutationResult = NonNullable<Awaited<ReturnType<typeof calculateTimeKeepingTotal>>>
    export type CalculateTimeKeepingTotalMutationBody = TimeKeeping
    export type CalculateTimeKeepingTotalMutationError = ErrorResponse

    export const useCalculateTimeKeepingTotal = <TData = Awaited<ReturnType<typeof calculateTimeKeepingTotal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: TimeKeeping},
        TContext
      > => {

      const mutationOptions = getCalculateTimeKeepingTotalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Employee
 */
export const addEmployee = (
    employee: Employee,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Employee>(
      {url: `/api/hr/employee`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: employee, signal
    },
      );
    }
  


export const getAddEmployeeMutationOptions = <TData = Awaited<ReturnType<typeof addEmployee>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Employee}, TContext>, }
) => {
const mutationKey = ['addEmployee'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addEmployee>>, {data: Employee}> = (props) => {
          const {data} = props ?? {};

          return  addEmployee(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Employee}, TContext>}

    export type AddEmployeeMutationResult = NonNullable<Awaited<ReturnType<typeof addEmployee>>>
    export type AddEmployeeMutationBody = Employee
    export type AddEmployeeMutationError = ErrorResponse

    export const useAddEmployee = <TData = Awaited<ReturnType<typeof addEmployee>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Employee}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Employee},
        TContext
      > => {

      const mutationOptions = getAddEmployeeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new TimeOff
 */
export const addTimeOff = (
    id: number,
    timeOff: TimeOff,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeOff>(
      {url: `/api/hr/employee/${id}/timeoff`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: timeOff, signal
    },
      );
    }
  


export const getAddTimeOffMutationOptions = <TData = Awaited<ReturnType<typeof addTimeOff>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeOff}, TContext>, }
) => {
const mutationKey = ['addTimeOff'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTimeOff>>, {id: number;data: TimeOff}> = (props) => {
          const {id,data} = props ?? {};

          return  addTimeOff(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: TimeOff}, TContext>}

    export type AddTimeOffMutationResult = NonNullable<Awaited<ReturnType<typeof addTimeOff>>>
    export type AddTimeOffMutationBody = TimeOff
    export type AddTimeOffMutationError = ErrorResponse

    export const useAddTimeOff = <TData = Awaited<ReturnType<typeof addTimeOff>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeOff}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: TimeOff},
        TContext
      > => {

      const mutationOptions = getAddTimeOffMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * EmployeePayments view. Supports filtering via rsql using Employee.
 */
export const employeePaymentsStatusView = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeePayments>(
      {url: `/api/hr/employee/payments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getEmployeePaymentsStatusViewMutationOptions = <TData = Awaited<ReturnType<typeof employeePaymentsStatusView>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['employeePaymentsStatusView'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof employeePaymentsStatusView>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  employeePaymentsStatusView(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type EmployeePaymentsStatusViewMutationResult = NonNullable<Awaited<ReturnType<typeof employeePaymentsStatusView>>>
    export type EmployeePaymentsStatusViewMutationBody = FilteringRequest
    export type EmployeePaymentsStatusViewMutationError = ErrorResponse

    export const useEmployeePaymentsStatusView = <TData = Awaited<ReturnType<typeof employeePaymentsStatusView>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getEmployeePaymentsStatusViewMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * EmployeeOvertimes view. Supports filtering via rsql using Employee.
 */
export const employeeOvertimesStatusView = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeeOvertimes>(
      {url: `/api/hr/employee/overtimes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getEmployeeOvertimesStatusViewMutationOptions = <TData = Awaited<ReturnType<typeof employeeOvertimesStatusView>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['employeeOvertimesStatusView'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof employeeOvertimesStatusView>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  employeeOvertimesStatusView(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type EmployeeOvertimesStatusViewMutationResult = NonNullable<Awaited<ReturnType<typeof employeeOvertimesStatusView>>>
    export type EmployeeOvertimesStatusViewMutationBody = FilteringRequest
    export type EmployeeOvertimesStatusViewMutationError = ErrorResponse

    export const useEmployeeOvertimesStatusView = <TData = Awaited<ReturnType<typeof employeeOvertimesStatusView>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getEmployeeOvertimesStatusViewMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List MaterialRequests. Supports filtering via rsql.
 */
export const materialRequests = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialRequests>(
      {url: `/api/general/materialRequests`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getMaterialRequestsMutationOptions = <TData = Awaited<ReturnType<typeof materialRequests>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['materialRequests'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof materialRequests>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  materialRequests(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type MaterialRequestsMutationResult = NonNullable<Awaited<ReturnType<typeof materialRequests>>>
    export type MaterialRequestsMutationBody = FilteringRequest
    export type MaterialRequestsMutationError = ErrorResponse

    export const useMaterialRequests = <TData = Awaited<ReturnType<typeof materialRequests>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getMaterialRequestsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new MaterialRequest
 */
export const addMaterialRequest = (
    materialRequest: MaterialRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialRequest>(
      {url: `/api/general/materialRequest`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: materialRequest, signal
    },
      );
    }
  


export const getAddMaterialRequestMutationOptions = <TData = Awaited<ReturnType<typeof addMaterialRequest>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialRequest}, TContext>, }
) => {
const mutationKey = ['addMaterialRequest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMaterialRequest>>, {data: MaterialRequest}> = (props) => {
          const {data} = props ?? {};

          return  addMaterialRequest(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: MaterialRequest}, TContext>}

    export type AddMaterialRequestMutationResult = NonNullable<Awaited<ReturnType<typeof addMaterialRequest>>>
    export type AddMaterialRequestMutationBody = MaterialRequest
    export type AddMaterialRequestMutationError = ErrorResponse

    export const useAddMaterialRequest = <TData = Awaited<ReturnType<typeof addMaterialRequest>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: MaterialRequest},
        TContext
      > => {

      const mutationOptions = getAddMaterialRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Bank
 */
export const addBank = (
    bank: Bank,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Bank>(
      {url: `/api/finance/bank`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bank, signal
    },
      );
    }
  


export const getAddBankMutationOptions = <TData = Awaited<ReturnType<typeof addBank>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Bank}, TContext>, }
) => {
const mutationKey = ['addBank'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBank>>, {data: Bank}> = (props) => {
          const {data} = props ?? {};

          return  addBank(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Bank}, TContext>}

    export type AddBankMutationResult = NonNullable<Awaited<ReturnType<typeof addBank>>>
    export type AddBankMutationBody = Bank
    export type AddBankMutationError = ErrorResponse

    export const useAddBank = <TData = Awaited<ReturnType<typeof addBank>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Bank}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Bank},
        TContext
      > => {

      const mutationOptions = getAddBankMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Bank Branch
 */
export const addBankBranch = (
    bankBranch: BankBranch,
 signal?: AbortSignal
) => {
      
      
      return customMutator<BankBranch>(
      {url: `/api/finance/bankBranch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bankBranch, signal
    },
      );
    }
  


export const getAddBankBranchMutationOptions = <TData = Awaited<ReturnType<typeof addBankBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankBranch}, TContext>, }
) => {
const mutationKey = ['addBankBranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBankBranch>>, {data: BankBranch}> = (props) => {
          const {data} = props ?? {};

          return  addBankBranch(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BankBranch}, TContext>}

    export type AddBankBranchMutationResult = NonNullable<Awaited<ReturnType<typeof addBankBranch>>>
    export type AddBankBranchMutationBody = BankBranch
    export type AddBankBranchMutationError = ErrorResponse

    export const useAddBankBranch = <TData = Awaited<ReturnType<typeof addBankBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankBranch}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: BankBranch},
        TContext
      > => {

      const mutationOptions = getAddBankBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Bank Account
 */
export const addBankBranch1 = (
    bankAccount: BankAccount,
 signal?: AbortSignal
) => {
      
      
      return customMutator<BankAccount>(
      {url: `/api/finance/bankAccount`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bankAccount, signal
    },
      );
    }
  


export const getAddBankBranch1MutationOptions = <TData = Awaited<ReturnType<typeof addBankBranch1>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankAccount}, TContext>, }
) => {
const mutationKey = ['addBankBranch1'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBankBranch1>>, {data: BankAccount}> = (props) => {
          const {data} = props ?? {};

          return  addBankBranch1(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BankAccount}, TContext>}

    export type AddBankBranch1MutationResult = NonNullable<Awaited<ReturnType<typeof addBankBranch1>>>
    export type AddBankBranch1MutationBody = BankAccount
    export type AddBankBranch1MutationError = ErrorResponse

    export const useAddBankBranch1 = <TData = Awaited<ReturnType<typeof addBankBranch1>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: BankAccount},
        TContext
      > => {

      const mutationOptions = getAddBankBranch1MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Department
 */
export const addDepartment = (
    department: Department,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Department>(
      {url: `/api/company/department`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: department, signal
    },
      );
    }
  


export const getAddDepartmentMutationOptions = <TData = Awaited<ReturnType<typeof addDepartment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Department}, TContext>, }
) => {
const mutationKey = ['addDepartment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addDepartment>>, {data: Department}> = (props) => {
          const {data} = props ?? {};

          return  addDepartment(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Department}, TContext>}

    export type AddDepartmentMutationResult = NonNullable<Awaited<ReturnType<typeof addDepartment>>>
    export type AddDepartmentMutationBody = Department
    export type AddDepartmentMutationError = ErrorResponse

    export const useAddDepartment = <TData = Awaited<ReturnType<typeof addDepartment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Department}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Department},
        TContext
      > => {

      const mutationOptions = getAddDepartmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Branch
 */
export const addBranch = (
    branch: Branch,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Branch>(
      {url: `/api/company/branch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: branch, signal
    },
      );
    }
  


export const getAddBranchMutationOptions = <TData = Awaited<ReturnType<typeof addBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Branch}, TContext>, }
) => {
const mutationKey = ['addBranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBranch>>, {data: Branch}> = (props) => {
          const {data} = props ?? {};

          return  addBranch(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Branch}, TContext>}

    export type AddBranchMutationResult = NonNullable<Awaited<ReturnType<typeof addBranch>>>
    export type AddBranchMutationBody = Branch
    export type AddBranchMutationError = ErrorResponse

    export const useAddBranch = <TData = Awaited<ReturnType<typeof addBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Branch}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Branch},
        TContext
      > => {

      const mutationOptions = getAddBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Section
 */
export const addSection = (
    section: Section,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Section>(
      {url: `/api/admin/section`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: section, signal
    },
      );
    }
  


export const getAddSectionMutationOptions = <TData = Awaited<ReturnType<typeof addSection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Section}, TContext>, }
) => {
const mutationKey = ['addSection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addSection>>, {data: Section}> = (props) => {
          const {data} = props ?? {};

          return  addSection(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Section}, TContext>}

    export type AddSectionMutationResult = NonNullable<Awaited<ReturnType<typeof addSection>>>
    export type AddSectionMutationBody = Section
    export type AddSectionMutationError = ErrorResponse

    export const useAddSection = <TData = Awaited<ReturnType<typeof addSection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Section}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Section},
        TContext
      > => {

      const mutationOptions = getAddSectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Role
 */
export const addRole = (
    role: Role,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Role>(
      {url: `/api/admin/role`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: role, signal
    },
      );
    }
  


export const getAddRoleMutationOptions = <TData = Awaited<ReturnType<typeof addRole>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Role}, TContext>, }
) => {
const mutationKey = ['addRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addRole>>, {data: Role}> = (props) => {
          const {data} = props ?? {};

          return  addRole(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Role}, TContext>}

    export type AddRoleMutationResult = NonNullable<Awaited<ReturnType<typeof addRole>>>
    export type AddRoleMutationBody = Role
    export type AddRoleMutationError = ErrorResponse

    export const useAddRole = <TData = Awaited<ReturnType<typeof addRole>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Role}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Role},
        TContext
      > => {

      const mutationOptions = getAddRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Public Holiday
 */
export const addPublicHoliday = (
    publicHoliday: PublicHoliday,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PublicHoliday>(
      {url: `/api/admin/publicHoliday`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: publicHoliday, signal
    },
      );
    }
  


export const getAddPublicHolidayMutationOptions = <TData = Awaited<ReturnType<typeof addPublicHoliday>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PublicHoliday}, TContext>, }
) => {
const mutationKey = ['addPublicHoliday'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPublicHoliday>>, {data: PublicHoliday}> = (props) => {
          const {data} = props ?? {};

          return  addPublicHoliday(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: PublicHoliday}, TContext>}

    export type AddPublicHolidayMutationResult = NonNullable<Awaited<ReturnType<typeof addPublicHoliday>>>
    export type AddPublicHolidayMutationBody = PublicHoliday
    export type AddPublicHolidayMutationError = ErrorResponse

    export const useAddPublicHoliday = <TData = Awaited<ReturnType<typeof addPublicHoliday>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PublicHoliday}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: PublicHoliday},
        TContext
      > => {

      const mutationOptions = getAddPublicHolidayMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new PaymentMethod
 */
export const addPaymentMethod = (
    paymentMethod: PaymentMethod,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PaymentMethod>(
      {url: `/api/admin/paymentMethod`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: paymentMethod, signal
    },
      );
    }
  


export const getAddPaymentMethodMutationOptions = <TData = Awaited<ReturnType<typeof addPaymentMethod>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PaymentMethod}, TContext>, }
) => {
const mutationKey = ['addPaymentMethod'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPaymentMethod>>, {data: PaymentMethod}> = (props) => {
          const {data} = props ?? {};

          return  addPaymentMethod(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: PaymentMethod}, TContext>}

    export type AddPaymentMethodMutationResult = NonNullable<Awaited<ReturnType<typeof addPaymentMethod>>>
    export type AddPaymentMethodMutationBody = PaymentMethod
    export type AddPaymentMethodMutationError = ErrorResponse

    export const useAddPaymentMethod = <TData = Awaited<ReturnType<typeof addPaymentMethod>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PaymentMethod}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: PaymentMethod},
        TContext
      > => {

      const mutationOptions = getAddPaymentMethodMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Machine
 */
export const addMachine = (
    machine: Machine,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Machine>(
      {url: `/api/admin/machine`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: machine, signal
    },
      );
    }
  


export const getAddMachineMutationOptions = <TData = Awaited<ReturnType<typeof addMachine>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Machine}, TContext>, }
) => {
const mutationKey = ['addMachine'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMachine>>, {data: Machine}> = (props) => {
          const {data} = props ?? {};

          return  addMachine(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Machine}, TContext>}

    export type AddMachineMutationResult = NonNullable<Awaited<ReturnType<typeof addMachine>>>
    export type AddMachineMutationBody = Machine
    export type AddMachineMutationError = ErrorResponse

    export const useAddMachine = <TData = Awaited<ReturnType<typeof addMachine>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Machine}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Machine},
        TContext
      > => {

      const mutationOptions = getAddMachineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Depot
 */
export const addDepot = (
    depot: Depot,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Depot>(
      {url: `/api/admin/depot`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: depot, signal
    },
      );
    }
  


export const getAddDepotMutationOptions = <TData = Awaited<ReturnType<typeof addDepot>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Depot}, TContext>, }
) => {
const mutationKey = ['addDepot'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addDepot>>, {data: Depot}> = (props) => {
          const {data} = props ?? {};

          return  addDepot(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Depot}, TContext>}

    export type AddDepotMutationResult = NonNullable<Awaited<ReturnType<typeof addDepot>>>
    export type AddDepotMutationBody = Depot
    export type AddDepotMutationError = ErrorResponse

    export const useAddDepot = <TData = Awaited<ReturnType<typeof addDepot>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Depot}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Depot},
        TContext
      > => {

      const mutationOptions = getAddDepotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Company
 */
export const addCompany = (
    company: Company,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Company>(
      {url: `/api/admin/company`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: company, signal
    },
      );
    }
  


export const getAddCompanyMutationOptions = <TData = Awaited<ReturnType<typeof addCompany>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Company}, TContext>, }
) => {
const mutationKey = ['addCompany'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCompany>>, {data: Company}> = (props) => {
          const {data} = props ?? {};

          return  addCompany(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Company}, TContext>}

    export type AddCompanyMutationResult = NonNullable<Awaited<ReturnType<typeof addCompany>>>
    export type AddCompanyMutationBody = Company
    export type AddCompanyMutationError = ErrorResponse

    export const useAddCompany = <TData = Awaited<ReturnType<typeof addCompany>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Company}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Company},
        TContext
      > => {

      const mutationOptions = getAddCompanyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ExpenseInvoice
 */
export const addExpenseInvoice = (
    expenseInvoice: ExpenseInvoice,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseInvoice>(
      {url: `/api/accounting/expenseInvoice`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: expenseInvoice, signal
    },
      );
    }
  


export const getAddExpenseInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof addExpenseInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, }
) => {
const mutationKey = ['addExpenseInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addExpenseInvoice>>, {data: ExpenseInvoice}> = (props) => {
          const {data} = props ?? {};

          return  addExpenseInvoice(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>}

    export type AddExpenseInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof addExpenseInvoice>>>
    export type AddExpenseInvoiceMutationBody = ExpenseInvoice
    export type AddExpenseInvoiceMutationError = ErrorResponse

    export const useAddExpenseInvoice = <TData = Awaited<ReturnType<typeof addExpenseInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ExpenseInvoice},
        TContext
      > => {

      const mutationOptions = getAddExpenseInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Invoice Total
 */
export const calculateInvoiceTotal1 = (
    expenseInvoice: ExpenseInvoice,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseInvoiceCalculationResult>(
      {url: `/api/accounting/expenseInvoice/calculateTotal`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: expenseInvoice, signal
    },
      );
    }
  


export const getCalculateInvoiceTotal1MutationOptions = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal1>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, }
) => {
const mutationKey = ['calculateInvoiceTotal1'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateInvoiceTotal1>>, {data: ExpenseInvoice}> = (props) => {
          const {data} = props ?? {};

          return  calculateInvoiceTotal1(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>}

    export type CalculateInvoiceTotal1MutationResult = NonNullable<Awaited<ReturnType<typeof calculateInvoiceTotal1>>>
    export type CalculateInvoiceTotal1MutationBody = ExpenseInvoice
    export type CalculateInvoiceTotal1MutationError = ErrorResponse

    export const useCalculateInvoiceTotal1 = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal1>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ExpenseInvoice},
        TContext
      > => {

      const mutationOptions = getCalculateInvoiceTotal1MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ExpenseCard
 */
export const addExpenseCard = (
    expenseCard: ExpenseCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseCard>(
      {url: `/api/accounting/expenseCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: expenseCard, signal
    },
      );
    }
  


export const getAddExpenseCardMutationOptions = <TData = Awaited<ReturnType<typeof addExpenseCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseCard}, TContext>, }
) => {
const mutationKey = ['addExpenseCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addExpenseCard>>, {data: ExpenseCard}> = (props) => {
          const {data} = props ?? {};

          return  addExpenseCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ExpenseCard}, TContext>}

    export type AddExpenseCardMutationResult = NonNullable<Awaited<ReturnType<typeof addExpenseCard>>>
    export type AddExpenseCardMutationBody = ExpenseCard
    export type AddExpenseCardMutationError = ErrorResponse

    export const useAddExpenseCard = <TData = Awaited<ReturnType<typeof addExpenseCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ExpenseCard},
        TContext
      > => {

      const mutationOptions = getAddExpenseCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new CashAccount
 */
export const addCashAccount = (
    cashAccount: CashAccount,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccount>(
      {url: `/api/accounting/cashAccount`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cashAccount, signal
    },
      );
    }
  


export const getAddCashAccountMutationOptions = <TData = Awaited<ReturnType<typeof addCashAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccount}, TContext>, }
) => {
const mutationKey = ['addCashAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCashAccount>>, {data: CashAccount}> = (props) => {
          const {data} = props ?? {};

          return  addCashAccount(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CashAccount}, TContext>}

    export type AddCashAccountMutationResult = NonNullable<Awaited<ReturnType<typeof addCashAccount>>>
    export type AddCashAccountMutationBody = CashAccount
    export type AddCashAccountMutationError = ErrorResponse

    export const useAddCashAccount = <TData = Awaited<ReturnType<typeof addCashAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CashAccount},
        TContext
      > => {

      const mutationOptions = getAddCashAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new CashAccountTransaction
 */
export const addCashAccountTransaction = (
    cashAccountTransaction: CashAccountTransaction,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccountTransaction>(
      {url: `/api/accounting/cashAccountTransaction`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cashAccountTransaction, signal
    },
      );
    }
  


export const getAddCashAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof addCashAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransaction}, TContext>, }
) => {
const mutationKey = ['addCashAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCashAccountTransaction>>, {data: CashAccountTransaction}> = (props) => {
          const {data} = props ?? {};

          return  addCashAccountTransaction(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CashAccountTransaction}, TContext>}

    export type AddCashAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof addCashAccountTransaction>>>
    export type AddCashAccountTransactionMutationBody = CashAccountTransaction
    export type AddCashAccountTransactionMutationError = ErrorResponse

    export const useAddCashAccountTransaction = <TData = Awaited<ReturnType<typeof addCashAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CashAccountTransaction},
        TContext
      > => {

      const mutationOptions = getAddCashAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Balance
 */
export const calculateBalance = (
    cashAccountTransactionEntity: CashAccountTransactionEntity[],
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccountBalanceResult>(
      {url: `/api/accounting/accounting/calculateBalance`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cashAccountTransactionEntity, signal
    },
      );
    }
  


export const getCalculateBalanceMutationOptions = <TData = Awaited<ReturnType<typeof calculateBalance>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransactionEntity[]}, TContext>, }
) => {
const mutationKey = ['calculateBalance'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateBalance>>, {data: CashAccountTransactionEntity[]}> = (props) => {
          const {data} = props ?? {};

          return  calculateBalance(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CashAccountTransactionEntity[]}, TContext>}

    export type CalculateBalanceMutationResult = NonNullable<Awaited<ReturnType<typeof calculateBalance>>>
    export type CalculateBalanceMutationBody = CashAccountTransactionEntity[]
    export type CalculateBalanceMutationError = ErrorResponse

    export const useCalculateBalance = <TData = Awaited<ReturnType<typeof calculateBalance>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransactionEntity[]}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CashAccountTransactionEntity[]},
        TContext
      > => {

      const mutationOptions = getCalculateBalanceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Returns user's own roles
 */
export const roles1 = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<UserRolesResponse>(
      {url: `/api/user/roles`, method: 'GET', signal
    },
      );
    }
  

export const getRoles1QueryKey = () => {
    return [`/api/user/roles`] as const;
    }

    
export const getRoles1QueryOptions = <TData = Awaited<ReturnType<typeof roles1>>, TError = ResponseBase>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRoles1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof roles1>>> = ({ signal }) => roles1(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type Roles1QueryResult = NonNullable<Awaited<ReturnType<typeof roles1>>>
export type Roles1QueryError = ResponseBase


export function useRoles1<TData = Awaited<ReturnType<typeof roles1>>, TError = ResponseBase>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof roles1>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRoles1<TData = Awaited<ReturnType<typeof roles1>>, TError = ResponseBase>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof roles1>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRoles1<TData = Awaited<ReturnType<typeof roles1>>, TError = ResponseBase>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useRoles1<TData = Awaited<ReturnType<typeof roles1>>, TError = ResponseBase>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getRoles1QueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getRoles1SuspenseQueryOptions = <TData = Awaited<ReturnType<typeof roles1>>, TError = ResponseBase>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRoles1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof roles1>>> = ({ signal }) => roles1(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type Roles1SuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof roles1>>>
export type Roles1SuspenseQueryError = ResponseBase


export function useRoles1Suspense<TData = Awaited<ReturnType<typeof roles1>>, TError = ResponseBase>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRoles1Suspense<TData = Awaited<ReturnType<typeof roles1>>, TError = ResponseBase>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRoles1Suspense<TData = Awaited<ReturnType<typeof roles1>>, TError = ResponseBase>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useRoles1Suspense<TData = Awaited<ReturnType<typeof roles1>>, TError = ResponseBase>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof roles1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getRoles1SuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get ServiceGroup Tree
 */
export const getServiceGroupTree = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceGroupTreeDataResponse>(
      {url: `/api/storage/serviceGroup/tree`, method: 'GET', signal
    },
      );
    }
  

export const getGetServiceGroupTreeQueryKey = () => {
    return [`/api/storage/serviceGroup/tree`] as const;
    }

    
export const getGetServiceGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroupTree>>> = ({ signal }) => getServiceGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroupTree>>>
export type GetServiceGroupTreeQueryError = unknown


export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroupTree>>> = ({ signal }) => getServiceGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroupTree>>>
export type GetServiceGroupTreeSuspenseQueryError = unknown


export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get Service Group Flat List
 */
export const getServiceGroupFlatList = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceGroupTreeDataResponse>(
      {url: `/api/storage/serviceGroup/flatList`, method: 'GET', signal
    },
      );
    }
  

export const getGetServiceGroupFlatListQueryKey = () => {
    return [`/api/storage/serviceGroup/flatList`] as const;
    }

    
export const getGetServiceGroupFlatListQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroupFlatList>>> = ({ signal }) => getServiceGroupFlatList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupFlatListQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroupFlatList>>>
export type GetServiceGroupFlatListQueryError = unknown


export function useGetServiceGroupFlatList<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupFlatList<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupFlatList<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupFlatList<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupFlatListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceGroupFlatListSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroupFlatList>>> = ({ signal }) => getServiceGroupFlatList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupFlatListSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroupFlatList>>>
export type GetServiceGroupFlatListSuspenseQueryError = unknown


export function useGetServiceGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupFlatListSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get ProductGroup Tree
 */
export const getProductGroupTree = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductGroupTreeDataResponse>(
      {url: `/api/storage/productGroup/tree`, method: 'GET', signal
    },
      );
    }
  

export const getGetProductGroupTreeQueryKey = () => {
    return [`/api/storage/productGroup/tree`] as const;
    }

    
export const getGetProductGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroupTree>>> = ({ signal }) => getProductGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroupTree>>>
export type GetProductGroupTreeQueryError = unknown


export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroupTree>>> = ({ signal }) => getProductGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroupTree>>>
export type GetProductGroupTreeSuspenseQueryError = unknown


export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get ProductGroup Flat List
 */
export const getProductGroupFlatList = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductGroupTreeDataResponse>(
      {url: `/api/storage/productGroup/flatList`, method: 'GET', signal
    },
      );
    }
  

export const getGetProductGroupFlatListQueryKey = () => {
    return [`/api/storage/productGroup/flatList`] as const;
    }

    
export const getGetProductGroupFlatListQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroupFlatList>>> = ({ signal }) => getProductGroupFlatList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupFlatListQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroupFlatList>>>
export type GetProductGroupFlatListQueryError = unknown


export function useGetProductGroupFlatList<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupFlatList<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupFlatList<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupFlatList<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupFlatListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductGroupFlatListSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroupFlatList>>> = ({ signal }) => getProductGroupFlatList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupFlatListSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroupFlatList>>>
export type GetProductGroupFlatListSuspenseQueryError = unknown


export function useGetProductGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupFlatListSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get MaterialGroup Tree
 */
export const getMaterialGroupTree = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialGroupTreeDataResponse>(
      {url: `/api/storage/materialGroup/tree`, method: 'GET', signal
    },
      );
    }
  

export const getGetMaterialGroupTreeQueryKey = () => {
    return [`/api/storage/materialGroup/tree`] as const;
    }

    
export const getGetMaterialGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroupTree>>> = ({ signal }) => getMaterialGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroupTree>>>
export type GetMaterialGroupTreeQueryError = unknown


export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroupTree>>> = ({ signal }) => getMaterialGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroupTree>>>
export type GetMaterialGroupTreeSuspenseQueryError = unknown


export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get MaterialGroup Flat List
 */
export const getMaterialGroupFlatList = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialGroupTreeDataResponse>(
      {url: `/api/storage/materialGroup/flatList`, method: 'GET', signal
    },
      );
    }
  

export const getGetMaterialGroupFlatListQueryKey = () => {
    return [`/api/storage/materialGroup/flatList`] as const;
    }

    
export const getGetMaterialGroupFlatListQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroupFlatList>>> = ({ signal }) => getMaterialGroupFlatList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupFlatListQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroupFlatList>>>
export type GetMaterialGroupFlatListQueryError = unknown


export function useGetMaterialGroupFlatList<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupFlatList<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupFlatList<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupFlatList<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupFlatListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialGroupFlatListSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroupFlatList>>> = ({ signal }) => getMaterialGroupFlatList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupFlatListSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroupFlatList>>>
export type GetMaterialGroupFlatListSuspenseQueryError = unknown


export function useGetMaterialGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupFlatListSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get FixtureGroup Tree
 */
export const getFixtureGroupTree = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureGroupTreeDataResponse>(
      {url: `/api/storage/fixtureGroup/tree`, method: 'GET', signal
    },
      );
    }
  

export const getGetFixtureGroupTreeQueryKey = () => {
    return [`/api/storage/fixtureGroup/tree`] as const;
    }

    
export const getGetFixtureGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroupTree>>> = ({ signal }) => getFixtureGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroupTree>>>
export type GetFixtureGroupTreeQueryError = unknown


export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFixtureGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroupTree>>> = ({ signal }) => getFixtureGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroupTree>>>
export type GetFixtureGroupTreeSuspenseQueryError = unknown


export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get FixtureGroup Flat List
 */
export const getFixtureGroupFlatList = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureGroupTreeDataResponse>(
      {url: `/api/storage/fixtureGroup/flatList`, method: 'GET', signal
    },
      );
    }
  

export const getGetFixtureGroupFlatListQueryKey = () => {
    return [`/api/storage/fixtureGroup/flatList`] as const;
    }

    
export const getGetFixtureGroupFlatListQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroupFlatList>>> = ({ signal }) => getFixtureGroupFlatList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupFlatListQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroupFlatList>>>
export type GetFixtureGroupFlatListQueryError = unknown


export function useGetFixtureGroupFlatList<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupFlatList<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupFlatList<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupFlatList<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupFlatListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFixtureGroupFlatListSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroupFlatList>>> = ({ signal }) => getFixtureGroupFlatList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupFlatListSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroupFlatList>>>
export type GetFixtureGroupFlatListSuspenseQueryError = unknown


export function useGetFixtureGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupFlatListSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get Draft Time Keeping for Employee
 */
export const getTimeKeepingDraft = (
    id: number,
    year: number,
    month: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeKeeping>(
      {url: `/api/hr/timekeeping/draft/employee/${id}/year/${year}/month/${month}`, method: 'GET', signal
    },
      );
    }
  

export const getGetTimeKeepingDraftQueryKey = (id: number,
    year: number,
    month: number,) => {
    return [`/api/hr/timekeeping/draft/employee/${id}/year/${year}/month/${month}`] as const;
    }

    
export const getGetTimeKeepingDraftQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingDraftQueryKey(id,year,month);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeepingDraft>>> = ({ signal }) => getTimeKeepingDraft(id,year,month, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id && year && month), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingDraftQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeepingDraft>>>
export type GetTimeKeepingDraftQueryError = ErrorResponse


export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeepingDraft>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeepingDraft>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingDraftQueryOptions(id,year,month,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeKeepingDraftSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingDraftQueryKey(id,year,month);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeepingDraft>>> = ({ signal }) => getTimeKeepingDraft(id,year,month, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingDraftSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeepingDraft>>>
export type GetTimeKeepingDraftSuspenseQueryError = ErrorResponse


export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingDraftSuspenseQueryOptions(id,year,month,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get TimeOff Status
 */
export const getTimeOffStatus = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeOffStatus>(
      {url: `/api/hr/employee/${id}/timeoffstatus`, method: 'GET', signal
    },
      );
    }
  

export const getGetTimeOffStatusQueryKey = (id: number,) => {
    return [`/api/hr/employee/${id}/timeoffstatus`] as const;
    }

    
export const getGetTimeOffStatusQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffStatusQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOffStatus>>> = ({ signal }) => getTimeOffStatus(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOffStatus>>>
export type GetTimeOffStatusQueryError = ErrorResponse


export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOffStatus>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOffStatus>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffStatusQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeOffStatusSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffStatusQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOffStatus>>> = ({ signal }) => getTimeOffStatus(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffStatusSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOffStatus>>>
export type GetTimeOffStatusSuspenseQueryError = ErrorResponse


export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffStatusSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get Employee Payment
 */
export const getEmployeePayment = (
    id: number,
    employeePaymentId: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeePayment>(
      {url: `/api/hr/employee/${id}/payment/${employeePaymentId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetEmployeePaymentQueryKey = (id: number,
    employeePaymentId: number,) => {
    return [`/api/hr/employee/${id}/payment/${employeePaymentId}`] as const;
    }

    
export const getGetEmployeePaymentQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeePaymentQueryKey(id,employeePaymentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeePayment>>> = ({ signal }) => getEmployeePayment(id,employeePaymentId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id && employeePaymentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeePaymentQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeePayment>>>
export type GetEmployeePaymentQueryError = unknown


export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeePayment>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeePayment>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeePaymentQueryOptions(id,employeePaymentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetEmployeePaymentSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeePaymentQueryKey(id,employeePaymentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeePayment>>> = ({ signal }) => getEmployeePayment(id,employeePaymentId, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeePaymentSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeePayment>>>
export type GetEmployeePaymentSuspenseQueryError = unknown


export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeePaymentSuspenseQueryOptions(id,employeePaymentId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete Employee Payment
 */
export const deleteEmployeePayment = (
    id: number,
    employeePaymentId: number,
 ) => {
      
      
      return customMutator<EmployeePayment>(
      {url: `/api/hr/employee/${id}/payment/${employeePaymentId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEmployeePaymentMutationOptions = <TData = Awaited<ReturnType<typeof deleteEmployeePayment>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;employeePaymentId: number}, TContext>, }
) => {
const mutationKey = ['deleteEmployeePayment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEmployeePayment>>, {id: number;employeePaymentId: number}> = (props) => {
          const {id,employeePaymentId} = props ?? {};

          return  deleteEmployeePayment(id,employeePaymentId,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;employeePaymentId: number}, TContext>}

    export type DeleteEmployeePaymentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEmployeePayment>>>
    
    export type DeleteEmployeePaymentMutationError = ResponseBase

    export const useDeleteEmployeePayment = <TData = Awaited<ReturnType<typeof deleteEmployeePayment>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;employeePaymentId: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;employeePaymentId: number},
        TContext
      > => {

      const mutationOptions = getDeleteEmployeePaymentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Employee Overtime
 */
export const getEmployeeOvertime = (
    id: number,
    overtimeId: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeeOvertime>(
      {url: `/api/hr/employee/${id}/overtime/${overtimeId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetEmployeeOvertimeQueryKey = (id: number,
    overtimeId: number,) => {
    return [`/api/hr/employee/${id}/overtime/${overtimeId}`] as const;
    }

    
export const getGetEmployeeOvertimeQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeOvertimeQueryKey(id,overtimeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeeOvertime>>> = ({ signal }) => getEmployeeOvertime(id,overtimeId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id && overtimeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeOvertimeQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeeOvertime>>>
export type GetEmployeeOvertimeQueryError = unknown


export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeeOvertime>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeeOvertime>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeOvertimeQueryOptions(id,overtimeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetEmployeeOvertimeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeOvertimeQueryKey(id,overtimeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeeOvertime>>> = ({ signal }) => getEmployeeOvertime(id,overtimeId, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeOvertimeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeeOvertime>>>
export type GetEmployeeOvertimeSuspenseQueryError = unknown


export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeOvertimeSuspenseQueryOptions(id,overtimeId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete Employee Overtime
 */
export const deleteEmployeeOvertime = (
    id: number,
    overtimeId: number,
 ) => {
      
      
      return customMutator<EmployeeOvertime>(
      {url: `/api/hr/employee/${id}/overtime/${overtimeId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEmployeeOvertimeMutationOptions = <TData = Awaited<ReturnType<typeof deleteEmployeeOvertime>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;overtimeId: number}, TContext>, }
) => {
const mutationKey = ['deleteEmployeeOvertime'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEmployeeOvertime>>, {id: number;overtimeId: number}> = (props) => {
          const {id,overtimeId} = props ?? {};

          return  deleteEmployeeOvertime(id,overtimeId,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;overtimeId: number}, TContext>}

    export type DeleteEmployeeOvertimeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEmployeeOvertime>>>
    
    export type DeleteEmployeeOvertimeMutationError = ResponseBase

    export const useDeleteEmployeeOvertime = <TData = Awaited<ReturnType<typeof deleteEmployeeOvertime>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;overtimeId: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;overtimeId: number},
        TContext
      > => {

      const mutationOptions = getDeleteEmployeeOvertimeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
