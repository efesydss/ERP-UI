/**
 * Generated by orval v7.4.1 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query'
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  AdditionalCost,
  AssignmentCard,
  AssignmentTransaction,
  Bank,
  BankAccount,
  BankBranch,
  Branch,
  CashAccount,
  CashAccountBalanceResult,
  CashAccountTransaction,
  CashAccountTransactionEntity,
  Company,
  CurrentAccount,
  CurrentAccountBankAccount,
  CurrentAccountTransaction,
  Department,
  Depot,
  Employee,
  EmployeeOvertime,
  EmployeeOvertimes,
  EmployeePayment,
  EmployeePayments,
  ErrorResponse,
  ExpenseCard,
  ExpenseInvoice,
  ExpenseInvoiceCalculationResult,
  FilteringRequest,
  FixtureCard,
  FixtureGroup,
  FixtureGroupTreeDataResponse,
  Invoice,
  InvoiceCalculationResult,
  LoginRequest,
  LoginResponse,
  Logout200,
  Machine,
  MaterialCard,
  MaterialGroup,
  MaterialGroupTreeDataResponse,
  PaymentMethod,
  ProductCard,
  ProductGroup,
  ProductGroupTreeDataResponse,
  Project,
  Proposal,
  PublicHoliday,
  PurchaseOrder,
  RefreshResponse,
  ResponseBase,
  Role,
  Section,
  ServiceCard,
  ServiceGroup,
  ServiceGroupTreeDataResponse,
  Shelf,
  TimeKeeping,
  TimeKeepingCalculationResult,
  TimeOff,
  TimeOffStatus,
  Unit
} from './model'



/**
 * Get Unit
 */
export const getUnit = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Unit>> => {
    
    
    return axios.default.get(
      `/api/storage/unit/${id}`,options
    );
  }


export const getGetUnitQueryKey = (id: number,) => {
    return [`/api/storage/unit/${id}`] as const;
    }

    
export const getGetUnitQueryOptions = <TData = Awaited<ReturnType<typeof getUnit>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUnitQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnit>>> = ({ signal }) => getUnit(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUnitQueryResult = NonNullable<Awaited<ReturnType<typeof getUnit>>>
export type GetUnitQueryError = AxiosError<ErrorResponse>


export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnit>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnit>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUnitQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUnitSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUnit>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUnitQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnit>>> = ({ signal }) => getUnit(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUnitSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUnit>>>
export type GetUnitSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUnitSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Unit
 */
export const updateUnit = (
    id: number,
    unit: Unit, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Unit>> => {
    
    
    return axios.default.put(
      `/api/storage/unit/${id}`,
      unit,options
    );
  }



export const getUpdateUnitMutationOptions = <TData = Awaited<ReturnType<typeof updateUnit>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Unit}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateUnit'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUnit>>, {id: number;data: Unit}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUnit(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Unit}, TContext>}

    export type UpdateUnitMutationResult = NonNullable<Awaited<ReturnType<typeof updateUnit>>>
    export type UpdateUnitMutationBody = Unit
    export type UpdateUnitMutationError = AxiosError<ErrorResponse>

    export const useUpdateUnit = <TData = Awaited<ReturnType<typeof updateUnit>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Unit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Unit},
        TContext
      > => {

      const mutationOptions = getUpdateUnitMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Unit
 */
export const deleteUnit = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Unit>> => {
    
    
    return axios.default.delete(
      `/api/storage/unit/${id}`,options
    );
  }



export const getDeleteUnitMutationOptions = <TData = Awaited<ReturnType<typeof deleteUnit>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteUnit'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUnit>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteUnit(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteUnitMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUnit>>>
    
    export type DeleteUnitMutationError = AxiosError<ResponseBase>

    export const useDeleteUnit = <TData = Awaited<ReturnType<typeof deleteUnit>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteUnitMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Shelf
 */
export const getShelf = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Shelf>> => {
    
    
    return axios.default.get(
      `/api/storage/shelf/${id}`,options
    );
  }


export const getGetShelfQueryKey = (id: number,) => {
    return [`/api/storage/shelf/${id}`] as const;
    }

    
export const getGetShelfQueryOptions = <TData = Awaited<ReturnType<typeof getShelf>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetShelfQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getShelf>>> = ({ signal }) => getShelf(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetShelfQueryResult = NonNullable<Awaited<ReturnType<typeof getShelf>>>
export type GetShelfQueryError = AxiosError<ErrorResponse>


export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShelf>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShelf>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetShelfQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetShelfSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getShelf>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetShelfQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getShelf>>> = ({ signal }) => getShelf(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetShelfSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getShelf>>>
export type GetShelfSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetShelfSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Shelf
 */
export const updateShelf = (
    id: number,
    shelf: Shelf, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Shelf>> => {
    
    
    return axios.default.put(
      `/api/storage/shelf/${id}`,
      shelf,options
    );
  }



export const getUpdateShelfMutationOptions = <TData = Awaited<ReturnType<typeof updateShelf>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Shelf}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateShelf'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateShelf>>, {id: number;data: Shelf}> = (props) => {
          const {id,data} = props ?? {};

          return  updateShelf(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Shelf}, TContext>}

    export type UpdateShelfMutationResult = NonNullable<Awaited<ReturnType<typeof updateShelf>>>
    export type UpdateShelfMutationBody = Shelf
    export type UpdateShelfMutationError = AxiosError<ErrorResponse>

    export const useUpdateShelf = <TData = Awaited<ReturnType<typeof updateShelf>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Shelf}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Shelf},
        TContext
      > => {

      const mutationOptions = getUpdateShelfMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Shelf
 */
export const deleteShelf = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Shelf>> => {
    
    
    return axios.default.delete(
      `/api/storage/shelf/${id}`,options
    );
  }



export const getDeleteShelfMutationOptions = <TData = Awaited<ReturnType<typeof deleteShelf>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteShelf'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteShelf>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteShelf(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteShelfMutationResult = NonNullable<Awaited<ReturnType<typeof deleteShelf>>>
    
    export type DeleteShelfMutationError = AxiosError<ResponseBase>

    export const useDeleteShelf = <TData = Awaited<ReturnType<typeof deleteShelf>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteShelfMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ServiceGroup
 */
export const getServiceGroup = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ServiceGroup>> => {
    
    
    return axios.default.get(
      `/api/storage/serviceGroup/${id}`,options
    );
  }


export const getGetServiceGroupQueryKey = (id: number,) => {
    return [`/api/storage/serviceGroup/${id}`] as const;
    }

    
export const getGetServiceGroupQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroup>>> = ({ signal }) => getServiceGroup(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroup>>>
export type GetServiceGroupQueryError = AxiosError<ErrorResponse>


export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroup>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroup>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroup>>> = ({ signal }) => getServiceGroup(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroup>>>
export type GetServiceGroupSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ServiceGroup
 */
export const updateServiceGroup = (
    id: number,
    serviceGroup: ServiceGroup, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ServiceGroup>> => {
    
    
    return axios.default.put(
      `/api/storage/serviceGroup/${id}`,
      serviceGroup,options
    );
  }



export const getUpdateServiceGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateServiceGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceGroup}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateServiceGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceGroup>>, {id: number;data: ServiceGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateServiceGroup(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ServiceGroup}, TContext>}

    export type UpdateServiceGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceGroup>>>
    export type UpdateServiceGroupMutationBody = ServiceGroup
    export type UpdateServiceGroupMutationError = AxiosError<ErrorResponse>

    export const useUpdateServiceGroup = <TData = Awaited<ReturnType<typeof updateServiceGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ServiceGroup},
        TContext
      > => {

      const mutationOptions = getUpdateServiceGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ServiceGroup
 */
export const deleteServiceGroup = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ServiceGroup>> => {
    
    
    return axios.default.delete(
      `/api/storage/serviceGroup/${id}`,options
    );
  }



export const getDeleteServiceGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteServiceGroup>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteServiceGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteServiceGroup(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteServiceGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceGroup>>>
    
    export type DeleteServiceGroupMutationError = AxiosError<ResponseBase>

    export const useDeleteServiceGroup = <TData = Awaited<ReturnType<typeof deleteServiceGroup>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteServiceGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ServiceCard
 */
export const getServiceCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.get(
      `/api/storage/serviceCard/${id}`,options
    );
  }


export const getGetServiceCardQueryKey = (id: number,) => {
    return [`/api/storage/serviceCard/${id}`] as const;
    }

    
export const getGetServiceCardQueryOptions = <TData = Awaited<ReturnType<typeof getServiceCard>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceCard>>> = ({ signal }) => getServiceCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceCardQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceCard>>>
export type GetServiceCardQueryError = AxiosError<unknown>


export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getServiceCard>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceCard>>> = ({ signal }) => getServiceCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceCard>>>
export type GetServiceCardSuspenseQueryError = AxiosError<unknown>


export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ServiceCard
 */
export const updateServiceCard = (
    id: number,
    serviceCard: ServiceCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ServiceCard>> => {
    
    
    return axios.default.put(
      `/api/storage/serviceCard/${id}`,
      serviceCard,options
    );
  }



export const getUpdateServiceCardMutationOptions = <TData = Awaited<ReturnType<typeof updateServiceCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateServiceCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceCard>>, {id: number;data: ServiceCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateServiceCard(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ServiceCard}, TContext>}

    export type UpdateServiceCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceCard>>>
    export type UpdateServiceCardMutationBody = ServiceCard
    export type UpdateServiceCardMutationError = AxiosError<ErrorResponse>

    export const useUpdateServiceCard = <TData = Awaited<ReturnType<typeof updateServiceCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ServiceCard},
        TContext
      > => {

      const mutationOptions = getUpdateServiceCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ServiceCard
 */
export const deleteServiceCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ServiceCard>> => {
    
    
    return axios.default.delete(
      `/api/storage/serviceCard/${id}`,options
    );
  }



export const getDeleteServiceCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteServiceCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteServiceCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteServiceCard(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteServiceCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceCard>>>
    
    export type DeleteServiceCardMutationError = AxiosError<ResponseBase>

    export const useDeleteServiceCard = <TData = Awaited<ReturnType<typeof deleteServiceCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteServiceCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ProductGroup
 */
export const getProductGroup = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProductGroup>> => {
    
    
    return axios.default.get(
      `/api/storage/productGroup/${id}`,options
    );
  }


export const getGetProductGroupQueryKey = (id: number,) => {
    return [`/api/storage/productGroup/${id}`] as const;
    }

    
export const getGetProductGroupQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroup>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroup>>> = ({ signal }) => getProductGroup(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroup>>>
export type GetProductGroupQueryError = AxiosError<ErrorResponse>


export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroup>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroup>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroup>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroup>>> = ({ signal }) => getProductGroup(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroup>>>
export type GetProductGroupSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ProductGroup
 */
export const updateProductGroup = (
    id: number,
    productGroup: ProductGroup, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProductGroup>> => {
    
    
    return axios.default.put(
      `/api/storage/productGroup/${id}`,
      productGroup,options
    );
  }



export const getUpdateProductGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateProductGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductGroup}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateProductGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProductGroup>>, {id: number;data: ProductGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProductGroup(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ProductGroup}, TContext>}

    export type UpdateProductGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateProductGroup>>>
    export type UpdateProductGroupMutationBody = ProductGroup
    export type UpdateProductGroupMutationError = AxiosError<ErrorResponse>

    export const useUpdateProductGroup = <TData = Awaited<ReturnType<typeof updateProductGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ProductGroup},
        TContext
      > => {

      const mutationOptions = getUpdateProductGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ProductGroup
 */
export const deleteProductGroup = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProductGroup>> => {
    
    
    return axios.default.delete(
      `/api/storage/productGroup/${id}`,options
    );
  }



export const getDeleteProductGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteProductGroup>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteProductGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProductGroup(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProductGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductGroup>>>
    
    export type DeleteProductGroupMutationError = AxiosError<ResponseBase>

    export const useDeleteProductGroup = <TData = Awaited<ReturnType<typeof deleteProductGroup>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProductGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ProductCard
 */
export const getProductCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProductCard>> => {
    
    
    return axios.default.get(
      `/api/storage/productCard/${id}`,options
    );
  }


export const getGetProductCardQueryKey = (id: number,) => {
    return [`/api/storage/productCard/${id}`] as const;
    }

    
export const getGetProductCardQueryOptions = <TData = Awaited<ReturnType<typeof getProductCard>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductCard>>> = ({ signal }) => getProductCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductCardQueryResult = NonNullable<Awaited<ReturnType<typeof getProductCard>>>
export type GetProductCardQueryError = AxiosError<unknown>


export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductCard>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductCard>>> = ({ signal }) => getProductCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductCard>>>
export type GetProductCardSuspenseQueryError = AxiosError<unknown>


export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ProductCard
 */
export const updateProductCard = (
    id: number,
    productCard: ProductCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProductCard>> => {
    
    
    return axios.default.put(
      `/api/storage/productCard/${id}`,
      productCard,options
    );
  }



export const getUpdateProductCardMutationOptions = <TData = Awaited<ReturnType<typeof updateProductCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateProductCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProductCard>>, {id: number;data: ProductCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProductCard(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ProductCard}, TContext>}

    export type UpdateProductCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateProductCard>>>
    export type UpdateProductCardMutationBody = ProductCard
    export type UpdateProductCardMutationError = AxiosError<ErrorResponse>

    export const useUpdateProductCard = <TData = Awaited<ReturnType<typeof updateProductCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ProductCard},
        TContext
      > => {

      const mutationOptions = getUpdateProductCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ProductCard
 */
export const deleteProductCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProductCard>> => {
    
    
    return axios.default.delete(
      `/api/storage/productCard/${id}`,options
    );
  }



export const getDeleteProductCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteProductCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteProductCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProductCard(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProductCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductCard>>>
    
    export type DeleteProductCardMutationError = AxiosError<ResponseBase>

    export const useDeleteProductCard = <TData = Awaited<ReturnType<typeof deleteProductCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProductCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get MaterialGroup
 */
export const getMaterialGroup = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MaterialGroup>> => {
    
    
    return axios.default.get(
      `/api/storage/materialGroup/${id}`,options
    );
  }


export const getGetMaterialGroupQueryKey = (id: number,) => {
    return [`/api/storage/materialGroup/${id}`] as const;
    }

    
export const getGetMaterialGroupQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroup>>> = ({ signal }) => getMaterialGroup(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroup>>>
export type GetMaterialGroupQueryError = AxiosError<ErrorResponse>


export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroup>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroup>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroup>>> = ({ signal }) => getMaterialGroup(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroup>>>
export type GetMaterialGroupSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update MaterialGroup
 */
export const updateMaterialGroup = (
    id: number,
    materialGroup: MaterialGroup, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MaterialGroup>> => {
    
    
    return axios.default.put(
      `/api/storage/materialGroup/${id}`,
      materialGroup,options
    );
  }



export const getUpdateMaterialGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateMaterialGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialGroup}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateMaterialGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMaterialGroup>>, {id: number;data: MaterialGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMaterialGroup(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: MaterialGroup}, TContext>}

    export type UpdateMaterialGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateMaterialGroup>>>
    export type UpdateMaterialGroupMutationBody = MaterialGroup
    export type UpdateMaterialGroupMutationError = AxiosError<ErrorResponse>

    export const useUpdateMaterialGroup = <TData = Awaited<ReturnType<typeof updateMaterialGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: MaterialGroup},
        TContext
      > => {

      const mutationOptions = getUpdateMaterialGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete MaterialGroup
 */
export const deleteMaterialGroup = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MaterialGroup>> => {
    
    
    return axios.default.delete(
      `/api/storage/materialGroup/${id}`,options
    );
  }



export const getDeleteMaterialGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteMaterialGroup>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteMaterialGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMaterialGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMaterialGroup(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteMaterialGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMaterialGroup>>>
    
    export type DeleteMaterialGroupMutationError = AxiosError<ResponseBase>

    export const useDeleteMaterialGroup = <TData = Awaited<ReturnType<typeof deleteMaterialGroup>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMaterialGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get MaterialCard
 */
export const getMaterialCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MaterialCard>> => {
    
    
    return axios.default.get(
      `/api/storage/materialCard/${id}`,options
    );
  }


export const getGetMaterialCardQueryKey = (id: number,) => {
    return [`/api/storage/materialCard/${id}`] as const;
    }

    
export const getGetMaterialCardQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialCard>>> = ({ signal }) => getMaterialCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialCardQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialCard>>>
export type GetMaterialCardQueryError = AxiosError<unknown>


export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialCard>>> = ({ signal }) => getMaterialCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialCard>>>
export type GetMaterialCardSuspenseQueryError = AxiosError<unknown>


export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update MaterialCard
 */
export const updateMaterialCard = (
    id: number,
    materialCard: MaterialCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MaterialCard>> => {
    
    
    return axios.default.put(
      `/api/storage/materialCard/${id}`,
      materialCard,options
    );
  }



export const getUpdateMaterialCardMutationOptions = <TData = Awaited<ReturnType<typeof updateMaterialCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateMaterialCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMaterialCard>>, {id: number;data: MaterialCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMaterialCard(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: MaterialCard}, TContext>}

    export type UpdateMaterialCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateMaterialCard>>>
    export type UpdateMaterialCardMutationBody = MaterialCard
    export type UpdateMaterialCardMutationError = AxiosError<ErrorResponse>

    export const useUpdateMaterialCard = <TData = Awaited<ReturnType<typeof updateMaterialCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: MaterialCard},
        TContext
      > => {

      const mutationOptions = getUpdateMaterialCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete MaterialCard
 */
export const deleteMaterialCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MaterialCard>> => {
    
    
    return axios.default.delete(
      `/api/storage/materialCard/${id}`,options
    );
  }



export const getDeleteMaterialCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteMaterialCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteMaterialCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMaterialCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMaterialCard(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteMaterialCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMaterialCard>>>
    
    export type DeleteMaterialCardMutationError = AxiosError<ResponseBase>

    export const useDeleteMaterialCard = <TData = Awaited<ReturnType<typeof deleteMaterialCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMaterialCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get FixtureGroup
 */
export const getFixtureGroup = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FixtureGroup>> => {
    
    
    return axios.default.get(
      `/api/storage/fixtureGroup/${id}`,options
    );
  }


export const getGetFixtureGroupQueryKey = (id: number,) => {
    return [`/api/storage/fixtureGroup/${id}`] as const;
    }

    
export const getGetFixtureGroupQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroup>>> = ({ signal }) => getFixtureGroup(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroup>>>
export type GetFixtureGroupQueryError = AxiosError<ErrorResponse>


export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroup>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroup>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFixtureGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroup>>> = ({ signal }) => getFixtureGroup(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroup>>>
export type GetFixtureGroupSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update FixtureGroup
 */
export const updateFixtureGroup = (
    id: number,
    fixtureGroup: FixtureGroup, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FixtureGroup>> => {
    
    
    return axios.default.put(
      `/api/storage/fixtureGroup/${id}`,
      fixtureGroup,options
    );
  }



export const getUpdateFixtureGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateFixtureGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureGroup}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateFixtureGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFixtureGroup>>, {id: number;data: FixtureGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateFixtureGroup(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: FixtureGroup}, TContext>}

    export type UpdateFixtureGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateFixtureGroup>>>
    export type UpdateFixtureGroupMutationBody = FixtureGroup
    export type UpdateFixtureGroupMutationError = AxiosError<ErrorResponse>

    export const useUpdateFixtureGroup = <TData = Awaited<ReturnType<typeof updateFixtureGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: FixtureGroup},
        TContext
      > => {

      const mutationOptions = getUpdateFixtureGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete FixtureGroup
 */
export const deleteFixtureGroup = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FixtureGroup>> => {
    
    
    return axios.default.delete(
      `/api/storage/fixtureGroup/${id}`,options
    );
  }



export const getDeleteFixtureGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteFixtureGroup>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteFixtureGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFixtureGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteFixtureGroup(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteFixtureGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFixtureGroup>>>
    
    export type DeleteFixtureGroupMutationError = AxiosError<ResponseBase>

    export const useDeleteFixtureGroup = <TData = Awaited<ReturnType<typeof deleteFixtureGroup>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteFixtureGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get FixtureCard
 */
export const getFixtureCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.get(
      `/api/storage/fixtureCard/${id}`,options
    );
  }


export const getGetFixtureCardQueryKey = (id: number,) => {
    return [`/api/storage/fixtureCard/${id}`] as const;
    }

    
export const getGetFixtureCardQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureCard>>> = ({ signal }) => getFixtureCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureCardQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureCard>>>
export type GetFixtureCardQueryError = AxiosError<unknown>


export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFixtureCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureCard>>> = ({ signal }) => getFixtureCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureCard>>>
export type GetFixtureCardSuspenseQueryError = AxiosError<unknown>


export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update FixtureCard
 */
export const updateFixtureCard = (
    id: number,
    fixtureCard: FixtureCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FixtureCard>> => {
    
    
    return axios.default.put(
      `/api/storage/fixtureCard/${id}`,
      fixtureCard,options
    );
  }



export const getUpdateFixtureCardMutationOptions = <TData = Awaited<ReturnType<typeof updateFixtureCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateFixtureCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFixtureCard>>, {id: number;data: FixtureCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateFixtureCard(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: FixtureCard}, TContext>}

    export type UpdateFixtureCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateFixtureCard>>>
    export type UpdateFixtureCardMutationBody = FixtureCard
    export type UpdateFixtureCardMutationError = AxiosError<ErrorResponse>

    export const useUpdateFixtureCard = <TData = Awaited<ReturnType<typeof updateFixtureCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: FixtureCard},
        TContext
      > => {

      const mutationOptions = getUpdateFixtureCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete FixtureCard
 */
export const deleteFixtureCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FixtureCard>> => {
    
    
    return axios.default.delete(
      `/api/storage/fixtureCard/${id}`,options
    );
  }



export const getDeleteFixtureCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteFixtureCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteFixtureCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFixtureCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteFixtureCard(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteFixtureCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFixtureCard>>>
    
    export type DeleteFixtureCardMutationError = AxiosError<ResponseBase>

    export const useDeleteFixtureCard = <TData = Awaited<ReturnType<typeof deleteFixtureCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteFixtureCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get AssignmentTransaction
 */
export const getAssignmentTransaction = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentTransaction>> => {
    
    
    return axios.default.get(
      `/api/storage/assignmentTransaction/${id}`,options
    );
  }


export const getGetAssignmentTransactionQueryKey = (id: number,) => {
    return [`/api/storage/assignmentTransaction/${id}`] as const;
    }

    
export const getGetAssignmentTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentTransaction>>> = ({ signal }) => getAssignmentTransaction(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentTransaction>>>
export type GetAssignmentTransactionQueryError = AxiosError<ErrorResponse>


export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentTransactionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssignmentTransactionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentTransaction>>> = ({ signal }) => getAssignmentTransaction(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentTransactionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentTransaction>>>
export type GetAssignmentTransactionSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentTransactionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update AssignmentTransaction
 */
export const updateAssignmentTransaction = (
    id: number,
    assignmentTransaction: AssignmentTransaction, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentTransaction>> => {
    
    
    return axios.default.put(
      `/api/storage/assignmentTransaction/${id}`,
      assignmentTransaction,options
    );
  }



export const getUpdateAssignmentTransactionMutationOptions = <TData = Awaited<ReturnType<typeof updateAssignmentTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentTransaction}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateAssignmentTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssignmentTransaction>>, {id: number;data: AssignmentTransaction}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAssignmentTransaction(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: AssignmentTransaction}, TContext>}

    export type UpdateAssignmentTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssignmentTransaction>>>
    export type UpdateAssignmentTransactionMutationBody = AssignmentTransaction
    export type UpdateAssignmentTransactionMutationError = AxiosError<ErrorResponse>

    export const useUpdateAssignmentTransaction = <TData = Awaited<ReturnType<typeof updateAssignmentTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentTransaction}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: AssignmentTransaction},
        TContext
      > => {

      const mutationOptions = getUpdateAssignmentTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete AssignmentTransaction
 */
export const deleteAssignmentTransaction = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentTransaction>> => {
    
    
    return axios.default.delete(
      `/api/storage/assignmentTransaction/${id}`,options
    );
  }



export const getDeleteAssignmentTransactionMutationOptions = <TData = Awaited<ReturnType<typeof deleteAssignmentTransaction>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteAssignmentTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssignmentTransaction>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAssignmentTransaction(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteAssignmentTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssignmentTransaction>>>
    
    export type DeleteAssignmentTransactionMutationError = AxiosError<ResponseBase>

    export const useDeleteAssignmentTransaction = <TData = Awaited<ReturnType<typeof deleteAssignmentTransaction>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAssignmentTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get AssignmentCard
 */
export const getAssignmentCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentCard>> => {
    
    
    return axios.default.get(
      `/api/storage/assignmentCard/${id}`,options
    );
  }


export const getGetAssignmentCardQueryKey = (id: number,) => {
    return [`/api/storage/assignmentCard/${id}`] as const;
    }

    
export const getGetAssignmentCardQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentCard>>> = ({ signal }) => getAssignmentCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentCardQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentCard>>>
export type GetAssignmentCardQueryError = AxiosError<ErrorResponse>


export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssignmentCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentCard>>> = ({ signal }) => getAssignmentCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentCard>>>
export type GetAssignmentCardSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update AssignmentCard
 */
export const updateAssignmentCard = (
    id: number,
    assignmentCard: AssignmentCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentCard>> => {
    
    
    return axios.default.put(
      `/api/storage/assignmentCard/${id}`,
      assignmentCard,options
    );
  }



export const getUpdateAssignmentCardMutationOptions = <TData = Awaited<ReturnType<typeof updateAssignmentCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateAssignmentCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssignmentCard>>, {id: number;data: AssignmentCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAssignmentCard(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: AssignmentCard}, TContext>}

    export type UpdateAssignmentCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssignmentCard>>>
    export type UpdateAssignmentCardMutationBody = AssignmentCard
    export type UpdateAssignmentCardMutationError = AxiosError<ErrorResponse>

    export const useUpdateAssignmentCard = <TData = Awaited<ReturnType<typeof updateAssignmentCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: AssignmentCard},
        TContext
      > => {

      const mutationOptions = getUpdateAssignmentCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete AssignmentCard
 */
export const deleteAssignmentCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentCard>> => {
    
    
    return axios.default.delete(
      `/api/storage/assignmentCard/${id}`,options
    );
  }



export const getDeleteAssignmentCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteAssignmentCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteAssignmentCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssignmentCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAssignmentCard(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteAssignmentCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssignmentCard>>>
    
    export type DeleteAssignmentCardMutationError = AxiosError<ResponseBase>

    export const useDeleteAssignmentCard = <TData = Awaited<ReturnType<typeof deleteAssignmentCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAssignmentCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Proposal
 */
export const getProposal = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Proposal>> => {
    
    
    return axios.default.get(
      `/api/sales/proposal/${id}`,options
    );
  }


export const getGetProposalQueryKey = (id: number,) => {
    return [`/api/sales/proposal/${id}`] as const;
    }

    
export const getGetProposalQueryOptions = <TData = Awaited<ReturnType<typeof getProposal>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProposalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProposal>>> = ({ signal }) => getProposal(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProposalQueryResult = NonNullable<Awaited<ReturnType<typeof getProposal>>>
export type GetProposalQueryError = AxiosError<ErrorResponse>


export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProposal>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProposal>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProposalQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProposalSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProposal>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProposalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProposal>>> = ({ signal }) => getProposal(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProposalSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProposal>>>
export type GetProposalSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProposalSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Proposal
 */
export const updateProposal = (
    id: number,
    proposal: Proposal, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Proposal>> => {
    
    
    return axios.default.put(
      `/api/sales/proposal/${id}`,
      proposal,options
    );
  }



export const getUpdateProposalMutationOptions = <TData = Awaited<ReturnType<typeof updateProposal>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Proposal}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateProposal'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProposal>>, {id: number;data: Proposal}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProposal(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Proposal}, TContext>}

    export type UpdateProposalMutationResult = NonNullable<Awaited<ReturnType<typeof updateProposal>>>
    export type UpdateProposalMutationBody = Proposal
    export type UpdateProposalMutationError = AxiosError<ErrorResponse>

    export const useUpdateProposal = <TData = Awaited<ReturnType<typeof updateProposal>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Proposal}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Proposal},
        TContext
      > => {

      const mutationOptions = getUpdateProposalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Proposal
 */
export const deleteProposal = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Proposal>> => {
    
    
    return axios.default.delete(
      `/api/sales/proposal/${id}`,options
    );
  }



export const getDeleteProposalMutationOptions = <TData = Awaited<ReturnType<typeof deleteProposal>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteProposal'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProposal>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProposal(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProposalMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProposal>>>
    
    export type DeleteProposalMutationError = AxiosError<ResponseBase>

    export const useDeleteProposal = <TData = Awaited<ReturnType<typeof deleteProposal>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProposalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Purchase Order
 */
export const getPurchaseOrder = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PurchaseOrder>> => {
    
    
    return axios.default.get(
      `/api/purchasing/purchaseOrder/${id}`,options
    );
  }


export const getGetPurchaseOrderQueryKey = (id: number,) => {
    return [`/api/purchasing/purchaseOrder/${id}`] as const;
    }

    
export const getGetPurchaseOrderQueryOptions = <TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPurchaseOrderQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPurchaseOrder>>> = ({ signal }) => getPurchaseOrder(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPurchaseOrderQueryResult = NonNullable<Awaited<ReturnType<typeof getPurchaseOrder>>>
export type GetPurchaseOrderQueryError = AxiosError<ErrorResponse>


export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseOrder>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseOrder>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPurchaseOrderQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPurchaseOrderSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPurchaseOrderQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPurchaseOrder>>> = ({ signal }) => getPurchaseOrder(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPurchaseOrderSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPurchaseOrder>>>
export type GetPurchaseOrderSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPurchaseOrderSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update PurchaseOrder
 */
export const updatePurchaseOrder = (
    id: number,
    purchaseOrder: PurchaseOrder, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PurchaseOrder>> => {
    
    
    return axios.default.put(
      `/api/purchasing/purchaseOrder/${id}`,
      purchaseOrder,options
    );
  }



export const getUpdatePurchaseOrderMutationOptions = <TData = Awaited<ReturnType<typeof updatePurchaseOrder>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PurchaseOrder}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updatePurchaseOrder'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePurchaseOrder>>, {id: number;data: PurchaseOrder}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePurchaseOrder(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: PurchaseOrder}, TContext>}

    export type UpdatePurchaseOrderMutationResult = NonNullable<Awaited<ReturnType<typeof updatePurchaseOrder>>>
    export type UpdatePurchaseOrderMutationBody = PurchaseOrder
    export type UpdatePurchaseOrderMutationError = AxiosError<ErrorResponse>

    export const useUpdatePurchaseOrder = <TData = Awaited<ReturnType<typeof updatePurchaseOrder>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PurchaseOrder}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: PurchaseOrder},
        TContext
      > => {

      const mutationOptions = getUpdatePurchaseOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete PurchaseOrder
 */
export const deletePurchaseOrder = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PurchaseOrder>> => {
    
    
    return axios.default.delete(
      `/api/purchasing/purchaseOrder/${id}`,options
    );
  }



export const getDeletePurchaseOrderMutationOptions = <TData = Awaited<ReturnType<typeof deletePurchaseOrder>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deletePurchaseOrder'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePurchaseOrder>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deletePurchaseOrder(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeletePurchaseOrderMutationResult = NonNullable<Awaited<ReturnType<typeof deletePurchaseOrder>>>
    
    export type DeletePurchaseOrderMutationError = AxiosError<ResponseBase>

    export const useDeletePurchaseOrder = <TData = Awaited<ReturnType<typeof deletePurchaseOrder>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeletePurchaseOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Invoice
 */
export const getInvoice = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Invoice>> => {
    
    
    return axios.default.get(
      `/api/purchasing/invoice/${id}`,options
    );
  }


export const getGetInvoiceQueryKey = (id: number,) => {
    return [`/api/purchasing/invoice/${id}`] as const;
    }

    
export const getGetInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof getInvoice>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInvoice>>> = ({ signal }) => getInvoice(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof getInvoice>>>
export type GetInvoiceQueryError = AxiosError<ErrorResponse>


export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetInvoiceQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetInvoiceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getInvoice>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInvoice>>> = ({ signal }) => getInvoice(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInvoiceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getInvoice>>>
export type GetInvoiceSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetInvoiceSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Invoice
 */
export const updateInvoice = (
    id: number,
    invoice: Invoice, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Invoice>> => {
    
    
    return axios.default.put(
      `/api/purchasing/invoice/${id}`,
      invoice,options
    );
  }



export const getUpdateInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof updateInvoice>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Invoice}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateInvoice>>, {id: number;data: Invoice}> = (props) => {
          const {id,data} = props ?? {};

          return  updateInvoice(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Invoice}, TContext>}

    export type UpdateInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof updateInvoice>>>
    export type UpdateInvoiceMutationBody = Invoice
    export type UpdateInvoiceMutationError = AxiosError<ErrorResponse>

    export const useUpdateInvoice = <TData = Awaited<ReturnType<typeof updateInvoice>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Invoice}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Invoice},
        TContext
      > => {

      const mutationOptions = getUpdateInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Invoice by document reference
 */
export const deleteInvoice = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Invoice>> => {
    
    
    return axios.default.delete(
      `/api/purchasing/invoice/${id}`,options
    );
  }



export const getDeleteInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof deleteInvoice>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteInvoice>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteInvoice(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteInvoice>>>
    
    export type DeleteInvoiceMutationError = AxiosError<unknown>

    export const useDeleteInvoice = <TData = Awaited<ReturnType<typeof deleteInvoice>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Current Account Transaction
 */
export const getCurrentAccountTransaction = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccountTransaction>> => {
    
    
    return axios.default.get(
      `/api/purchasing/currentAccountTransaction/${id}`,options
    );
  }


export const getGetCurrentAccountTransactionQueryKey = (id: number,) => {
    return [`/api/purchasing/currentAccountTransaction/${id}`] as const;
    }

    
export const getGetCurrentAccountTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountTransaction>>> = ({ signal }) => getCurrentAccountTransaction(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountTransaction>>>
export type GetCurrentAccountTransactionQueryError = AxiosError<ErrorResponse>


export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountTransactionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentAccountTransactionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountTransaction>>> = ({ signal }) => getCurrentAccountTransaction(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountTransactionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountTransaction>>>
export type GetCurrentAccountTransactionSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountTransactionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Current Account Transaction
 */
export const updateCurrentAccountTransaction = (
    id: number,
    currentAccountTransaction: CurrentAccountTransaction, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccountTransaction>> => {
    
    
    return axios.default.put(
      `/api/purchasing/currentAccountTransaction/${id}`,
      currentAccountTransaction,options
    );
  }



export const getUpdateCurrentAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof updateCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountTransaction}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateCurrentAccountTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentAccountTransaction>>, {id: number;data: CurrentAccountTransaction}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurrentAccountTransaction(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CurrentAccountTransaction}, TContext>}

    export type UpdateCurrentAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentAccountTransaction>>>
    export type UpdateCurrentAccountTransactionMutationBody = CurrentAccountTransaction
    export type UpdateCurrentAccountTransactionMutationError = AxiosError<ErrorResponse>

    export const useUpdateCurrentAccountTransaction = <TData = Awaited<ReturnType<typeof updateCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountTransaction}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CurrentAccountTransaction},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Current Account Transaction by document reference
 */
export const deleteCurrentAccountTransaction = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccountTransaction>> => {
    
    
    return axios.default.delete(
      `/api/purchasing/currentAccountTransaction/${id}`,options
    );
  }



export const getDeleteCurrentAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteCurrentAccountTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurrentAccountTransaction(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCurrentAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>>
    
    export type DeleteCurrentAccountTransactionMutationError = AxiosError<unknown>

    export const useDeleteCurrentAccountTransaction = <TData = Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurrentAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get CurrentAccountBankAccount
 */
export const getCurrentAccountBankAccount = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccountBankAccount>> => {
    
    
    return axios.default.get(
      `/api/purchasing/currentAccountBankAccount/${id}`,options
    );
  }


export const getGetCurrentAccountBankAccountQueryKey = (id: number,) => {
    return [`/api/purchasing/currentAccountBankAccount/${id}`] as const;
    }

    
export const getGetCurrentAccountBankAccountQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>> = ({ signal }) => getCurrentAccountBankAccount(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountBankAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>>
export type GetCurrentAccountBankAccountQueryError = AxiosError<ErrorResponse>


export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountBankAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentAccountBankAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>> = ({ signal }) => getCurrentAccountBankAccount(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountBankAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>>
export type GetCurrentAccountBankAccountSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountBankAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update CurrentAccountBankAccount
 */
export const updateCurrentAccountBankAccount = (
    id: number,
    currentAccountBankAccount: CurrentAccountBankAccount, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccountBankAccount>> => {
    
    
    return axios.default.put(
      `/api/purchasing/currentAccountBankAccount/${id}`,
      currentAccountBankAccount,options
    );
  }



export const getUpdateCurrentAccountBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountBankAccount}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateCurrentAccountBankAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>, {id: number;data: CurrentAccountBankAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurrentAccountBankAccount(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CurrentAccountBankAccount}, TContext>}

    export type UpdateCurrentAccountBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>>
    export type UpdateCurrentAccountBankAccountMutationBody = CurrentAccountBankAccount
    export type UpdateCurrentAccountBankAccountMutationError = AxiosError<ErrorResponse>

    export const useUpdateCurrentAccountBankAccount = <TData = Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountBankAccount}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CurrentAccountBankAccount},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentAccountBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete CurrentAccountBankAccount
 */
export const deleteCurrentAccountBankAccount = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccountBankAccount>> => {
    
    
    return axios.default.delete(
      `/api/purchasing/currentAccountBankAccount/${id}`,options
    );
  }



export const getDeleteCurrentAccountBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteCurrentAccountBankAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurrentAccountBankAccount(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCurrentAccountBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>>
    
    export type DeleteCurrentAccountBankAccountMutationError = AxiosError<ResponseBase>

    export const useDeleteCurrentAccountBankAccount = <TData = Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurrentAccountBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Current Account
 */
export const getCurrentAccount = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccount>> => {
    
    
    return axios.default.get(
      `/api/purchasing/currentAccount/${id}`,options
    );
  }


export const getGetCurrentAccountQueryKey = (id: number,) => {
    return [`/api/purchasing/currentAccount/${id}`] as const;
    }

    
export const getGetCurrentAccountQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccount>>> = ({ signal }) => getCurrentAccount(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccount>>>
export type GetCurrentAccountQueryError = AxiosError<ErrorResponse>


export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccount>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccount>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccount>>> = ({ signal }) => getCurrentAccount(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccount>>>
export type GetCurrentAccountSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Current Account
 */
export const updateCurrentAccount = (
    id: number,
    currentAccount: CurrentAccount, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccount>> => {
    
    
    return axios.default.put(
      `/api/purchasing/currentAccount/${id}`,
      currentAccount,options
    );
  }



export const getUpdateCurrentAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateCurrentAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccount}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateCurrentAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentAccount>>, {id: number;data: CurrentAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurrentAccount(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CurrentAccount}, TContext>}

    export type UpdateCurrentAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentAccount>>>
    export type UpdateCurrentAccountMutationBody = CurrentAccount
    export type UpdateCurrentAccountMutationError = AxiosError<ErrorResponse>

    export const useUpdateCurrentAccount = <TData = Awaited<ReturnType<typeof updateCurrentAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccount}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CurrentAccount},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Current Account by document reference
 */
export const deleteCurrentAccount = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccount>> => {
    
    
    return axios.default.delete(
      `/api/purchasing/currentAccount/${id}`,options
    );
  }



export const getDeleteCurrentAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteCurrentAccount>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteCurrentAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrentAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurrentAccount(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCurrentAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrentAccount>>>
    
    export type DeleteCurrentAccountMutationError = AxiosError<unknown>

    export const useDeleteCurrentAccount = <TData = Awaited<ReturnType<typeof deleteCurrentAccount>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurrentAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get AdditionalCost
 */
export const getAdditionalCost = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdditionalCost>> => {
    
    
    return axios.default.get(
      `/api/purchasing/additionalCost/${id}`,options
    );
  }


export const getGetAdditionalCostQueryKey = (id: number,) => {
    return [`/api/purchasing/additionalCost/${id}`] as const;
    }

    
export const getGetAdditionalCostQueryOptions = <TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdditionalCostQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdditionalCost>>> = ({ signal }) => getAdditionalCost(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdditionalCostQueryResult = NonNullable<Awaited<ReturnType<typeof getAdditionalCost>>>
export type GetAdditionalCostQueryError = AxiosError<ErrorResponse>


export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdditionalCost>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdditionalCost>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdditionalCostQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdditionalCostSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdditionalCostQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdditionalCost>>> = ({ signal }) => getAdditionalCost(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdditionalCostSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdditionalCost>>>
export type GetAdditionalCostSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdditionalCostSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update AdditionalCost
 */
export const updateAdditionalCost = (
    id: number,
    additionalCost: AdditionalCost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdditionalCost>> => {
    
    
    return axios.default.put(
      `/api/purchasing/additionalCost/${id}`,
      additionalCost,options
    );
  }



export const getUpdateAdditionalCostMutationOptions = <TData = Awaited<ReturnType<typeof updateAdditionalCost>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AdditionalCost}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateAdditionalCost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdditionalCost>>, {id: number;data: AdditionalCost}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAdditionalCost(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: AdditionalCost}, TContext>}

    export type UpdateAdditionalCostMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdditionalCost>>>
    export type UpdateAdditionalCostMutationBody = AdditionalCost
    export type UpdateAdditionalCostMutationError = AxiosError<ErrorResponse>

    export const useUpdateAdditionalCost = <TData = Awaited<ReturnType<typeof updateAdditionalCost>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AdditionalCost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: AdditionalCost},
        TContext
      > => {

      const mutationOptions = getUpdateAdditionalCostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete AdditionalCost
 */
export const deleteAdditionalCost = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdditionalCost>> => {
    
    
    return axios.default.delete(
      `/api/purchasing/additionalCost/${id}`,options
    );
  }



export const getDeleteAdditionalCostMutationOptions = <TData = Awaited<ReturnType<typeof deleteAdditionalCost>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteAdditionalCost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAdditionalCost>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAdditionalCost(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteAdditionalCostMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAdditionalCost>>>
    
    export type DeleteAdditionalCostMutationError = AxiosError<ResponseBase>

    export const useDeleteAdditionalCost = <TData = Awaited<ReturnType<typeof deleteAdditionalCost>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAdditionalCostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Project
 */
export const getProject = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Project>> => {
    
    
    return axios.default.get(
      `/api/production/project/${id}`,options
    );
  }


export const getGetProjectQueryKey = (id: number,) => {
    return [`/api/production/project/${id}`] as const;
    }

    
export const getGetProjectQueryOptions = <TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({ signal }) => getProject(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProjectQueryResult = NonNullable<Awaited<ReturnType<typeof getProject>>>
export type GetProjectQueryError = AxiosError<ErrorResponse>


export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProjectQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProjectSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({ signal }) => getProject(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProjectSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProject>>>
export type GetProjectSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProjectSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Project
 */
export const updateProject = (
    id: number,
    project: Project, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Project>> => {
    
    
    return axios.default.put(
      `/api/production/project/${id}`,
      project,options
    );
  }



export const getUpdateProjectMutationOptions = <TData = Awaited<ReturnType<typeof updateProject>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Project}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateProject'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProject>>, {id: number;data: Project}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProject(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Project}, TContext>}

    export type UpdateProjectMutationResult = NonNullable<Awaited<ReturnType<typeof updateProject>>>
    export type UpdateProjectMutationBody = Project
    export type UpdateProjectMutationError = AxiosError<ErrorResponse>

    export const useUpdateProject = <TData = Awaited<ReturnType<typeof updateProject>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Project}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Project},
        TContext
      > => {

      const mutationOptions = getUpdateProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Project
 */
export const deleteProject = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Project>> => {
    
    
    return axios.default.delete(
      `/api/production/project/${id}`,options
    );
  }



export const getDeleteProjectMutationOptions = <TData = Awaited<ReturnType<typeof deleteProject>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteProject'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProject>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProject(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProject>>>
    
    export type DeleteProjectMutationError = AxiosError<ResponseBase>

    export const useDeleteProject = <TData = Awaited<ReturnType<typeof deleteProject>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Time Keeping
 */
export const getTimeKeeping = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeKeeping>> => {
    
    
    return axios.default.get(
      `/api/hr/timekeeping/${id}`,options
    );
  }


export const getGetTimeKeepingQueryKey = (id: number,) => {
    return [`/api/hr/timekeeping/${id}`] as const;
    }

    
export const getGetTimeKeepingQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeeping>>> = ({ signal }) => getTimeKeeping(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeeping>>>
export type GetTimeKeepingQueryError = AxiosError<ErrorResponse>


export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeeping>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeeping>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeKeepingSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeeping>>> = ({ signal }) => getTimeKeeping(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeeping>>>
export type GetTimeKeepingSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Time Keeping
 */
export const updateTimeKeeping = (
    id: number,
    timeKeeping: TimeKeeping, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeKeeping>> => {
    
    
    return axios.default.put(
      `/api/hr/timekeeping/${id}`,
      timeKeeping,options
    );
  }



export const getUpdateTimeKeepingMutationOptions = <TData = Awaited<ReturnType<typeof updateTimeKeeping>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeKeeping}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateTimeKeeping'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTimeKeeping>>, {id: number;data: TimeKeeping}> = (props) => {
          const {id,data} = props ?? {};

          return  updateTimeKeeping(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: TimeKeeping}, TContext>}

    export type UpdateTimeKeepingMutationResult = NonNullable<Awaited<ReturnType<typeof updateTimeKeeping>>>
    export type UpdateTimeKeepingMutationBody = TimeKeeping
    export type UpdateTimeKeepingMutationError = AxiosError<ErrorResponse>

    export const useUpdateTimeKeeping = <TData = Awaited<ReturnType<typeof updateTimeKeeping>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeKeeping}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: TimeKeeping},
        TContext
      > => {

      const mutationOptions = getUpdateTimeKeepingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Time Keeping by document reference
 */
export const deleteTimeKeeping = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeKeeping>> => {
    
    
    return axios.default.delete(
      `/api/hr/timekeeping/${id}`,options
    );
  }



export const getDeleteTimeKeepingMutationOptions = <TData = Awaited<ReturnType<typeof deleteTimeKeeping>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteTimeKeeping'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTimeKeeping>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteTimeKeeping(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteTimeKeepingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTimeKeeping>>>
    
    export type DeleteTimeKeepingMutationError = AxiosError<ResponseBase>

    export const useDeleteTimeKeeping = <TData = Awaited<ReturnType<typeof deleteTimeKeeping>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteTimeKeepingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Employee
 */
export const getEmployee = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Employee>> => {
    
    
    return axios.default.get(
      `/api/hr/employee/${id}`,options
    );
  }


export const getGetEmployeeQueryKey = (id: number,) => {
    return [`/api/hr/employee/${id}`] as const;
    }

    
export const getGetEmployeeQueryOptions = <TData = Awaited<ReturnType<typeof getEmployee>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployee>>> = ({ signal }) => getEmployee(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployee>>>
export type GetEmployeeQueryError = AxiosError<ErrorResponse>


export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployee>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployee>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetEmployeeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEmployee>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployee>>> = ({ signal }) => getEmployee(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployee>>>
export type GetEmployeeSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Employee
 */
export const updateEmployee = (
    id: number,
    employee: Employee, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Employee>> => {
    
    
    return axios.default.put(
      `/api/hr/employee/${id}`,
      employee,options
    );
  }



export const getUpdateEmployeeMutationOptions = <TData = Awaited<ReturnType<typeof updateEmployee>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Employee}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateEmployee'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEmployee>>, {id: number;data: Employee}> = (props) => {
          const {id,data} = props ?? {};

          return  updateEmployee(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Employee}, TContext>}

    export type UpdateEmployeeMutationResult = NonNullable<Awaited<ReturnType<typeof updateEmployee>>>
    export type UpdateEmployeeMutationBody = Employee
    export type UpdateEmployeeMutationError = AxiosError<ErrorResponse>

    export const useUpdateEmployee = <TData = Awaited<ReturnType<typeof updateEmployee>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Employee}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Employee},
        TContext
      > => {

      const mutationOptions = getUpdateEmployeeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Employee by document reference
 */
export const deleteEmployee = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Employee>> => {
    
    
    return axios.default.delete(
      `/api/hr/employee/${id}`,options
    );
  }



export const getDeleteEmployeeMutationOptions = <TData = Awaited<ReturnType<typeof deleteEmployee>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteEmployee'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEmployee>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteEmployee(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteEmployeeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEmployee>>>
    
    export type DeleteEmployeeMutationError = AxiosError<unknown>

    export const useDeleteEmployee = <TData = Awaited<ReturnType<typeof deleteEmployee>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteEmployeeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get TimeOff
 */
export const getTimeOff = (
    id: number,
    timeOffId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeOff>> => {
    
    
    return axios.default.get(
      `/api/hr/employee/${id}/timeoff/${timeOffId}`,options
    );
  }


export const getGetTimeOffQueryKey = (id: number,
    timeOffId: number,) => {
    return [`/api/hr/employee/${id}/timeoff/${timeOffId}`] as const;
    }

    
export const getGetTimeOffQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOff>>, TError = AxiosError<ResponseBase>>(id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffQueryKey(id,timeOffId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOff>>> = ({ signal }) => getTimeOff(id,timeOffId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && timeOffId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOff>>>
export type GetTimeOffQueryError = AxiosError<ResponseBase>


export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = AxiosError<ResponseBase>>(
 id: number,
    timeOffId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOff>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = AxiosError<ResponseBase>>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOff>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = AxiosError<ResponseBase>>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = AxiosError<ResponseBase>>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffQueryOptions(id,timeOffId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeOffSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOff>>, TError = AxiosError<ResponseBase>>(id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffQueryKey(id,timeOffId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOff>>> = ({ signal }) => getTimeOff(id,timeOffId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOff>>>
export type GetTimeOffSuspenseQueryError = AxiosError<ResponseBase>


export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = AxiosError<ResponseBase>>(
 id: number,
    timeOffId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = AxiosError<ResponseBase>>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = AxiosError<ResponseBase>>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = AxiosError<ResponseBase>>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffSuspenseQueryOptions(id,timeOffId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Timeoff
 */
export const updateTimeoff = (
    id: number,
    timeOffId: number,
    timeOff: TimeOff, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeOff>> => {
    
    
    return axios.default.put(
      `/api/hr/employee/${id}/timeoff/${timeOffId}`,
      timeOff,options
    );
  }



export const getUpdateTimeoffMutationOptions = <TData = Awaited<ReturnType<typeof updateTimeoff>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number;data: TimeOff}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateTimeoff'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTimeoff>>, {id: number;timeOffId: number;data: TimeOff}> = (props) => {
          const {id,timeOffId,data} = props ?? {};

          return  updateTimeoff(id,timeOffId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;timeOffId: number;data: TimeOff}, TContext>}

    export type UpdateTimeoffMutationResult = NonNullable<Awaited<ReturnType<typeof updateTimeoff>>>
    export type UpdateTimeoffMutationBody = TimeOff
    export type UpdateTimeoffMutationError = AxiosError<ErrorResponse>

    export const useUpdateTimeoff = <TData = Awaited<ReturnType<typeof updateTimeoff>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number;data: TimeOff}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;timeOffId: number;data: TimeOff},
        TContext
      > => {

      const mutationOptions = getUpdateTimeoffMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete TimeOff
 */
export const deleteTimeOff = (
    id: number,
    timeOffId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeOff>> => {
    
    
    return axios.default.delete(
      `/api/hr/employee/${id}/timeoff/${timeOffId}`,options
    );
  }



export const getDeleteTimeOffMutationOptions = <TData = Awaited<ReturnType<typeof deleteTimeOff>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteTimeOff'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTimeOff>>, {id: number;timeOffId: number}> = (props) => {
          const {id,timeOffId} = props ?? {};

          return  deleteTimeOff(id,timeOffId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;timeOffId: number}, TContext>}

    export type DeleteTimeOffMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTimeOff>>>
    
    export type DeleteTimeOffMutationError = AxiosError<ResponseBase>

    export const useDeleteTimeOff = <TData = Awaited<ReturnType<typeof deleteTimeOff>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;timeOffId: number},
        TContext
      > => {

      const mutationOptions = getDeleteTimeOffMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update Employee Payment
 */
export const updateEmployeePayments = (
    id: number,
    employeePayment: EmployeePayment[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EmployeePayment[]>> => {
    
    
    return axios.default.put(
      `/api/hr/employee/${id}/payment`,
      employeePayment,options
    );
  }



export const getUpdateEmployeePaymentsMutationOptions = <TData = Awaited<ReturnType<typeof updateEmployeePayments>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateEmployeePayments'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEmployeePayments>>, {id: number;data: EmployeePayment[]}> = (props) => {
          const {id,data} = props ?? {};

          return  updateEmployeePayments(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>}

    export type UpdateEmployeePaymentsMutationResult = NonNullable<Awaited<ReturnType<typeof updateEmployeePayments>>>
    export type UpdateEmployeePaymentsMutationBody = EmployeePayment[]
    export type UpdateEmployeePaymentsMutationError = AxiosError<ErrorResponse>

    export const useUpdateEmployeePayments = <TData = Awaited<ReturnType<typeof updateEmployeePayments>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeePayment[]},
        TContext
      > => {

      const mutationOptions = getUpdateEmployeePaymentsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Employee Payments
 */
export const addEmployeePayment = (
    id: number,
    employeePayment: EmployeePayment[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EmployeePayment[]>> => {
    
    
    return axios.default.post(
      `/api/hr/employee/${id}/payment`,
      employeePayment,options
    );
  }



export const getAddEmployeePaymentMutationOptions = <TData = Awaited<ReturnType<typeof addEmployeePayment>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addEmployeePayment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addEmployeePayment>>, {id: number;data: EmployeePayment[]}> = (props) => {
          const {id,data} = props ?? {};

          return  addEmployeePayment(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>}

    export type AddEmployeePaymentMutationResult = NonNullable<Awaited<ReturnType<typeof addEmployeePayment>>>
    export type AddEmployeePaymentMutationBody = EmployeePayment[]
    export type AddEmployeePaymentMutationError = AxiosError<ErrorResponse>

    export const useAddEmployeePayment = <TData = Awaited<ReturnType<typeof addEmployeePayment>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeePayment[]},
        TContext
      > => {

      const mutationOptions = getAddEmployeePaymentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update Employee Overtime
 */
export const updateEmployeeOvertimes = (
    id: number,
    employeeOvertime: EmployeeOvertime[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EmployeeOvertime[]>> => {
    
    
    return axios.default.put(
      `/api/hr/employee/${id}/overtime`,
      employeeOvertime,options
    );
  }



export const getUpdateEmployeeOvertimesMutationOptions = <TData = Awaited<ReturnType<typeof updateEmployeeOvertimes>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateEmployeeOvertimes'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEmployeeOvertimes>>, {id: number;data: EmployeeOvertime[]}> = (props) => {
          const {id,data} = props ?? {};

          return  updateEmployeeOvertimes(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>}

    export type UpdateEmployeeOvertimesMutationResult = NonNullable<Awaited<ReturnType<typeof updateEmployeeOvertimes>>>
    export type UpdateEmployeeOvertimesMutationBody = EmployeeOvertime[]
    export type UpdateEmployeeOvertimesMutationError = AxiosError<ErrorResponse>

    export const useUpdateEmployeeOvertimes = <TData = Awaited<ReturnType<typeof updateEmployeeOvertimes>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeeOvertime[]},
        TContext
      > => {

      const mutationOptions = getUpdateEmployeeOvertimesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Employee Overtimes
 */
export const addEmployeeOvertimes = (
    id: number,
    employeeOvertime: EmployeeOvertime[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EmployeeOvertime[]>> => {
    
    
    return axios.default.post(
      `/api/hr/employee/${id}/overtime`,
      employeeOvertime,options
    );
  }



export const getAddEmployeeOvertimesMutationOptions = <TData = Awaited<ReturnType<typeof addEmployeeOvertimes>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addEmployeeOvertimes'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addEmployeeOvertimes>>, {id: number;data: EmployeeOvertime[]}> = (props) => {
          const {id,data} = props ?? {};

          return  addEmployeeOvertimes(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>}

    export type AddEmployeeOvertimesMutationResult = NonNullable<Awaited<ReturnType<typeof addEmployeeOvertimes>>>
    export type AddEmployeeOvertimesMutationBody = EmployeeOvertime[]
    export type AddEmployeeOvertimesMutationError = AxiosError<ErrorResponse>

    export const useAddEmployeeOvertimes = <TData = Awaited<ReturnType<typeof addEmployeeOvertimes>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeeOvertime[]},
        TContext
      > => {

      const mutationOptions = getAddEmployeeOvertimesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Bank Branch
 */
export const getBankBranch = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BankBranch>> => {
    
    
    return axios.default.get(
      `/api/finance/bankBranch/${id}`,options
    );
  }


export const getGetBankBranchQueryKey = (id: number,) => {
    return [`/api/finance/bankBranch/${id}`] as const;
    }

    
export const getGetBankBranchQueryOptions = <TData = Awaited<ReturnType<typeof getBankBranch>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankBranch>>> = ({ signal }) => getBankBranch(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankBranchQueryResult = NonNullable<Awaited<ReturnType<typeof getBankBranch>>>
export type GetBankBranchQueryError = AxiosError<unknown>


export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankBranch>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankBranch>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankBranchQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBankBranchSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBankBranch>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankBranch>>> = ({ signal }) => getBankBranch(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankBranchSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBankBranch>>>
export type GetBankBranchSuspenseQueryError = AxiosError<unknown>


export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankBranchSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Bank Branch
 */
export const updateBankbranch = (
    id: number,
    bankBranch: BankBranch, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BankBranch>> => {
    
    
    return axios.default.put(
      `/api/finance/bankBranch/${id}`,
      bankBranch,options
    );
  }



export const getUpdateBankbranchMutationOptions = <TData = Awaited<ReturnType<typeof updateBankbranch>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankBranch}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateBankbranch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBankbranch>>, {id: number;data: BankBranch}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBankbranch(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: BankBranch}, TContext>}

    export type UpdateBankbranchMutationResult = NonNullable<Awaited<ReturnType<typeof updateBankbranch>>>
    export type UpdateBankbranchMutationBody = BankBranch
    export type UpdateBankbranchMutationError = AxiosError<ErrorResponse>

    export const useUpdateBankbranch = <TData = Awaited<ReturnType<typeof updateBankbranch>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankBranch}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: BankBranch},
        TContext
      > => {

      const mutationOptions = getUpdateBankbranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Bank Branch
 */
export const deleteBankBranch = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BankBranch>> => {
    
    
    return axios.default.delete(
      `/api/finance/bankBranch/${id}`,options
    );
  }



export const getDeleteBankBranchMutationOptions = <TData = Awaited<ReturnType<typeof deleteBankBranch>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteBankBranch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBankBranch>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBankBranch(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBankBranchMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBankBranch>>>
    
    export type DeleteBankBranchMutationError = AxiosError<ResponseBase>

    export const useDeleteBankBranch = <TData = Awaited<ReturnType<typeof deleteBankBranch>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBankBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Bank Account
 */
export const getBankAccount = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BankAccount>> => {
    
    
    return axios.default.get(
      `/api/finance/bankAccount/${id}`,options
    );
  }


export const getGetBankAccountQueryKey = (id: number,) => {
    return [`/api/finance/bankAccount/${id}`] as const;
    }

    
export const getGetBankAccountQueryOptions = <TData = Awaited<ReturnType<typeof getBankAccount>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankAccount>>> = ({ signal }) => getBankAccount(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getBankAccount>>>
export type GetBankAccountQueryError = AxiosError<unknown>


export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBankAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBankAccount>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankAccount>>> = ({ signal }) => getBankAccount(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBankAccount>>>
export type GetBankAccountSuspenseQueryError = AxiosError<unknown>


export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Bank Account
 */
export const updateBankAccount = (
    id: number,
    bankAccount: BankAccount, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BankAccount>> => {
    
    
    return axios.default.put(
      `/api/finance/bankAccount/${id}`,
      bankAccount,options
    );
  }



export const getUpdateBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateBankAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankAccount}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateBankAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBankAccount>>, {id: number;data: BankAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBankAccount(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: BankAccount}, TContext>}

    export type UpdateBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateBankAccount>>>
    export type UpdateBankAccountMutationBody = BankAccount
    export type UpdateBankAccountMutationError = AxiosError<ErrorResponse>

    export const useUpdateBankAccount = <TData = Awaited<ReturnType<typeof updateBankAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankAccount}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: BankAccount},
        TContext
      > => {

      const mutationOptions = getUpdateBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Bank Account
 */
export const deleteBankAccount = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BankAccount>> => {
    
    
    return axios.default.delete(
      `/api/finance/bankAccount/${id}`,options
    );
  }



export const getDeleteBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteBankAccount>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteBankAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBankAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBankAccount(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBankAccount>>>
    
    export type DeleteBankAccountMutationError = AxiosError<ResponseBase>

    export const useDeleteBankAccount = <TData = Awaited<ReturnType<typeof deleteBankAccount>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Bank
 */
export const getDepartment = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Bank>> => {
    
    
    return axios.default.get(
      `/api/finance/bank/${id}`,options
    );
  }


export const getGetDepartmentQueryKey = (id: number,) => {
    return [`/api/finance/bank/${id}`] as const;
    }

    
export const getGetDepartmentQueryOptions = <TData = Awaited<ReturnType<typeof getDepartment>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartmentQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment>>> = ({ signal }) => getDepartment(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartmentQueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment>>>
export type GetDepartmentQueryError = AxiosError<ErrorResponse>


export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartmentQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepartmentSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepartment>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartmentQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment>>> = ({ signal }) => getDepartment(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartmentSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment>>>
export type GetDepartmentSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartmentSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Bank
 */
export const updateBank = (
    id: number,
    bank: Bank, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Bank>> => {
    
    
    return axios.default.put(
      `/api/finance/bank/${id}`,
      bank,options
    );
  }



export const getUpdateBankMutationOptions = <TData = Awaited<ReturnType<typeof updateBank>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Bank}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateBank'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBank>>, {id: number;data: Bank}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBank(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Bank}, TContext>}

    export type UpdateBankMutationResult = NonNullable<Awaited<ReturnType<typeof updateBank>>>
    export type UpdateBankMutationBody = Bank
    export type UpdateBankMutationError = AxiosError<ErrorResponse>

    export const useUpdateBank = <TData = Awaited<ReturnType<typeof updateBank>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Bank}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Bank},
        TContext
      > => {

      const mutationOptions = getUpdateBankMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete bank
 */
export const deleteBank = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Bank>> => {
    
    
    return axios.default.delete(
      `/api/finance/bank/${id}`,options
    );
  }



export const getDeleteBankMutationOptions = <TData = Awaited<ReturnType<typeof deleteBank>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteBank'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBank>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBank(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBankMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBank>>>
    
    export type DeleteBankMutationError = AxiosError<ResponseBase>

    export const useDeleteBank = <TData = Awaited<ReturnType<typeof deleteBank>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBankMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Department
 */
export const getDepartment1 = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Department>> => {
    
    
    return axios.default.get(
      `/api/company/department/${id}`,options
    );
  }


export const getGetDepartment1QueryKey = (id: number,) => {
    return [`/api/company/department/${id}`] as const;
    }

    
export const getGetDepartment1QueryOptions = <TData = Awaited<ReturnType<typeof getDepartment1>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartment1QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment1>>> = ({ signal }) => getDepartment1(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartment1QueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment1>>>
export type GetDepartment1QueryError = AxiosError<ErrorResponse>


export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment1>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment1>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartment1QueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepartment1SuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepartment1>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartment1QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment1>>> = ({ signal }) => getDepartment1(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartment1SuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment1>>>
export type GetDepartment1SuspenseQueryError = AxiosError<ErrorResponse>


export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartment1SuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Department
 */
export const updateDepartment = (
    id: number,
    department: Department, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Department>> => {
    
    
    return axios.default.put(
      `/api/company/department/${id}`,
      department,options
    );
  }



export const getUpdateDepartmentMutationOptions = <TData = Awaited<ReturnType<typeof updateDepartment>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Department}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateDepartment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDepartment>>, {id: number;data: Department}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDepartment(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Department}, TContext>}

    export type UpdateDepartmentMutationResult = NonNullable<Awaited<ReturnType<typeof updateDepartment>>>
    export type UpdateDepartmentMutationBody = Department
    export type UpdateDepartmentMutationError = AxiosError<ErrorResponse>

    export const useUpdateDepartment = <TData = Awaited<ReturnType<typeof updateDepartment>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Department}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Department},
        TContext
      > => {

      const mutationOptions = getUpdateDepartmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Department
 */
export const deleteDepartment = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Department>> => {
    
    
    return axios.default.delete(
      `/api/company/department/${id}`,options
    );
  }



export const getDeleteDepartmentMutationOptions = <TData = Awaited<ReturnType<typeof deleteDepartment>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteDepartment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDepartment>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteDepartment(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteDepartmentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDepartment>>>
    
    export type DeleteDepartmentMutationError = AxiosError<ResponseBase>

    export const useDeleteDepartment = <TData = Awaited<ReturnType<typeof deleteDepartment>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteDepartmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Branch
 */
export const getBranch = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Branch>> => {
    
    
    return axios.default.get(
      `/api/company/branch/${id}`,options
    );
  }


export const getGetBranchQueryKey = (id: number,) => {
    return [`/api/company/branch/${id}`] as const;
    }

    
export const getGetBranchQueryOptions = <TData = Awaited<ReturnType<typeof getBranch>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranch>>> = ({ signal }) => getBranch(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBranchQueryResult = NonNullable<Awaited<ReturnType<typeof getBranch>>>
export type GetBranchQueryError = AxiosError<ErrorResponse>


export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranch>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranch>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBranchQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBranchSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBranch>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranch>>> = ({ signal }) => getBranch(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBranchSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBranch>>>
export type GetBranchSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBranchSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Branch
 */
export const updateBranch = (
    id: number,
    branch: Branch, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Branch>> => {
    
    
    return axios.default.put(
      `/api/company/branch/${id}`,
      branch,options
    );
  }



export const getUpdateBranchMutationOptions = <TData = Awaited<ReturnType<typeof updateBranch>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Branch}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateBranch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBranch>>, {id: number;data: Branch}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBranch(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Branch}, TContext>}

    export type UpdateBranchMutationResult = NonNullable<Awaited<ReturnType<typeof updateBranch>>>
    export type UpdateBranchMutationBody = Branch
    export type UpdateBranchMutationError = AxiosError<ErrorResponse>

    export const useUpdateBranch = <TData = Awaited<ReturnType<typeof updateBranch>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Branch}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Branch},
        TContext
      > => {

      const mutationOptions = getUpdateBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Branch
 */
export const deleteBranch = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Branch>> => {
    
    
    return axios.default.delete(
      `/api/company/branch/${id}`,options
    );
  }



export const getDeleteBranchMutationOptions = <TData = Awaited<ReturnType<typeof deleteBranch>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteBranch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBranch>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBranch(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBranchMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBranch>>>
    
    export type DeleteBranchMutationError = AxiosError<ResponseBase>

    export const useDeleteBranch = <TData = Awaited<ReturnType<typeof deleteBranch>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Section
 */
export const getSection = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Section>> => {
    
    
    return axios.default.get(
      `/api/admin/section/${id}`,options
    );
  }


export const getGetSectionQueryKey = (id: number,) => {
    return [`/api/admin/section/${id}`] as const;
    }

    
export const getGetSectionQueryOptions = <TData = Awaited<ReturnType<typeof getSection>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSectionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSection>>> = ({ signal }) => getSection(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSectionQueryResult = NonNullable<Awaited<ReturnType<typeof getSection>>>
export type GetSectionQueryError = AxiosError<ErrorResponse>


export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSection>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSection>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSectionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSectionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSection>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSectionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSection>>> = ({ signal }) => getSection(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSectionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSection>>>
export type GetSectionSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSectionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Section
 */
export const updateSection = (
    id: number,
    section: Section, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Section>> => {
    
    
    return axios.default.put(
      `/api/admin/section/${id}`,
      section,options
    );
  }



export const getUpdateSectionMutationOptions = <TData = Awaited<ReturnType<typeof updateSection>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Section}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateSection'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSection>>, {id: number;data: Section}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSection(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Section}, TContext>}

    export type UpdateSectionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSection>>>
    export type UpdateSectionMutationBody = Section
    export type UpdateSectionMutationError = AxiosError<ErrorResponse>

    export const useUpdateSection = <TData = Awaited<ReturnType<typeof updateSection>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Section}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Section},
        TContext
      > => {

      const mutationOptions = getUpdateSectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Section
 */
export const deleteSection = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Section>> => {
    
    
    return axios.default.delete(
      `/api/admin/section/${id}`,options
    );
  }



export const getDeleteSectionMutationOptions = <TData = Awaited<ReturnType<typeof deleteSection>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteSection'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSection>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteSection(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteSectionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSection>>>
    
    export type DeleteSectionMutationError = AxiosError<ResponseBase>

    export const useDeleteSection = <TData = Awaited<ReturnType<typeof deleteSection>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteSectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Role
 */
export const getRole = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Role>> => {
    
    
    return axios.default.get(
      `/api/admin/role/${id}`,options
    );
  }


export const getGetRoleQueryKey = (id: number,) => {
    return [`/api/admin/role/${id}`] as const;
    }

    
export const getGetRoleQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoleQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleQueryError = AxiosError<ErrorResponse>


export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoleQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoleSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoleSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Role
 */
export const updateRole = (
    id: number,
    role: Role, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Role>> => {
    
    
    return axios.default.put(
      `/api/admin/role/${id}`,
      role,options
    );
  }



export const getUpdateRoleMutationOptions = <TData = Awaited<ReturnType<typeof updateRole>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Role}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRole>>, {id: number;data: Role}> = (props) => {
          const {id,data} = props ?? {};

          return  updateRole(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Role}, TContext>}

    export type UpdateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateRole>>>
    export type UpdateRoleMutationBody = Role
    export type UpdateRoleMutationError = AxiosError<ErrorResponse>

    export const useUpdateRole = <TData = Awaited<ReturnType<typeof updateRole>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Role}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Role},
        TContext
      > => {

      const mutationOptions = getUpdateRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Role
 */
export const deleteRole = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Role>> => {
    
    
    return axios.default.delete(
      `/api/admin/role/${id}`,options
    );
  }



export const getDeleteRoleMutationOptions = <TData = Awaited<ReturnType<typeof deleteRole>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRole>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteRole(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteRoleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRole>>>
    
    export type DeleteRoleMutationError = AxiosError<ResponseBase>

    export const useDeleteRole = <TData = Awaited<ReturnType<typeof deleteRole>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Public Holiday
 */
export const getPublicHoliday = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PublicHoliday>> => {
    
    
    return axios.default.get(
      `/api/admin/publicHoliday/${id}`,options
    );
  }


export const getGetPublicHolidayQueryKey = (id: number,) => {
    return [`/api/admin/publicHoliday/${id}`] as const;
    }

    
export const getGetPublicHolidayQueryOptions = <TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublicHolidayQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicHoliday>>> = ({ signal }) => getPublicHoliday(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPublicHolidayQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicHoliday>>>
export type GetPublicHolidayQueryError = AxiosError<ErrorResponse>


export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicHoliday>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicHoliday>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPublicHolidayQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPublicHolidaySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublicHolidayQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicHoliday>>> = ({ signal }) => getPublicHoliday(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPublicHolidaySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicHoliday>>>
export type GetPublicHolidaySuspenseQueryError = AxiosError<ErrorResponse>


export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPublicHolidaySuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Public Holiday
 */
export const updatePublicHoliday = (
    id: number,
    publicHoliday: PublicHoliday, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PublicHoliday>> => {
    
    
    return axios.default.put(
      `/api/admin/publicHoliday/${id}`,
      publicHoliday,options
    );
  }



export const getUpdatePublicHolidayMutationOptions = <TData = Awaited<ReturnType<typeof updatePublicHoliday>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PublicHoliday}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updatePublicHoliday'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePublicHoliday>>, {id: number;data: PublicHoliday}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePublicHoliday(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: PublicHoliday}, TContext>}

    export type UpdatePublicHolidayMutationResult = NonNullable<Awaited<ReturnType<typeof updatePublicHoliday>>>
    export type UpdatePublicHolidayMutationBody = PublicHoliday
    export type UpdatePublicHolidayMutationError = AxiosError<ErrorResponse>

    export const useUpdatePublicHoliday = <TData = Awaited<ReturnType<typeof updatePublicHoliday>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PublicHoliday}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: PublicHoliday},
        TContext
      > => {

      const mutationOptions = getUpdatePublicHolidayMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete PublicHoliday
 */
export const deletePublicHoliday = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PublicHoliday>> => {
    
    
    return axios.default.delete(
      `/api/admin/publicHoliday/${id}`,options
    );
  }



export const getDeletePublicHolidayMutationOptions = <TData = Awaited<ReturnType<typeof deletePublicHoliday>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deletePublicHoliday'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePublicHoliday>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deletePublicHoliday(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeletePublicHolidayMutationResult = NonNullable<Awaited<ReturnType<typeof deletePublicHoliday>>>
    
    export type DeletePublicHolidayMutationError = AxiosError<ResponseBase>

    export const useDeletePublicHoliday = <TData = Awaited<ReturnType<typeof deletePublicHoliday>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeletePublicHolidayMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get PaymentMethod
 */
export const getPaymentMethod = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaymentMethod>> => {
    
    
    return axios.default.get(
      `/api/admin/paymentMethod/${id}`,options
    );
  }


export const getGetPaymentMethodQueryKey = (id: number,) => {
    return [`/api/admin/paymentMethod/${id}`] as const;
    }

    
export const getGetPaymentMethodQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentMethodQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentMethod>>> = ({ signal }) => getPaymentMethod(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPaymentMethodQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentMethod>>>
export type GetPaymentMethodQueryError = AxiosError<ErrorResponse>


export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentMethod>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentMethod>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPaymentMethodQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPaymentMethodSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentMethodQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentMethod>>> = ({ signal }) => getPaymentMethod(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPaymentMethodSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentMethod>>>
export type GetPaymentMethodSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPaymentMethodSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update PaymentMethod
 */
export const updatePaymentMethod = (
    id: number,
    paymentMethod: PaymentMethod, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaymentMethod>> => {
    
    
    return axios.default.put(
      `/api/admin/paymentMethod/${id}`,
      paymentMethod,options
    );
  }



export const getUpdatePaymentMethodMutationOptions = <TData = Awaited<ReturnType<typeof updatePaymentMethod>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PaymentMethod}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updatePaymentMethod'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePaymentMethod>>, {id: number;data: PaymentMethod}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePaymentMethod(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: PaymentMethod}, TContext>}

    export type UpdatePaymentMethodMutationResult = NonNullable<Awaited<ReturnType<typeof updatePaymentMethod>>>
    export type UpdatePaymentMethodMutationBody = PaymentMethod
    export type UpdatePaymentMethodMutationError = AxiosError<ErrorResponse>

    export const useUpdatePaymentMethod = <TData = Awaited<ReturnType<typeof updatePaymentMethod>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PaymentMethod}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: PaymentMethod},
        TContext
      > => {

      const mutationOptions = getUpdatePaymentMethodMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete PaymentMethod
 */
export const deletePaymentMethod = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaymentMethod>> => {
    
    
    return axios.default.delete(
      `/api/admin/paymentMethod/${id}`,options
    );
  }



export const getDeletePaymentMethodMutationOptions = <TData = Awaited<ReturnType<typeof deletePaymentMethod>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deletePaymentMethod'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePaymentMethod>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deletePaymentMethod(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeletePaymentMethodMutationResult = NonNullable<Awaited<ReturnType<typeof deletePaymentMethod>>>
    
    export type DeletePaymentMethodMutationError = AxiosError<ResponseBase>

    export const useDeletePaymentMethod = <TData = Awaited<ReturnType<typeof deletePaymentMethod>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeletePaymentMethodMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Machine
 */
export const getMachine = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Machine>> => {
    
    
    return axios.default.get(
      `/api/admin/machine/${id}`,options
    );
  }


export const getGetMachineQueryKey = (id: number,) => {
    return [`/api/admin/machine/${id}`] as const;
    }

    
export const getGetMachineQueryOptions = <TData = Awaited<ReturnType<typeof getMachine>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMachineQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMachine>>> = ({ signal }) => getMachine(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMachineQueryResult = NonNullable<Awaited<ReturnType<typeof getMachine>>>
export type GetMachineQueryError = AxiosError<ErrorResponse>


export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMachine>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMachine>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMachineQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMachineSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMachine>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMachineQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMachine>>> = ({ signal }) => getMachine(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMachineSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMachine>>>
export type GetMachineSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMachineSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Machine
 */
export const updateMachine = (
    id: number,
    machine: Machine, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Machine>> => {
    
    
    return axios.default.put(
      `/api/admin/machine/${id}`,
      machine,options
    );
  }



export const getUpdateMachineMutationOptions = <TData = Awaited<ReturnType<typeof updateMachine>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Machine}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateMachine'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMachine>>, {id: number;data: Machine}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMachine(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Machine}, TContext>}

    export type UpdateMachineMutationResult = NonNullable<Awaited<ReturnType<typeof updateMachine>>>
    export type UpdateMachineMutationBody = Machine
    export type UpdateMachineMutationError = AxiosError<ErrorResponse>

    export const useUpdateMachine = <TData = Awaited<ReturnType<typeof updateMachine>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Machine}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Machine},
        TContext
      > => {

      const mutationOptions = getUpdateMachineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Machine
 */
export const deleteMachine = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Machine>> => {
    
    
    return axios.default.delete(
      `/api/admin/machine/${id}`,options
    );
  }



export const getDeleteMachineMutationOptions = <TData = Awaited<ReturnType<typeof deleteMachine>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteMachine'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMachine>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMachine(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteMachineMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMachine>>>
    
    export type DeleteMachineMutationError = AxiosError<ResponseBase>

    export const useDeleteMachine = <TData = Awaited<ReturnType<typeof deleteMachine>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMachineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Depot
 */
export const getDepot = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Depot>> => {
    
    
    return axios.default.get(
      `/api/admin/depot/${id}`,options
    );
  }


export const getGetDepotQueryKey = (id: number,) => {
    return [`/api/admin/depot/${id}`] as const;
    }

    
export const getGetDepotQueryOptions = <TData = Awaited<ReturnType<typeof getDepot>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepot>>> = ({ signal }) => getDepot(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotQueryResult = NonNullable<Awaited<ReturnType<typeof getDepot>>>
export type GetDepotQueryError = AxiosError<ErrorResponse>


export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepot>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepot>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepotSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepot>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepot>>> = ({ signal }) => getDepot(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepot>>>
export type GetDepotSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Depot
 */
export const updateDepot = (
    id: number,
    depot: Depot, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Depot>> => {
    
    
    return axios.default.put(
      `/api/admin/depot/${id}`,
      depot,options
    );
  }



export const getUpdateDepotMutationOptions = <TData = Awaited<ReturnType<typeof updateDepot>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Depot}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateDepot'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDepot>>, {id: number;data: Depot}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDepot(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Depot}, TContext>}

    export type UpdateDepotMutationResult = NonNullable<Awaited<ReturnType<typeof updateDepot>>>
    export type UpdateDepotMutationBody = Depot
    export type UpdateDepotMutationError = AxiosError<ErrorResponse>

    export const useUpdateDepot = <TData = Awaited<ReturnType<typeof updateDepot>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Depot}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Depot},
        TContext
      > => {

      const mutationOptions = getUpdateDepotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Depot
 */
export const deleteDepot = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Depot>> => {
    
    
    return axios.default.delete(
      `/api/admin/depot/${id}`,options
    );
  }



export const getDeleteDepotMutationOptions = <TData = Awaited<ReturnType<typeof deleteDepot>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteDepot'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDepot>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteDepot(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteDepotMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDepot>>>
    
    export type DeleteDepotMutationError = AxiosError<ResponseBase>

    export const useDeleteDepot = <TData = Awaited<ReturnType<typeof deleteDepot>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteDepotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Company
 */
export const getCompany = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Company>> => {
    
    
    return axios.default.get(
      `/api/admin/company/${id}`,options
    );
  }


export const getGetCompanyQueryKey = (id: number,) => {
    return [`/api/admin/company/${id}`] as const;
    }

    
export const getGetCompanyQueryOptions = <TData = Awaited<ReturnType<typeof getCompany>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCompanyQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompany>>> = ({ signal }) => getCompany(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCompanyQueryResult = NonNullable<Awaited<ReturnType<typeof getCompany>>>
export type GetCompanyQueryError = AxiosError<ErrorResponse>


export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompany>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompany>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCompanyQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCompanySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCompany>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCompanyQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompany>>> = ({ signal }) => getCompany(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCompanySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCompany>>>
export type GetCompanySuspenseQueryError = AxiosError<ErrorResponse>


export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCompanySuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Company
 */
export const updateCompany = (
    id: number,
    company: Company, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Company>> => {
    
    
    return axios.default.put(
      `/api/admin/company/${id}`,
      company,options
    );
  }



export const getUpdateCompanyMutationOptions = <TData = Awaited<ReturnType<typeof updateCompany>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Company}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateCompany'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCompany>>, {id: number;data: Company}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCompany(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Company}, TContext>}

    export type UpdateCompanyMutationResult = NonNullable<Awaited<ReturnType<typeof updateCompany>>>
    export type UpdateCompanyMutationBody = Company
    export type UpdateCompanyMutationError = AxiosError<ErrorResponse>

    export const useUpdateCompany = <TData = Awaited<ReturnType<typeof updateCompany>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Company}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Company},
        TContext
      > => {

      const mutationOptions = getUpdateCompanyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Company
 */
export const deleteCompany = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Company>> => {
    
    
    return axios.default.delete(
      `/api/admin/company/${id}`,options
    );
  }



export const getDeleteCompanyMutationOptions = <TData = Awaited<ReturnType<typeof deleteCompany>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteCompany'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCompany>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCompany(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCompanyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCompany>>>
    
    export type DeleteCompanyMutationError = AxiosError<ResponseBase>

    export const useDeleteCompany = <TData = Awaited<ReturnType<typeof deleteCompany>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCompanyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ExpenseInvoice
 */
export const getExpenseInvoice = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExpenseInvoice>> => {
    
    
    return axios.default.get(
      `/api/accounting/expenseInvoice/${id}`,options
    );
  }


export const getGetExpenseInvoiceQueryKey = (id: number,) => {
    return [`/api/accounting/expenseInvoice/${id}`] as const;
    }

    
export const getGetExpenseInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseInvoice>>> = ({ signal }) => getExpenseInvoice(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseInvoice>>>
export type GetExpenseInvoiceQueryError = AxiosError<ErrorResponse>


export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseInvoiceQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExpenseInvoiceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseInvoice>>> = ({ signal }) => getExpenseInvoice(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseInvoiceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseInvoice>>>
export type GetExpenseInvoiceSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseInvoiceSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ExpenseInvoice
 */
export const updateExpenseInvoice = (
    id: number,
    expenseInvoice: ExpenseInvoice, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExpenseInvoice>> => {
    
    
    return axios.default.put(
      `/api/accounting/expenseInvoice/${id}`,
      expenseInvoice,options
    );
  }



export const getUpdateExpenseInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof updateExpenseInvoice>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseInvoice}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateExpenseInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExpenseInvoice>>, {id: number;data: ExpenseInvoice}> = (props) => {
          const {id,data} = props ?? {};

          return  updateExpenseInvoice(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ExpenseInvoice}, TContext>}

    export type UpdateExpenseInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof updateExpenseInvoice>>>
    export type UpdateExpenseInvoiceMutationBody = ExpenseInvoice
    export type UpdateExpenseInvoiceMutationError = AxiosError<ErrorResponse>

    export const useUpdateExpenseInvoice = <TData = Awaited<ReturnType<typeof updateExpenseInvoice>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseInvoice}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ExpenseInvoice},
        TContext
      > => {

      const mutationOptions = getUpdateExpenseInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ExpenseInvoice
 */
export const deleteExpenseInvoice = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExpenseInvoice>> => {
    
    
    return axios.default.delete(
      `/api/accounting/expenseInvoice/${id}`,options
    );
  }



export const getDeleteExpenseInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof deleteExpenseInvoice>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteExpenseInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteExpenseInvoice>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteExpenseInvoice(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteExpenseInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteExpenseInvoice>>>
    
    export type DeleteExpenseInvoiceMutationError = AxiosError<ResponseBase>

    export const useDeleteExpenseInvoice = <TData = Awaited<ReturnType<typeof deleteExpenseInvoice>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteExpenseInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ExpenseCard
 */
export const getExpenseCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExpenseCard>> => {
    
    
    return axios.default.get(
      `/api/accounting/expenseCard/${id}`,options
    );
  }


export const getGetExpenseCardQueryKey = (id: number,) => {
    return [`/api/accounting/expenseCard/${id}`] as const;
    }

    
export const getGetExpenseCardQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseCard>>> = ({ signal }) => getExpenseCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseCardQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseCard>>>
export type GetExpenseCardQueryError = AxiosError<ErrorResponse>


export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseCard>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExpenseCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseCard>>> = ({ signal }) => getExpenseCard(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseCard>>>
export type GetExpenseCardSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ExpenseCard
 */
export const updateExpenseCard = (
    id: number,
    expenseCard: ExpenseCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExpenseCard>> => {
    
    
    return axios.default.put(
      `/api/accounting/expenseCard/${id}`,
      expenseCard,options
    );
  }



export const getUpdateExpenseCardMutationOptions = <TData = Awaited<ReturnType<typeof updateExpenseCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateExpenseCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExpenseCard>>, {id: number;data: ExpenseCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateExpenseCard(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ExpenseCard}, TContext>}

    export type UpdateExpenseCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateExpenseCard>>>
    export type UpdateExpenseCardMutationBody = ExpenseCard
    export type UpdateExpenseCardMutationError = AxiosError<ErrorResponse>

    export const useUpdateExpenseCard = <TData = Awaited<ReturnType<typeof updateExpenseCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ExpenseCard},
        TContext
      > => {

      const mutationOptions = getUpdateExpenseCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ExpenseCard
 */
export const deleteExpenseCard = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExpenseCard>> => {
    
    
    return axios.default.delete(
      `/api/accounting/expenseCard/${id}`,options
    );
  }



export const getDeleteExpenseCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteExpenseCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteExpenseCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteExpenseCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteExpenseCard(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteExpenseCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteExpenseCard>>>
    
    export type DeleteExpenseCardMutationError = AxiosError<ResponseBase>

    export const useDeleteExpenseCard = <TData = Awaited<ReturnType<typeof deleteExpenseCard>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteExpenseCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get CashAccountTransaction
 */
export const getCashAccountTransaction = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CashAccountTransaction>> => {
    
    
    return axios.default.get(
      `/api/accounting/cashAccountTransaction/${id}`,options
    );
  }


export const getGetCashAccountTransactionQueryKey = (id: number,) => {
    return [`/api/accounting/cashAccountTransaction/${id}`] as const;
    }

    
export const getGetCashAccountTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccountTransaction>>> = ({ signal }) => getCashAccountTransaction(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccountTransaction>>>
export type GetCashAccountTransactionQueryError = AxiosError<ErrorResponse>


export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountTransactionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCashAccountTransactionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccountTransaction>>> = ({ signal }) => getCashAccountTransaction(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountTransactionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccountTransaction>>>
export type GetCashAccountTransactionSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountTransactionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update CashAccountTransaction
 */
export const updateCashAccountTransaction = (
    id: number,
    cashAccountTransaction: CashAccountTransaction, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CashAccountTransaction>> => {
    
    
    return axios.default.put(
      `/api/accounting/cashAccountTransaction/${id}`,
      cashAccountTransaction,options
    );
  }



export const getUpdateCashAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof updateCashAccountTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccountTransaction}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateCashAccountTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCashAccountTransaction>>, {id: number;data: CashAccountTransaction}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCashAccountTransaction(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CashAccountTransaction}, TContext>}

    export type UpdateCashAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof updateCashAccountTransaction>>>
    export type UpdateCashAccountTransactionMutationBody = CashAccountTransaction
    export type UpdateCashAccountTransactionMutationError = AxiosError<ErrorResponse>

    export const useUpdateCashAccountTransaction = <TData = Awaited<ReturnType<typeof updateCashAccountTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccountTransaction}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CashAccountTransaction},
        TContext
      > => {

      const mutationOptions = getUpdateCashAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete CashAccountTransaction
 */
export const deleteCashAccountTransaction = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CashAccountTransaction>> => {
    
    
    return axios.default.delete(
      `/api/accounting/cashAccountTransaction/${id}`,options
    );
  }



export const getDeleteCashAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof deleteCashAccountTransaction>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteCashAccountTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCashAccountTransaction>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCashAccountTransaction(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCashAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCashAccountTransaction>>>
    
    export type DeleteCashAccountTransactionMutationError = AxiosError<ResponseBase>

    export const useDeleteCashAccountTransaction = <TData = Awaited<ReturnType<typeof deleteCashAccountTransaction>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCashAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get CashAccount
 */
export const getCashAccount = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CashAccount>> => {
    
    
    return axios.default.get(
      `/api/accounting/cashAccount/${id}`,options
    );
  }


export const getGetCashAccountQueryKey = (id: number,) => {
    return [`/api/accounting/cashAccount/${id}`] as const;
    }

    
export const getGetCashAccountQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccount>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccount>>> = ({ signal }) => getCashAccount(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccount>>>
export type GetCashAccountQueryError = AxiosError<ErrorResponse>


export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccount>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccount>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCashAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccount>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccount>>> = ({ signal }) => getCashAccount(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccount>>>
export type GetCashAccountSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update CashAccount
 */
export const updateCashAccount = (
    id: number,
    cashAccount: CashAccount, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CashAccount>> => {
    
    
    return axios.default.put(
      `/api/accounting/cashAccount/${id}`,
      cashAccount,options
    );
  }



export const getUpdateCashAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateCashAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccount}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['updateCashAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCashAccount>>, {id: number;data: CashAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCashAccount(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CashAccount}, TContext>}

    export type UpdateCashAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateCashAccount>>>
    export type UpdateCashAccountMutationBody = CashAccount
    export type UpdateCashAccountMutationError = AxiosError<ErrorResponse>

    export const useUpdateCashAccount = <TData = Awaited<ReturnType<typeof updateCashAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccount}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CashAccount},
        TContext
      > => {

      const mutationOptions = getUpdateCashAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete CashAccount
 */
export const deleteCashAccount = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CashAccount>> => {
    
    
    return axios.default.delete(
      `/api/accounting/cashAccount/${id}`,options
    );
  }



export const getDeleteCashAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteCashAccount>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteCashAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCashAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCashAccount(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCashAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCashAccount>>>
    
    export type DeleteCashAccountMutationError = AxiosError<ResponseBase>

    export const useDeleteCashAccount = <TData = Awaited<ReturnType<typeof deleteCashAccount>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCashAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const refresh = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RefreshResponse>> => {
    
    
    return axios.default.post(
      `/api/user/refresh`,undefined,options
    );
  }



export const getRefreshMutationOptions = <TData = Awaited<ReturnType<typeof refresh>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['refresh'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refresh>>, void> = () => {
          

          return  refresh(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type RefreshMutationResult = NonNullable<Awaited<ReturnType<typeof refresh>>>
    
    export type RefreshMutationError = AxiosError<ResponseBase>

    export const useRefresh = <TData = Awaited<ReturnType<typeof refresh>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getRefreshMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const logout = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Logout200>> => {
    
    
    return axios.default.post(
      `/api/user/logout`,undefined,options
    );
  }



export const getLogoutMutationOptions = <TData = Awaited<ReturnType<typeof logout>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['logout'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = AxiosError<unknown>

    export const useLogout = <TData = Awaited<ReturnType<typeof logout>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Login erp user
 */
export const login = (
    loginRequest: LoginRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LoginResponse>> => {
    
    
    return axios.default.post(
      `/api/user/login`,
      loginRequest,options
    );
  }



export const getLoginMutationOptions = <TData = Awaited<ReturnType<typeof login>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: LoginRequest}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['login'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: LoginRequest}, TContext>}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = AxiosError<ResponseBase>

    export const useLogin = <TData = Awaited<ReturnType<typeof login>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: LoginRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Unit
 */
export const addUnit = (
    unit: Unit, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Unit>> => {
    
    
    return axios.default.post(
      `/api/storage/unit`,
      unit,options
    );
  }



export const getAddUnitMutationOptions = <TData = Awaited<ReturnType<typeof addUnit>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Unit}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addUnit'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUnit>>, {data: Unit}> = (props) => {
          const {data} = props ?? {};

          return  addUnit(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Unit}, TContext>}

    export type AddUnitMutationResult = NonNullable<Awaited<ReturnType<typeof addUnit>>>
    export type AddUnitMutationBody = Unit
    export type AddUnitMutationError = AxiosError<ErrorResponse>

    export const useAddUnit = <TData = Awaited<ReturnType<typeof addUnit>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Unit}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Unit},
        TContext
      > => {

      const mutationOptions = getAddUnitMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Shelf
 */
export const addShelf = (
    shelf: Shelf, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Shelf>> => {
    
    
    return axios.default.post(
      `/api/storage/shelf`,
      shelf,options
    );
  }



export const getAddShelfMutationOptions = <TData = Awaited<ReturnType<typeof addShelf>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Shelf}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addShelf'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addShelf>>, {data: Shelf}> = (props) => {
          const {data} = props ?? {};

          return  addShelf(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Shelf}, TContext>}

    export type AddShelfMutationResult = NonNullable<Awaited<ReturnType<typeof addShelf>>>
    export type AddShelfMutationBody = Shelf
    export type AddShelfMutationError = AxiosError<ErrorResponse>

    export const useAddShelf = <TData = Awaited<ReturnType<typeof addShelf>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Shelf}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Shelf},
        TContext
      > => {

      const mutationOptions = getAddShelfMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ServiceGroup
 */
export const addServiceGroup = (
    serviceGroup: ServiceGroup, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ServiceGroup>> => {
    
    
    return axios.default.post(
      `/api/storage/serviceGroup`,
      serviceGroup,options
    );
  }



export const getAddServiceGroupMutationOptions = <TData = Awaited<ReturnType<typeof addServiceGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceGroup}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addServiceGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addServiceGroup>>, {data: ServiceGroup}> = (props) => {
          const {data} = props ?? {};

          return  addServiceGroup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ServiceGroup}, TContext>}

    export type AddServiceGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addServiceGroup>>>
    export type AddServiceGroupMutationBody = ServiceGroup
    export type AddServiceGroupMutationError = AxiosError<ErrorResponse>

    export const useAddServiceGroup = <TData = Awaited<ReturnType<typeof addServiceGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: ServiceGroup},
        TContext
      > => {

      const mutationOptions = getAddServiceGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ServiceCard
 */
export const addServiceCard = (
    serviceCard: ServiceCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ServiceCard>> => {
    
    
    return axios.default.post(
      `/api/storage/serviceCard`,
      serviceCard,options
    );
  }



export const getAddServiceCardMutationOptions = <TData = Awaited<ReturnType<typeof addServiceCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addServiceCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addServiceCard>>, {data: ServiceCard}> = (props) => {
          const {data} = props ?? {};

          return  addServiceCard(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ServiceCard}, TContext>}

    export type AddServiceCardMutationResult = NonNullable<Awaited<ReturnType<typeof addServiceCard>>>
    export type AddServiceCardMutationBody = ServiceCard
    export type AddServiceCardMutationError = AxiosError<ErrorResponse>

    export const useAddServiceCard = <TData = Awaited<ReturnType<typeof addServiceCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: ServiceCard},
        TContext
      > => {

      const mutationOptions = getAddServiceCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ProductGroup
 */
export const addProductGroup = (
    productGroup: ProductGroup, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProductGroup>> => {
    
    
    return axios.default.post(
      `/api/storage/productGroup`,
      productGroup,options
    );
  }



export const getAddProductGroupMutationOptions = <TData = Awaited<ReturnType<typeof addProductGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductGroup}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addProductGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProductGroup>>, {data: ProductGroup}> = (props) => {
          const {data} = props ?? {};

          return  addProductGroup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ProductGroup}, TContext>}

    export type AddProductGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addProductGroup>>>
    export type AddProductGroupMutationBody = ProductGroup
    export type AddProductGroupMutationError = AxiosError<ErrorResponse>

    export const useAddProductGroup = <TData = Awaited<ReturnType<typeof addProductGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: ProductGroup},
        TContext
      > => {

      const mutationOptions = getAddProductGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ProductCard
 */
export const addProductCard = (
    productCard: ProductCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProductCard>> => {
    
    
    return axios.default.post(
      `/api/storage/productCard`,
      productCard,options
    );
  }



export const getAddProductCardMutationOptions = <TData = Awaited<ReturnType<typeof addProductCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addProductCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProductCard>>, {data: ProductCard}> = (props) => {
          const {data} = props ?? {};

          return  addProductCard(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ProductCard}, TContext>}

    export type AddProductCardMutationResult = NonNullable<Awaited<ReturnType<typeof addProductCard>>>
    export type AddProductCardMutationBody = ProductCard
    export type AddProductCardMutationError = AxiosError<ErrorResponse>

    export const useAddProductCard = <TData = Awaited<ReturnType<typeof addProductCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: ProductCard},
        TContext
      > => {

      const mutationOptions = getAddProductCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new MaterialGroup
 */
export const addMaterialGroup = (
    materialGroup: MaterialGroup, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MaterialGroup>> => {
    
    
    return axios.default.post(
      `/api/storage/materialGroup`,
      materialGroup,options
    );
  }



export const getAddMaterialGroupMutationOptions = <TData = Awaited<ReturnType<typeof addMaterialGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialGroup}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addMaterialGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMaterialGroup>>, {data: MaterialGroup}> = (props) => {
          const {data} = props ?? {};

          return  addMaterialGroup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: MaterialGroup}, TContext>}

    export type AddMaterialGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addMaterialGroup>>>
    export type AddMaterialGroupMutationBody = MaterialGroup
    export type AddMaterialGroupMutationError = AxiosError<ErrorResponse>

    export const useAddMaterialGroup = <TData = Awaited<ReturnType<typeof addMaterialGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: MaterialGroup},
        TContext
      > => {

      const mutationOptions = getAddMaterialGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new MaterialCard
 */
export const addMaterialCard = (
    materialCard: MaterialCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MaterialCard>> => {
    
    
    return axios.default.post(
      `/api/storage/materialCard`,
      materialCard,options
    );
  }



export const getAddMaterialCardMutationOptions = <TData = Awaited<ReturnType<typeof addMaterialCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addMaterialCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMaterialCard>>, {data: MaterialCard}> = (props) => {
          const {data} = props ?? {};

          return  addMaterialCard(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: MaterialCard}, TContext>}

    export type AddMaterialCardMutationResult = NonNullable<Awaited<ReturnType<typeof addMaterialCard>>>
    export type AddMaterialCardMutationBody = MaterialCard
    export type AddMaterialCardMutationError = AxiosError<ErrorResponse>

    export const useAddMaterialCard = <TData = Awaited<ReturnType<typeof addMaterialCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: MaterialCard},
        TContext
      > => {

      const mutationOptions = getAddMaterialCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new FixtureGroup
 */
export const addFixtureGroup = (
    fixtureGroup: FixtureGroup, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FixtureGroup>> => {
    
    
    return axios.default.post(
      `/api/storage/fixtureGroup`,
      fixtureGroup,options
    );
  }



export const getAddFixtureGroupMutationOptions = <TData = Awaited<ReturnType<typeof addFixtureGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureGroup}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addFixtureGroup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFixtureGroup>>, {data: FixtureGroup}> = (props) => {
          const {data} = props ?? {};

          return  addFixtureGroup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FixtureGroup}, TContext>}

    export type AddFixtureGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addFixtureGroup>>>
    export type AddFixtureGroupMutationBody = FixtureGroup
    export type AddFixtureGroupMutationError = AxiosError<ErrorResponse>

    export const useAddFixtureGroup = <TData = Awaited<ReturnType<typeof addFixtureGroup>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: FixtureGroup},
        TContext
      > => {

      const mutationOptions = getAddFixtureGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new FixtureCard
 */
export const addFixtureCard = (
    fixtureCard: FixtureCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FixtureCard>> => {
    
    
    return axios.default.post(
      `/api/storage/fixtureCard`,
      fixtureCard,options
    );
  }



export const getAddFixtureCardMutationOptions = <TData = Awaited<ReturnType<typeof addFixtureCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addFixtureCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFixtureCard>>, {data: FixtureCard}> = (props) => {
          const {data} = props ?? {};

          return  addFixtureCard(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FixtureCard}, TContext>}

    export type AddFixtureCardMutationResult = NonNullable<Awaited<ReturnType<typeof addFixtureCard>>>
    export type AddFixtureCardMutationBody = FixtureCard
    export type AddFixtureCardMutationError = AxiosError<ErrorResponse>

    export const useAddFixtureCard = <TData = Awaited<ReturnType<typeof addFixtureCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: FixtureCard},
        TContext
      > => {

      const mutationOptions = getAddFixtureCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new AssignmentTransaction
 */
export const addAssignmentTransaction = (
    assignmentTransaction: AssignmentTransaction, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentTransaction>> => {
    
    
    return axios.default.post(
      `/api/storage/assignmentTransaction`,
      assignmentTransaction,options
    );
  }



export const getAddAssignmentTransactionMutationOptions = <TData = Awaited<ReturnType<typeof addAssignmentTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentTransaction}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addAssignmentTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAssignmentTransaction>>, {data: AssignmentTransaction}> = (props) => {
          const {data} = props ?? {};

          return  addAssignmentTransaction(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: AssignmentTransaction}, TContext>}

    export type AddAssignmentTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof addAssignmentTransaction>>>
    export type AddAssignmentTransactionMutationBody = AssignmentTransaction
    export type AddAssignmentTransactionMutationError = AxiosError<ErrorResponse>

    export const useAddAssignmentTransaction = <TData = Awaited<ReturnType<typeof addAssignmentTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentTransaction}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: AssignmentTransaction},
        TContext
      > => {

      const mutationOptions = getAddAssignmentTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new AssignmentCard
 */
export const addAssignmentCard = (
    assignmentCard: AssignmentCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentCard>> => {
    
    
    return axios.default.post(
      `/api/storage/assignmentCard`,
      assignmentCard,options
    );
  }



export const getAddAssignmentCardMutationOptions = <TData = Awaited<ReturnType<typeof addAssignmentCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addAssignmentCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAssignmentCard>>, {data: AssignmentCard}> = (props) => {
          const {data} = props ?? {};

          return  addAssignmentCard(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: AssignmentCard}, TContext>}

    export type AddAssignmentCardMutationResult = NonNullable<Awaited<ReturnType<typeof addAssignmentCard>>>
    export type AddAssignmentCardMutationBody = AssignmentCard
    export type AddAssignmentCardMutationError = AxiosError<ErrorResponse>

    export const useAddAssignmentCard = <TData = Awaited<ReturnType<typeof addAssignmentCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: AssignmentCard},
        TContext
      > => {

      const mutationOptions = getAddAssignmentCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Proposal
 */
export const addProposal = (
    proposal: Proposal, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Proposal>> => {
    
    
    return axios.default.post(
      `/api/sales/proposal`,
      proposal,options
    );
  }



export const getAddProposalMutationOptions = <TData = Awaited<ReturnType<typeof addProposal>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Proposal}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addProposal'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProposal>>, {data: Proposal}> = (props) => {
          const {data} = props ?? {};

          return  addProposal(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Proposal}, TContext>}

    export type AddProposalMutationResult = NonNullable<Awaited<ReturnType<typeof addProposal>>>
    export type AddProposalMutationBody = Proposal
    export type AddProposalMutationError = AxiosError<ErrorResponse>

    export const useAddProposal = <TData = Awaited<ReturnType<typeof addProposal>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Proposal}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Proposal},
        TContext
      > => {

      const mutationOptions = getAddProposalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new PurchaseOrder
 */
export const addPurchaseOrder = (
    purchaseOrder: PurchaseOrder, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PurchaseOrder>> => {
    
    
    return axios.default.post(
      `/api/purchasing/purchaseOrder`,
      purchaseOrder,options
    );
  }



export const getAddPurchaseOrderMutationOptions = <TData = Awaited<ReturnType<typeof addPurchaseOrder>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PurchaseOrder}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addPurchaseOrder'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPurchaseOrder>>, {data: PurchaseOrder}> = (props) => {
          const {data} = props ?? {};

          return  addPurchaseOrder(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: PurchaseOrder}, TContext>}

    export type AddPurchaseOrderMutationResult = NonNullable<Awaited<ReturnType<typeof addPurchaseOrder>>>
    export type AddPurchaseOrderMutationBody = PurchaseOrder
    export type AddPurchaseOrderMutationError = AxiosError<ErrorResponse>

    export const useAddPurchaseOrder = <TData = Awaited<ReturnType<typeof addPurchaseOrder>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PurchaseOrder}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: PurchaseOrder},
        TContext
      > => {

      const mutationOptions = getAddPurchaseOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Invoice
 */
export const addInvoice = (
    invoice: Invoice, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Invoice>> => {
    
    
    return axios.default.post(
      `/api/purchasing/invoice`,
      invoice,options
    );
  }



export const getAddInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof addInvoice>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addInvoice>>, {data: Invoice}> = (props) => {
          const {data} = props ?? {};

          return  addInvoice(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Invoice}, TContext>}

    export type AddInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof addInvoice>>>
    export type AddInvoiceMutationBody = Invoice
    export type AddInvoiceMutationError = AxiosError<ErrorResponse>

    export const useAddInvoice = <TData = Awaited<ReturnType<typeof addInvoice>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Invoice},
        TContext
      > => {

      const mutationOptions = getAddInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Invoice Total
 */
export const calculateInvoiceTotal = (
    invoice: Invoice, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InvoiceCalculationResult>> => {
    
    
    return axios.default.post(
      `/api/purchasing/invoice/calculateTotal`,
      invoice,options
    );
  }



export const getCalculateInvoiceTotalMutationOptions = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['calculateInvoiceTotal'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateInvoiceTotal>>, {data: Invoice}> = (props) => {
          const {data} = props ?? {};

          return  calculateInvoiceTotal(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Invoice}, TContext>}

    export type CalculateInvoiceTotalMutationResult = NonNullable<Awaited<ReturnType<typeof calculateInvoiceTotal>>>
    export type CalculateInvoiceTotalMutationBody = Invoice
    export type CalculateInvoiceTotalMutationError = AxiosError<ErrorResponse>

    export const useCalculateInvoiceTotal = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Invoice},
        TContext
      > => {

      const mutationOptions = getCalculateInvoiceTotalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Current Account
 */
export const addCurrentAccount = (
    currentAccount: CurrentAccount, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccount>> => {
    
    
    return axios.default.post(
      `/api/purchasing/currentAccount`,
      currentAccount,options
    );
  }



export const getAddCurrentAccountMutationOptions = <TData = Awaited<ReturnType<typeof addCurrentAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccount}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addCurrentAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCurrentAccount>>, {data: CurrentAccount}> = (props) => {
          const {data} = props ?? {};

          return  addCurrentAccount(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CurrentAccount}, TContext>}

    export type AddCurrentAccountMutationResult = NonNullable<Awaited<ReturnType<typeof addCurrentAccount>>>
    export type AddCurrentAccountMutationBody = CurrentAccount
    export type AddCurrentAccountMutationError = AxiosError<ErrorResponse>

    export const useAddCurrentAccount = <TData = Awaited<ReturnType<typeof addCurrentAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccount}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: CurrentAccount},
        TContext
      > => {

      const mutationOptions = getAddCurrentAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Current Account Transaction
 */
export const addCurrentAccountTransaction = (
    currentAccountTransaction: CurrentAccountTransaction, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccountTransaction>> => {
    
    
    return axios.default.post(
      `/api/purchasing/currentAccountTransaction`,
      currentAccountTransaction,options
    );
  }



export const getAddCurrentAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof addCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountTransaction}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addCurrentAccountTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCurrentAccountTransaction>>, {data: CurrentAccountTransaction}> = (props) => {
          const {data} = props ?? {};

          return  addCurrentAccountTransaction(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CurrentAccountTransaction}, TContext>}

    export type AddCurrentAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof addCurrentAccountTransaction>>>
    export type AddCurrentAccountTransactionMutationBody = CurrentAccountTransaction
    export type AddCurrentAccountTransactionMutationError = AxiosError<ErrorResponse>

    export const useAddCurrentAccountTransaction = <TData = Awaited<ReturnType<typeof addCurrentAccountTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountTransaction}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: CurrentAccountTransaction},
        TContext
      > => {

      const mutationOptions = getAddCurrentAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new CurrentAccountBankAccount
 */
export const addCurrentAccountBankAccount = (
    currentAccountBankAccount: CurrentAccountBankAccount, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CurrentAccountBankAccount>> => {
    
    
    return axios.default.post(
      `/api/purchasing/currentAccountBankAccount`,
      currentAccountBankAccount,options
    );
  }



export const getAddCurrentAccountBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof addCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountBankAccount}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addCurrentAccountBankAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCurrentAccountBankAccount>>, {data: CurrentAccountBankAccount}> = (props) => {
          const {data} = props ?? {};

          return  addCurrentAccountBankAccount(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CurrentAccountBankAccount}, TContext>}

    export type AddCurrentAccountBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof addCurrentAccountBankAccount>>>
    export type AddCurrentAccountBankAccountMutationBody = CurrentAccountBankAccount
    export type AddCurrentAccountBankAccountMutationError = AxiosError<ErrorResponse>

    export const useAddCurrentAccountBankAccount = <TData = Awaited<ReturnType<typeof addCurrentAccountBankAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountBankAccount}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: CurrentAccountBankAccount},
        TContext
      > => {

      const mutationOptions = getAddCurrentAccountBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new AdditionalCost
 */
export const addAdditionalCost = (
    additionalCost: AdditionalCost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdditionalCost>> => {
    
    
    return axios.default.post(
      `/api/purchasing/additionalCost`,
      additionalCost,options
    );
  }



export const getAddAdditionalCostMutationOptions = <TData = Awaited<ReturnType<typeof addAdditionalCost>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AdditionalCost}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addAdditionalCost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAdditionalCost>>, {data: AdditionalCost}> = (props) => {
          const {data} = props ?? {};

          return  addAdditionalCost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: AdditionalCost}, TContext>}

    export type AddAdditionalCostMutationResult = NonNullable<Awaited<ReturnType<typeof addAdditionalCost>>>
    export type AddAdditionalCostMutationBody = AdditionalCost
    export type AddAdditionalCostMutationError = AxiosError<ErrorResponse>

    export const useAddAdditionalCost = <TData = Awaited<ReturnType<typeof addAdditionalCost>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AdditionalCost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: AdditionalCost},
        TContext
      > => {

      const mutationOptions = getAddAdditionalCostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Project
 */
export const addProject = (
    project: Project, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Project>> => {
    
    
    return axios.default.post(
      `/api/production/project`,
      project,options
    );
  }



export const getAddProjectMutationOptions = <TData = Awaited<ReturnType<typeof addProject>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Project}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addProject'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProject>>, {data: Project}> = (props) => {
          const {data} = props ?? {};

          return  addProject(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Project}, TContext>}

    export type AddProjectMutationResult = NonNullable<Awaited<ReturnType<typeof addProject>>>
    export type AddProjectMutationBody = Project
    export type AddProjectMutationError = AxiosError<ErrorResponse>

    export const useAddProject = <TData = Awaited<ReturnType<typeof addProject>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Project}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Project},
        TContext
      > => {

      const mutationOptions = getAddProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create new Time Keeping
 */
export const createTimeKeeping = (
    timeKeeping: TimeKeeping, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeKeeping>> => {
    
    
    return axios.default.post(
      `/api/hr/timekeeping`,
      timeKeeping,options
    );
  }



export const getCreateTimeKeepingMutationOptions = <TData = Awaited<ReturnType<typeof createTimeKeeping>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['createTimeKeeping'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTimeKeeping>>, {data: TimeKeeping}> = (props) => {
          const {data} = props ?? {};

          return  createTimeKeeping(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>}

    export type CreateTimeKeepingMutationResult = NonNullable<Awaited<ReturnType<typeof createTimeKeeping>>>
    export type CreateTimeKeepingMutationBody = TimeKeeping
    export type CreateTimeKeepingMutationError = AxiosError<ErrorResponse>

    export const useCreateTimeKeeping = <TData = Awaited<ReturnType<typeof createTimeKeeping>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: TimeKeeping},
        TContext
      > => {

      const mutationOptions = getCreateTimeKeepingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Time Keeping Total
 */
export const calculateTimeKeepingTotal = (
    timeKeeping: TimeKeeping, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeKeepingCalculationResult>> => {
    
    
    return axios.default.post(
      `/api/hr/timekeeping/calculateTotal`,
      timeKeeping,options
    );
  }



export const getCalculateTimeKeepingTotalMutationOptions = <TData = Awaited<ReturnType<typeof calculateTimeKeepingTotal>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['calculateTimeKeepingTotal'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateTimeKeepingTotal>>, {data: TimeKeeping}> = (props) => {
          const {data} = props ?? {};

          return  calculateTimeKeepingTotal(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>}

    export type CalculateTimeKeepingTotalMutationResult = NonNullable<Awaited<ReturnType<typeof calculateTimeKeepingTotal>>>
    export type CalculateTimeKeepingTotalMutationBody = TimeKeeping
    export type CalculateTimeKeepingTotalMutationError = AxiosError<ErrorResponse>

    export const useCalculateTimeKeepingTotal = <TData = Awaited<ReturnType<typeof calculateTimeKeepingTotal>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: TimeKeeping},
        TContext
      > => {

      const mutationOptions = getCalculateTimeKeepingTotalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Employee
 */
export const addEmployee = (
    employee: Employee, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Employee>> => {
    
    
    return axios.default.post(
      `/api/hr/employee`,
      employee,options
    );
  }



export const getAddEmployeeMutationOptions = <TData = Awaited<ReturnType<typeof addEmployee>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Employee}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addEmployee'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addEmployee>>, {data: Employee}> = (props) => {
          const {data} = props ?? {};

          return  addEmployee(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Employee}, TContext>}

    export type AddEmployeeMutationResult = NonNullable<Awaited<ReturnType<typeof addEmployee>>>
    export type AddEmployeeMutationBody = Employee
    export type AddEmployeeMutationError = AxiosError<ErrorResponse>

    export const useAddEmployee = <TData = Awaited<ReturnType<typeof addEmployee>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Employee}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Employee},
        TContext
      > => {

      const mutationOptions = getAddEmployeeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new TimeOff
 */
export const addTimeOff = (
    id: number,
    timeOff: TimeOff, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeOff>> => {
    
    
    return axios.default.post(
      `/api/hr/employee/${id}/timeoff`,
      timeOff,options
    );
  }



export const getAddTimeOffMutationOptions = <TData = Awaited<ReturnType<typeof addTimeOff>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeOff}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addTimeOff'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTimeOff>>, {id: number;data: TimeOff}> = (props) => {
          const {id,data} = props ?? {};

          return  addTimeOff(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: TimeOff}, TContext>}

    export type AddTimeOffMutationResult = NonNullable<Awaited<ReturnType<typeof addTimeOff>>>
    export type AddTimeOffMutationBody = TimeOff
    export type AddTimeOffMutationError = AxiosError<ErrorResponse>

    export const useAddTimeOff = <TData = Awaited<ReturnType<typeof addTimeOff>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeOff}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: TimeOff},
        TContext
      > => {

      const mutationOptions = getAddTimeOffMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * EmployeePayments view. Supports filtering via rsql using Employee.
 */
export const employeePaymentsStatusView = (
    filteringRequest: FilteringRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EmployeePayments>> => {
    
    
    return axios.default.post(
      `/api/hr/employee/payments`,
      filteringRequest,options
    );
  }



export const getEmployeePaymentsStatusViewMutationOptions = <TData = Awaited<ReturnType<typeof employeePaymentsStatusView>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['employeePaymentsStatusView'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof employeePaymentsStatusView>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  employeePaymentsStatusView(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type EmployeePaymentsStatusViewMutationResult = NonNullable<Awaited<ReturnType<typeof employeePaymentsStatusView>>>
    export type EmployeePaymentsStatusViewMutationBody = FilteringRequest
    export type EmployeePaymentsStatusViewMutationError = AxiosError<ErrorResponse>

    export const useEmployeePaymentsStatusView = <TData = Awaited<ReturnType<typeof employeePaymentsStatusView>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getEmployeePaymentsStatusViewMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * EmployeeOvertimes view. Supports filtering via rsql using Employee.
 */
export const employeeOvertimesStatusView = (
    filteringRequest: FilteringRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EmployeeOvertimes>> => {
    
    
    return axios.default.post(
      `/api/hr/employee/overtimes`,
      filteringRequest,options
    );
  }



export const getEmployeeOvertimesStatusViewMutationOptions = <TData = Awaited<ReturnType<typeof employeeOvertimesStatusView>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['employeeOvertimesStatusView'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof employeeOvertimesStatusView>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  employeeOvertimesStatusView(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type EmployeeOvertimesStatusViewMutationResult = NonNullable<Awaited<ReturnType<typeof employeeOvertimesStatusView>>>
    export type EmployeeOvertimesStatusViewMutationBody = FilteringRequest
    export type EmployeeOvertimesStatusViewMutationError = AxiosError<ErrorResponse>

    export const useEmployeeOvertimesStatusView = <TData = Awaited<ReturnType<typeof employeeOvertimesStatusView>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getEmployeeOvertimesStatusViewMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Bank
 */
export const addBank = (
    bank: Bank, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Bank>> => {
    
    
    return axios.default.post(
      `/api/finance/bank`,
      bank,options
    );
  }



export const getAddBankMutationOptions = <TData = Awaited<ReturnType<typeof addBank>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Bank}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addBank'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBank>>, {data: Bank}> = (props) => {
          const {data} = props ?? {};

          return  addBank(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Bank}, TContext>}

    export type AddBankMutationResult = NonNullable<Awaited<ReturnType<typeof addBank>>>
    export type AddBankMutationBody = Bank
    export type AddBankMutationError = AxiosError<ErrorResponse>

    export const useAddBank = <TData = Awaited<ReturnType<typeof addBank>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Bank}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Bank},
        TContext
      > => {

      const mutationOptions = getAddBankMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Bank Branch
 */
export const addBankBranch = (
    bankBranch: BankBranch, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BankBranch>> => {
    
    
    return axios.default.post(
      `/api/finance/bankBranch`,
      bankBranch,options
    );
  }



export const getAddBankBranchMutationOptions = <TData = Awaited<ReturnType<typeof addBankBranch>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankBranch}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addBankBranch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBankBranch>>, {data: BankBranch}> = (props) => {
          const {data} = props ?? {};

          return  addBankBranch(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BankBranch}, TContext>}

    export type AddBankBranchMutationResult = NonNullable<Awaited<ReturnType<typeof addBankBranch>>>
    export type AddBankBranchMutationBody = BankBranch
    export type AddBankBranchMutationError = AxiosError<ErrorResponse>

    export const useAddBankBranch = <TData = Awaited<ReturnType<typeof addBankBranch>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankBranch}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: BankBranch},
        TContext
      > => {

      const mutationOptions = getAddBankBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Bank Account
 */
export const addBankBranch1 = (
    bankAccount: BankAccount, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BankAccount>> => {
    
    
    return axios.default.post(
      `/api/finance/bankAccount`,
      bankAccount,options
    );
  }



export const getAddBankBranch1MutationOptions = <TData = Awaited<ReturnType<typeof addBankBranch1>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankAccount}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addBankBranch1'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBankBranch1>>, {data: BankAccount}> = (props) => {
          const {data} = props ?? {};

          return  addBankBranch1(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BankAccount}, TContext>}

    export type AddBankBranch1MutationResult = NonNullable<Awaited<ReturnType<typeof addBankBranch1>>>
    export type AddBankBranch1MutationBody = BankAccount
    export type AddBankBranch1MutationError = AxiosError<ErrorResponse>

    export const useAddBankBranch1 = <TData = Awaited<ReturnType<typeof addBankBranch1>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankAccount}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: BankAccount},
        TContext
      > => {

      const mutationOptions = getAddBankBranch1MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Department
 */
export const addDepartment = (
    department: Department, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Department>> => {
    
    
    return axios.default.post(
      `/api/company/department`,
      department,options
    );
  }



export const getAddDepartmentMutationOptions = <TData = Awaited<ReturnType<typeof addDepartment>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Department}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addDepartment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addDepartment>>, {data: Department}> = (props) => {
          const {data} = props ?? {};

          return  addDepartment(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Department}, TContext>}

    export type AddDepartmentMutationResult = NonNullable<Awaited<ReturnType<typeof addDepartment>>>
    export type AddDepartmentMutationBody = Department
    export type AddDepartmentMutationError = AxiosError<ErrorResponse>

    export const useAddDepartment = <TData = Awaited<ReturnType<typeof addDepartment>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Department}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Department},
        TContext
      > => {

      const mutationOptions = getAddDepartmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Branch
 */
export const addBranch = (
    branch: Branch, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Branch>> => {
    
    
    return axios.default.post(
      `/api/company/branch`,
      branch,options
    );
  }



export const getAddBranchMutationOptions = <TData = Awaited<ReturnType<typeof addBranch>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Branch}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addBranch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBranch>>, {data: Branch}> = (props) => {
          const {data} = props ?? {};

          return  addBranch(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Branch}, TContext>}

    export type AddBranchMutationResult = NonNullable<Awaited<ReturnType<typeof addBranch>>>
    export type AddBranchMutationBody = Branch
    export type AddBranchMutationError = AxiosError<ErrorResponse>

    export const useAddBranch = <TData = Awaited<ReturnType<typeof addBranch>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Branch}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Branch},
        TContext
      > => {

      const mutationOptions = getAddBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Section
 */
export const addSection = (
    section: Section, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Section>> => {
    
    
    return axios.default.post(
      `/api/admin/section`,
      section,options
    );
  }



export const getAddSectionMutationOptions = <TData = Awaited<ReturnType<typeof addSection>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Section}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addSection'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addSection>>, {data: Section}> = (props) => {
          const {data} = props ?? {};

          return  addSection(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Section}, TContext>}

    export type AddSectionMutationResult = NonNullable<Awaited<ReturnType<typeof addSection>>>
    export type AddSectionMutationBody = Section
    export type AddSectionMutationError = AxiosError<ErrorResponse>

    export const useAddSection = <TData = Awaited<ReturnType<typeof addSection>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Section}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Section},
        TContext
      > => {

      const mutationOptions = getAddSectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Role
 */
export const addRole = (
    role: Role, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Role>> => {
    
    
    return axios.default.post(
      `/api/admin/role`,
      role,options
    );
  }



export const getAddRoleMutationOptions = <TData = Awaited<ReturnType<typeof addRole>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Role}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addRole>>, {data: Role}> = (props) => {
          const {data} = props ?? {};

          return  addRole(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Role}, TContext>}

    export type AddRoleMutationResult = NonNullable<Awaited<ReturnType<typeof addRole>>>
    export type AddRoleMutationBody = Role
    export type AddRoleMutationError = AxiosError<ErrorResponse>

    export const useAddRole = <TData = Awaited<ReturnType<typeof addRole>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Role}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Role},
        TContext
      > => {

      const mutationOptions = getAddRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Public Holiday
 */
export const addPublicHoliday = (
    publicHoliday: PublicHoliday, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PublicHoliday>> => {
    
    
    return axios.default.post(
      `/api/admin/publicHoliday`,
      publicHoliday,options
    );
  }



export const getAddPublicHolidayMutationOptions = <TData = Awaited<ReturnType<typeof addPublicHoliday>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PublicHoliday}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addPublicHoliday'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPublicHoliday>>, {data: PublicHoliday}> = (props) => {
          const {data} = props ?? {};

          return  addPublicHoliday(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: PublicHoliday}, TContext>}

    export type AddPublicHolidayMutationResult = NonNullable<Awaited<ReturnType<typeof addPublicHoliday>>>
    export type AddPublicHolidayMutationBody = PublicHoliday
    export type AddPublicHolidayMutationError = AxiosError<ErrorResponse>

    export const useAddPublicHoliday = <TData = Awaited<ReturnType<typeof addPublicHoliday>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PublicHoliday}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: PublicHoliday},
        TContext
      > => {

      const mutationOptions = getAddPublicHolidayMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new PaymentMethod
 */
export const addPaymentMethod = (
    paymentMethod: PaymentMethod, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaymentMethod>> => {
    
    
    return axios.default.post(
      `/api/admin/paymentMethod`,
      paymentMethod,options
    );
  }



export const getAddPaymentMethodMutationOptions = <TData = Awaited<ReturnType<typeof addPaymentMethod>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PaymentMethod}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addPaymentMethod'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPaymentMethod>>, {data: PaymentMethod}> = (props) => {
          const {data} = props ?? {};

          return  addPaymentMethod(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: PaymentMethod}, TContext>}

    export type AddPaymentMethodMutationResult = NonNullable<Awaited<ReturnType<typeof addPaymentMethod>>>
    export type AddPaymentMethodMutationBody = PaymentMethod
    export type AddPaymentMethodMutationError = AxiosError<ErrorResponse>

    export const useAddPaymentMethod = <TData = Awaited<ReturnType<typeof addPaymentMethod>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PaymentMethod}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: PaymentMethod},
        TContext
      > => {

      const mutationOptions = getAddPaymentMethodMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Machine
 */
export const addMachine = (
    machine: Machine, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Machine>> => {
    
    
    return axios.default.post(
      `/api/admin/machine`,
      machine,options
    );
  }



export const getAddMachineMutationOptions = <TData = Awaited<ReturnType<typeof addMachine>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Machine}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addMachine'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMachine>>, {data: Machine}> = (props) => {
          const {data} = props ?? {};

          return  addMachine(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Machine}, TContext>}

    export type AddMachineMutationResult = NonNullable<Awaited<ReturnType<typeof addMachine>>>
    export type AddMachineMutationBody = Machine
    export type AddMachineMutationError = AxiosError<ErrorResponse>

    export const useAddMachine = <TData = Awaited<ReturnType<typeof addMachine>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Machine}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Machine},
        TContext
      > => {

      const mutationOptions = getAddMachineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Depot
 */
export const addDepot = (
    depot: Depot, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Depot>> => {
    
    
    return axios.default.post(
      `/api/admin/depot`,
      depot,options
    );
  }



export const getAddDepotMutationOptions = <TData = Awaited<ReturnType<typeof addDepot>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Depot}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addDepot'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addDepot>>, {data: Depot}> = (props) => {
          const {data} = props ?? {};

          return  addDepot(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Depot}, TContext>}

    export type AddDepotMutationResult = NonNullable<Awaited<ReturnType<typeof addDepot>>>
    export type AddDepotMutationBody = Depot
    export type AddDepotMutationError = AxiosError<ErrorResponse>

    export const useAddDepot = <TData = Awaited<ReturnType<typeof addDepot>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Depot}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Depot},
        TContext
      > => {

      const mutationOptions = getAddDepotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Company
 */
export const addCompany = (
    company: Company, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Company>> => {
    
    
    return axios.default.post(
      `/api/admin/company`,
      company,options
    );
  }



export const getAddCompanyMutationOptions = <TData = Awaited<ReturnType<typeof addCompany>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Company}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addCompany'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCompany>>, {data: Company}> = (props) => {
          const {data} = props ?? {};

          return  addCompany(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Company}, TContext>}

    export type AddCompanyMutationResult = NonNullable<Awaited<ReturnType<typeof addCompany>>>
    export type AddCompanyMutationBody = Company
    export type AddCompanyMutationError = AxiosError<ErrorResponse>

    export const useAddCompany = <TData = Awaited<ReturnType<typeof addCompany>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Company}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Company},
        TContext
      > => {

      const mutationOptions = getAddCompanyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ExpenseInvoice
 */
export const addExpenseInvoice = (
    expenseInvoice: ExpenseInvoice, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExpenseInvoice>> => {
    
    
    return axios.default.post(
      `/api/accounting/expenseInvoice`,
      expenseInvoice,options
    );
  }



export const getAddExpenseInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof addExpenseInvoice>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addExpenseInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addExpenseInvoice>>, {data: ExpenseInvoice}> = (props) => {
          const {data} = props ?? {};

          return  addExpenseInvoice(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>}

    export type AddExpenseInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof addExpenseInvoice>>>
    export type AddExpenseInvoiceMutationBody = ExpenseInvoice
    export type AddExpenseInvoiceMutationError = AxiosError<ErrorResponse>

    export const useAddExpenseInvoice = <TData = Awaited<ReturnType<typeof addExpenseInvoice>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: ExpenseInvoice},
        TContext
      > => {

      const mutationOptions = getAddExpenseInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Invoice Total
 */
export const calculateInvoiceTotal1 = (
    expenseInvoice: ExpenseInvoice, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExpenseInvoiceCalculationResult>> => {
    
    
    return axios.default.post(
      `/api/accounting/expenseInvoice/calculateTotal`,
      expenseInvoice,options
    );
  }



export const getCalculateInvoiceTotal1MutationOptions = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal1>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['calculateInvoiceTotal1'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateInvoiceTotal1>>, {data: ExpenseInvoice}> = (props) => {
          const {data} = props ?? {};

          return  calculateInvoiceTotal1(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>}

    export type CalculateInvoiceTotal1MutationResult = NonNullable<Awaited<ReturnType<typeof calculateInvoiceTotal1>>>
    export type CalculateInvoiceTotal1MutationBody = ExpenseInvoice
    export type CalculateInvoiceTotal1MutationError = AxiosError<ErrorResponse>

    export const useCalculateInvoiceTotal1 = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal1>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: ExpenseInvoice},
        TContext
      > => {

      const mutationOptions = getCalculateInvoiceTotal1MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ExpenseCard
 */
export const addExpenseCard = (
    expenseCard: ExpenseCard, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExpenseCard>> => {
    
    
    return axios.default.post(
      `/api/accounting/expenseCard`,
      expenseCard,options
    );
  }



export const getAddExpenseCardMutationOptions = <TData = Awaited<ReturnType<typeof addExpenseCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseCard}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addExpenseCard'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addExpenseCard>>, {data: ExpenseCard}> = (props) => {
          const {data} = props ?? {};

          return  addExpenseCard(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ExpenseCard}, TContext>}

    export type AddExpenseCardMutationResult = NonNullable<Awaited<ReturnType<typeof addExpenseCard>>>
    export type AddExpenseCardMutationBody = ExpenseCard
    export type AddExpenseCardMutationError = AxiosError<ErrorResponse>

    export const useAddExpenseCard = <TData = Awaited<ReturnType<typeof addExpenseCard>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseCard}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: ExpenseCard},
        TContext
      > => {

      const mutationOptions = getAddExpenseCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new CashAccount
 */
export const addCashAccount = (
    cashAccount: CashAccount, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CashAccount>> => {
    
    
    return axios.default.post(
      `/api/accounting/cashAccount`,
      cashAccount,options
    );
  }



export const getAddCashAccountMutationOptions = <TData = Awaited<ReturnType<typeof addCashAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccount}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addCashAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCashAccount>>, {data: CashAccount}> = (props) => {
          const {data} = props ?? {};

          return  addCashAccount(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CashAccount}, TContext>}

    export type AddCashAccountMutationResult = NonNullable<Awaited<ReturnType<typeof addCashAccount>>>
    export type AddCashAccountMutationBody = CashAccount
    export type AddCashAccountMutationError = AxiosError<ErrorResponse>

    export const useAddCashAccount = <TData = Awaited<ReturnType<typeof addCashAccount>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccount}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: CashAccount},
        TContext
      > => {

      const mutationOptions = getAddCashAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new CashAccountTransaction
 */
export const addCashAccountTransaction = (
    cashAccountTransaction: CashAccountTransaction, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CashAccountTransaction>> => {
    
    
    return axios.default.post(
      `/api/accounting/cashAccountTransaction`,
      cashAccountTransaction,options
    );
  }



export const getAddCashAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof addCashAccountTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransaction}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['addCashAccountTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCashAccountTransaction>>, {data: CashAccountTransaction}> = (props) => {
          const {data} = props ?? {};

          return  addCashAccountTransaction(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CashAccountTransaction}, TContext>}

    export type AddCashAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof addCashAccountTransaction>>>
    export type AddCashAccountTransactionMutationBody = CashAccountTransaction
    export type AddCashAccountTransactionMutationError = AxiosError<ErrorResponse>

    export const useAddCashAccountTransaction = <TData = Awaited<ReturnType<typeof addCashAccountTransaction>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransaction}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: CashAccountTransaction},
        TContext
      > => {

      const mutationOptions = getAddCashAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Balance
 */
export const calculateBalance = (
    cashAccountTransactionEntity: CashAccountTransactionEntity[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CashAccountBalanceResult>> => {
    
    
    return axios.default.post(
      `/api/accounting/accounting/calculateBalance`,
      cashAccountTransactionEntity,options
    );
  }



export const getCalculateBalanceMutationOptions = <TData = Awaited<ReturnType<typeof calculateBalance>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransactionEntity[]}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['calculateBalance'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateBalance>>, {data: CashAccountTransactionEntity[]}> = (props) => {
          const {data} = props ?? {};

          return  calculateBalance(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CashAccountTransactionEntity[]}, TContext>}

    export type CalculateBalanceMutationResult = NonNullable<Awaited<ReturnType<typeof calculateBalance>>>
    export type CalculateBalanceMutationBody = CashAccountTransactionEntity[]
    export type CalculateBalanceMutationError = AxiosError<ErrorResponse>

    export const useCalculateBalance = <TData = Awaited<ReturnType<typeof calculateBalance>>, TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransactionEntity[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: CashAccountTransactionEntity[]},
        TContext
      > => {

      const mutationOptions = getCalculateBalanceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ServiceGroup Tree
 */
export const getServiceGroupTree = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ServiceGroupTreeDataResponse>> => {
    
    
    return axios.default.get(
      `/api/storage/serviceGroup/tree`,options
    );
  }


export const getGetServiceGroupTreeQueryKey = () => {
    return [`/api/storage/serviceGroup/tree`] as const;
    }

    
export const getGetServiceGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroupTree>>> = ({ signal }) => getServiceGroupTree({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroupTree>>>
export type GetServiceGroupTreeQueryError = AxiosError<unknown>


export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroupTree>>> = ({ signal }) => getServiceGroupTree({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroupTree>>>
export type GetServiceGroupTreeSuspenseQueryError = AxiosError<unknown>


export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get Service Group Flat List
 */
export const getServiceGroupFlatList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ServiceGroupTreeDataResponse>> => {
    
    
    return axios.default.get(
      `/api/storage/serviceGroup/flatList`,options
    );
  }


export const getGetServiceGroupFlatListQueryKey = () => {
    return [`/api/storage/serviceGroup/flatList`] as const;
    }

    
export const getGetServiceGroupFlatListQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroupFlatList>>> = ({ signal }) => getServiceGroupFlatList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupFlatListQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroupFlatList>>>
export type GetServiceGroupFlatListQueryError = AxiosError<unknown>


export function useGetServiceGroupFlatList<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupFlatList<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupFlatList<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupFlatList<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupFlatListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceGroupFlatListSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroupFlatList>>> = ({ signal }) => getServiceGroupFlatList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupFlatListSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroupFlatList>>>
export type GetServiceGroupFlatListSuspenseQueryError = AxiosError<unknown>


export function useGetServiceGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupFlatListSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get ProductGroup Tree
 */
export const getProductGroupTree = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProductGroupTreeDataResponse>> => {
    
    
    return axios.default.get(
      `/api/storage/productGroup/tree`,options
    );
  }


export const getGetProductGroupTreeQueryKey = () => {
    return [`/api/storage/productGroup/tree`] as const;
    }

    
export const getGetProductGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroupTree>>> = ({ signal }) => getProductGroupTree({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroupTree>>>
export type GetProductGroupTreeQueryError = AxiosError<unknown>


export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroupTree>>> = ({ signal }) => getProductGroupTree({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroupTree>>>
export type GetProductGroupTreeSuspenseQueryError = AxiosError<unknown>


export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get ProductGroup Flat List
 */
export const getProductGroupFlatList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProductGroupTreeDataResponse>> => {
    
    
    return axios.default.get(
      `/api/storage/productGroup/flatList`,options
    );
  }


export const getGetProductGroupFlatListQueryKey = () => {
    return [`/api/storage/productGroup/flatList`] as const;
    }

    
export const getGetProductGroupFlatListQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroupFlatList>>> = ({ signal }) => getProductGroupFlatList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupFlatListQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroupFlatList>>>
export type GetProductGroupFlatListQueryError = AxiosError<unknown>


export function useGetProductGroupFlatList<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupFlatList<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupFlatList<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupFlatList<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupFlatListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductGroupFlatListSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroupFlatList>>> = ({ signal }) => getProductGroupFlatList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupFlatListSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroupFlatList>>>
export type GetProductGroupFlatListSuspenseQueryError = AxiosError<unknown>


export function useGetProductGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getProductGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupFlatListSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get MaterialGroup Tree
 */
export const getMaterialGroupTree = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MaterialGroupTreeDataResponse>> => {
    

    return axios.default.get(
      `/api/storage/materialGroup/tree`,options
    );
  }


export const getGetMaterialGroupTreeQueryKey = () => {
    return [`/api/storage/materialGroup/tree`] as const;
    }

    
export const getGetMaterialGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroupTree>>> = ({ signal }) => getMaterialGroupTree({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroupTree>>>
export type GetMaterialGroupTreeQueryError = AxiosError<unknown>


export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroupTree>>> = ({ signal }) => getMaterialGroupTree({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroupTree>>>
export type GetMaterialGroupTreeSuspenseQueryError = AxiosError<unknown>


export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get MaterialGroup Flat List
 */
export const getMaterialGroupFlatList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MaterialGroupTreeDataResponse>> => {
    
    
    return axios.default.get(
      `/api/storage/materialGroup/flatList`,options
    );
  }


export const getGetMaterialGroupFlatListQueryKey = () => {
    return [`/api/storage/materialGroup/flatList`] as const;
    }

    
export const getGetMaterialGroupFlatListQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroupFlatList>>> = ({ signal }) => getMaterialGroupFlatList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupFlatListQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroupFlatList>>>
export type GetMaterialGroupFlatListQueryError = AxiosError<unknown>


export function useGetMaterialGroupFlatList<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupFlatList<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupFlatList<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupFlatList<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupFlatListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialGroupFlatListSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroupFlatList>>> = ({ signal }) => getMaterialGroupFlatList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupFlatListSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroupFlatList>>>
export type GetMaterialGroupFlatListSuspenseQueryError = AxiosError<unknown>


export function useGetMaterialGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupFlatListSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get FixtureGroup Tree
 */
export const getFixtureGroupTree = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FixtureGroupTreeDataResponse>> => {
    
    
    return axios.default.get(
      `/api/storage/fixtureGroup/tree`,options
    );
  }


export const getGetFixtureGroupTreeQueryKey = () => {
    return [`/api/storage/fixtureGroup/tree`] as const;
    }

    
export const getGetFixtureGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroupTree>>> = ({ signal }) => getFixtureGroupTree({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroupTree>>>
export type GetFixtureGroupTreeQueryError = AxiosError<unknown>


export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFixtureGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroupTree>>> = ({ signal }) => getFixtureGroupTree({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroupTree>>>
export type GetFixtureGroupTreeSuspenseQueryError = AxiosError<unknown>


export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get FixtureGroup Flat List
 */
export const getFixtureGroupFlatList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FixtureGroupTreeDataResponse>> => {
    
    
    return axios.default.get(
      `/api/storage/fixtureGroup/flatList`,options
    );
  }


export const getGetFixtureGroupFlatListQueryKey = () => {
    return [`/api/storage/fixtureGroup/flatList`] as const;
    }

    
export const getGetFixtureGroupFlatListQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroupFlatList>>> = ({ signal }) => getFixtureGroupFlatList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupFlatListQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroupFlatList>>>
export type GetFixtureGroupFlatListQueryError = AxiosError<unknown>


export function useGetFixtureGroupFlatList<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupFlatList<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroupFlatList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupFlatList<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupFlatList<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupFlatListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFixtureGroupFlatListSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupFlatListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroupFlatList>>> = ({ signal }) => getFixtureGroupFlatList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupFlatListSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroupFlatList>>>
export type GetFixtureGroupFlatListSuspenseQueryError = AxiosError<unknown>


export function useGetFixtureGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupFlatListSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupFlatList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupFlatListSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get Draft Time Keeping for Employee
 */
export const getTimeKeepingDraft = (
    id: number,
    year: number,
    month: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeKeeping>> => {
    
    
    return axios.default.get(
      `/api/hr/timekeeping/draft/employee/${id}/year/${year}/month/${month}`,options
    );
  }


export const getGetTimeKeepingDraftQueryKey = (id: number,
    year: number,
    month: number,) => {
    return [`/api/hr/timekeeping/draft/employee/${id}/year/${year}/month/${month}`] as const;
    }

    
export const getGetTimeKeepingDraftQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = AxiosError<ErrorResponse>>(id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingDraftQueryKey(id,year,month);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeepingDraft>>> = ({ signal }) => getTimeKeepingDraft(id,year,month, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && year && month), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingDraftQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeepingDraft>>>
export type GetTimeKeepingDraftQueryError = AxiosError<ErrorResponse>


export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = AxiosError<ErrorResponse>>(
 id: number,
    year: number,
    month: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeepingDraft>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = AxiosError<ErrorResponse>>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeepingDraft>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = AxiosError<ErrorResponse>>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = AxiosError<ErrorResponse>>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingDraftQueryOptions(id,year,month,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeKeepingDraftSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = AxiosError<ErrorResponse>>(id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingDraftQueryKey(id,year,month);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeepingDraft>>> = ({ signal }) => getTimeKeepingDraft(id,year,month, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingDraftSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeepingDraft>>>
export type GetTimeKeepingDraftSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = AxiosError<ErrorResponse>>(
 id: number,
    year: number,
    month: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = AxiosError<ErrorResponse>>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = AxiosError<ErrorResponse>>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = AxiosError<ErrorResponse>>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingDraftSuspenseQueryOptions(id,year,month,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get TimeOff Status
 */
export const getTimeOffStatus = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimeOffStatus>> => {
    
    
    return axios.default.get(
      `/api/hr/employee/${id}/timeoffstatus`,options
    );
  }


export const getGetTimeOffStatusQueryKey = (id: number,) => {
    return [`/api/hr/employee/${id}/timeoffstatus`] as const;
    }

    
export const getGetTimeOffStatusQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffStatusQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOffStatus>>> = ({ signal }) => getTimeOffStatus(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOffStatus>>>
export type GetTimeOffStatusQueryError = AxiosError<ErrorResponse>


export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOffStatus>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOffStatus>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffStatusQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeOffStatusSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = AxiosError<ErrorResponse>>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffStatusQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOffStatus>>> = ({ signal }) => getTimeOffStatus(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffStatusSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOffStatus>>>
export type GetTimeOffStatusSuspenseQueryError = AxiosError<ErrorResponse>


export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = AxiosError<ErrorResponse>>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = AxiosError<ErrorResponse>>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffStatusSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get Employee Payment
 */
export const getEmployeePayment = (
    id: number,
    employeePaymentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EmployeePayment>> => {
    
    
    return axios.default.get(
      `/api/hr/employee/${id}/payment/${employeePaymentId}`,options
    );
  }


export const getGetEmployeePaymentQueryKey = (id: number,
    employeePaymentId: number,) => {
    return [`/api/hr/employee/${id}/payment/${employeePaymentId}`] as const;
    }

    
export const getGetEmployeePaymentQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = AxiosError<unknown>>(id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeePaymentQueryKey(id,employeePaymentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeePayment>>> = ({ signal }) => getEmployeePayment(id,employeePaymentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && employeePaymentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeePaymentQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeePayment>>>
export type GetEmployeePaymentQueryError = AxiosError<unknown>


export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = AxiosError<unknown>>(
 id: number,
    employeePaymentId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeePayment>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = AxiosError<unknown>>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeePayment>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = AxiosError<unknown>>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = AxiosError<unknown>>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeePaymentQueryOptions(id,employeePaymentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetEmployeePaymentSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = AxiosError<unknown>>(id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeePaymentQueryKey(id,employeePaymentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeePayment>>> = ({ signal }) => getEmployeePayment(id,employeePaymentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeePaymentSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeePayment>>>
export type GetEmployeePaymentSuspenseQueryError = AxiosError<unknown>


export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = AxiosError<unknown>>(
 id: number,
    employeePaymentId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = AxiosError<unknown>>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = AxiosError<unknown>>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = AxiosError<unknown>>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeePaymentSuspenseQueryOptions(id,employeePaymentId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete Employee Payment
 */
export const deleteEmployeePayment = (
    id: number,
    employeePaymentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EmployeePayment>> => {
    
    
    return axios.default.delete(
      `/api/hr/employee/${id}/payment/${employeePaymentId}`,options
    );
  }



export const getDeleteEmployeePaymentMutationOptions = <TData = Awaited<ReturnType<typeof deleteEmployeePayment>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;employeePaymentId: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteEmployeePayment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEmployeePayment>>, {id: number;employeePaymentId: number}> = (props) => {
          const {id,employeePaymentId} = props ?? {};

          return  deleteEmployeePayment(id,employeePaymentId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;employeePaymentId: number}, TContext>}

    export type DeleteEmployeePaymentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEmployeePayment>>>
    
    export type DeleteEmployeePaymentMutationError = AxiosError<ResponseBase>

    export const useDeleteEmployeePayment = <TData = Awaited<ReturnType<typeof deleteEmployeePayment>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;employeePaymentId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;employeePaymentId: number},
        TContext
      > => {

      const mutationOptions = getDeleteEmployeePaymentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Employee Overtime
 */
export const getEmployeeOvertime = (
    id: number,
    overtimeId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EmployeeOvertime>> => {
    
    
    return axios.default.get(
      `/api/hr/employee/${id}/overtime/${overtimeId}`,options
    );
  }


export const getGetEmployeeOvertimeQueryKey = (id: number,
    overtimeId: number,) => {
    return [`/api/hr/employee/${id}/overtime/${overtimeId}`] as const;
    }

    
export const getGetEmployeeOvertimeQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = AxiosError<unknown>>(id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeOvertimeQueryKey(id,overtimeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeeOvertime>>> = ({ signal }) => getEmployeeOvertime(id,overtimeId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && overtimeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeOvertimeQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeeOvertime>>>
export type GetEmployeeOvertimeQueryError = AxiosError<unknown>


export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = AxiosError<unknown>>(
 id: number,
    overtimeId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeeOvertime>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = AxiosError<unknown>>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeeOvertime>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = AxiosError<unknown>>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = AxiosError<unknown>>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeOvertimeQueryOptions(id,overtimeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetEmployeeOvertimeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = AxiosError<unknown>>(id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeOvertimeQueryKey(id,overtimeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeeOvertime>>> = ({ signal }) => getEmployeeOvertime(id,overtimeId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeOvertimeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeeOvertime>>>
export type GetEmployeeOvertimeSuspenseQueryError = AxiosError<unknown>


export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = AxiosError<unknown>>(
 id: number,
    overtimeId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = AxiosError<unknown>>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = AxiosError<unknown>>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = AxiosError<unknown>>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeOvertimeSuspenseQueryOptions(id,overtimeId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete Employee Overtime
 */
export const deleteEmployeeOvertime = (
    id: number,
    overtimeId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EmployeeOvertime>> => {
    
    
    return axios.default.delete(
      `/api/hr/employee/${id}/overtime/${overtimeId}`,options
    );
  }



export const getDeleteEmployeeOvertimeMutationOptions = <TData = Awaited<ReturnType<typeof deleteEmployeeOvertime>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;overtimeId: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['deleteEmployeeOvertime'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEmployeeOvertime>>, {id: number;overtimeId: number}> = (props) => {
          const {id,overtimeId} = props ?? {};

          return  deleteEmployeeOvertime(id,overtimeId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;overtimeId: number}, TContext>}

    export type DeleteEmployeeOvertimeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEmployeeOvertime>>>
    
    export type DeleteEmployeeOvertimeMutationError = AxiosError<ResponseBase>

    export const useDeleteEmployeeOvertime = <TData = Awaited<ReturnType<typeof deleteEmployeeOvertime>>, TError = AxiosError<ResponseBase>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;overtimeId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;overtimeId: number},
        TContext
      > => {

      const mutationOptions = getDeleteEmployeeOvertimeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
