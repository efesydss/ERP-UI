/**
 * Generated by orval v7.4.1 ðŸº
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query'
import type {
  AdditionalCost,
  AdditionalCosts,
  AssignmentCard,
  AssignmentCards,
  AssignmentTransaction,
  AssignmentTransactions,
  Bank,
  BankAccount,
  BankAccounts,
  BankBranch,
  BankBranches,
  Banks,
  Branch,
  Branches,
  CashAccount,
  CashAccountBalanceResult,
  CashAccountTransaction,
  CashAccountTransactionEntity,
  CashAccountTransactions,
  CashAccounts,
  Companies,
  Company,
  CurrentAccount,
  CurrentAccountBankAccount,
  CurrentAccountBankAccounts,
  CurrentAccountTransaction,
  CurrentAccountTransactions,
  CurrentAccounts,
  Department,
  Departments,
  Depot,
  Depots,
  Employee,
  EmployeeOvertime,
  EmployeeOvertimes,
  EmployeePayment,
  EmployeePayments,
  Employees,
  ErrorResponse,
  ExpenseCard,
  ExpenseCards,
  ExpenseInvoice,
  ExpenseInvoiceCalculationResult,
  ExpenseInvoices,
  FilteringRequest,
  FixtureCard,
  FixtureCards,
  FixtureGroup,
  FixtureGroupTree,
  FixtureGroups,
  Invoice,
  InvoiceCalculationResult,
  Invoices,
  LoginRequest,
  LoginResponse,
  Logout200,
  Machine,
  Machines,
  MaterialCard,
  MaterialCards,
  MaterialGroup,
  MaterialGroupTreeDataResponse,
  MaterialGroups,
  PaymentMethod,
  PaymentMethods,
  ProductCard,
  ProductCards,
  ProductGroup,
  ProductGroupTree,
  ProductGroups,
  Project,
  Projects,
  Proposal,
  Proposals,
  PublicHoliday,
  PublicHolidays,
  PurchaseOrder,
  PurchaseOrders,
  RefreshResponse,
  ResponseBase,
  Role,
  Roles,
  Section,
  Sections,
  ServiceCard,
  ServiceCards,
  ServiceGroup,
  ServiceGroupTree,
  ServiceGroups,
  Shelf,
  Shelves,
  TimeKeeping,
  TimeKeepingCalculationResult,
  TimeKeepings,
  TimeOff,
  TimeOffStatus,
  TimeOffStatuses,
  TimeOffs,
  Unit,
  Units,
  Users
} from './model'
import { customMutator } from './customMutator';



/**
 * Get Unit
 */
export const getUnit = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Unit>(
      {url: `/api/storage/unit/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetUnitQueryKey = (id: number,) => {
    return [`/api/storage/unit/${id}`] as const;
    }

    
export const getGetUnitQueryOptions = <TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUnitQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnit>>> = ({ signal }) => getUnit(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUnitQueryResult = NonNullable<Awaited<ReturnType<typeof getUnit>>>
export type GetUnitQueryError = ErrorResponse


export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnit>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnit>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUnit<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUnitQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUnitSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUnitQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnit>>> = ({ signal }) => getUnit(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUnitSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUnit>>>
export type GetUnitSuspenseQueryError = ErrorResponse


export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUnitSuspense<TData = Awaited<ReturnType<typeof getUnit>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUnit>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUnitSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Unit
 */
export const updateUnit = (
    id: number,
    unit: Unit,
 ) => {
      
      
      return customMutator<Unit>(
      {url: `/api/storage/unit/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: unit
    },
      );
    }
  


export const getUpdateUnitMutationOptions = <TData = Awaited<ReturnType<typeof updateUnit>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Unit}, TContext>, }
) => {
const mutationKey = ['updateUnit'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUnit>>, {id: number;data: Unit}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUnit(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Unit}, TContext>}

    export type UpdateUnitMutationResult = NonNullable<Awaited<ReturnType<typeof updateUnit>>>
    export type UpdateUnitMutationBody = Unit
    export type UpdateUnitMutationError = ErrorResponse

    export const useUpdateUnit = <TData = Awaited<ReturnType<typeof updateUnit>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Unit}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Unit},
        TContext
      > => {

      const mutationOptions = getUpdateUnitMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Unit
 */
export const deleteUnit = (
    id: number,
 ) => {
      
      
      return customMutator<Unit>(
      {url: `/api/storage/unit/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUnitMutationOptions = <TData = Awaited<ReturnType<typeof deleteUnit>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteUnit'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUnit>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteUnit(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteUnitMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUnit>>>
    
    export type DeleteUnitMutationError = ResponseBase

    export const useDeleteUnit = <TData = Awaited<ReturnType<typeof deleteUnit>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteUnitMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Shelf
 */
export const getShelf = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Shelf>(
      {url: `/api/storage/shelf/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetShelfQueryKey = (id: number,) => {
    return [`/api/storage/shelf/${id}`] as const;
    }

    
export const getGetShelfQueryOptions = <TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetShelfQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getShelf>>> = ({ signal }) => getShelf(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetShelfQueryResult = NonNullable<Awaited<ReturnType<typeof getShelf>>>
export type GetShelfQueryError = ErrorResponse


export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShelf>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShelf>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetShelf<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetShelfQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetShelfSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetShelfQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getShelf>>> = ({ signal }) => getShelf(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetShelfSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getShelf>>>
export type GetShelfSuspenseQueryError = ErrorResponse


export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetShelfSuspense<TData = Awaited<ReturnType<typeof getShelf>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getShelf>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetShelfSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Shelf
 */
export const updateShelf = (
    id: number,
    shelf: Shelf,
 ) => {
      
      
      return customMutator<Shelf>(
      {url: `/api/storage/shelf/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: shelf
    },
      );
    }
  


export const getUpdateShelfMutationOptions = <TData = Awaited<ReturnType<typeof updateShelf>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Shelf}, TContext>, }
) => {
const mutationKey = ['updateShelf'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateShelf>>, {id: number;data: Shelf}> = (props) => {
          const {id,data} = props ?? {};

          return  updateShelf(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Shelf}, TContext>}

    export type UpdateShelfMutationResult = NonNullable<Awaited<ReturnType<typeof updateShelf>>>
    export type UpdateShelfMutationBody = Shelf
    export type UpdateShelfMutationError = ErrorResponse

    export const useUpdateShelf = <TData = Awaited<ReturnType<typeof updateShelf>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Shelf}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Shelf},
        TContext
      > => {

      const mutationOptions = getUpdateShelfMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Shelf
 */
export const deleteShelf = (
    id: number,
 ) => {
      
      
      return customMutator<Shelf>(
      {url: `/api/storage/shelf/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteShelfMutationOptions = <TData = Awaited<ReturnType<typeof deleteShelf>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteShelf'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteShelf>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteShelf(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteShelfMutationResult = NonNullable<Awaited<ReturnType<typeof deleteShelf>>>
    
    export type DeleteShelfMutationError = ResponseBase

    export const useDeleteShelf = <TData = Awaited<ReturnType<typeof deleteShelf>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteShelfMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ServiceGroup
 */
export const getServiceGroup = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceGroup>(
      {url: `/api/storage/serviceGroup/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetServiceGroupQueryKey = (id: number,) => {
    return [`/api/storage/serviceGroup/${id}`] as const;
    }

    
export const getGetServiceGroupQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroup>>> = ({ signal }) => getServiceGroup(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroup>>>
export type GetServiceGroupQueryError = ErrorResponse


export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroup<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroup>>> = ({ signal }) => getServiceGroup(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroup>>>
export type GetServiceGroupSuspenseQueryError = ErrorResponse


export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupSuspense<TData = Awaited<ReturnType<typeof getServiceGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ServiceGroup
 */
export const updateServiceGroup = (
    id: number,
    serviceGroup: ServiceGroup,
 ) => {
      
      
      return customMutator<ServiceGroup>(
      {url: `/api/storage/serviceGroup/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: serviceGroup
    },
      );
    }
  


export const getUpdateServiceGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateServiceGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceGroup}, TContext>, }
) => {
const mutationKey = ['updateServiceGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceGroup>>, {id: number;data: ServiceGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateServiceGroup(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ServiceGroup}, TContext>}

    export type UpdateServiceGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceGroup>>>
    export type UpdateServiceGroupMutationBody = ServiceGroup
    export type UpdateServiceGroupMutationError = ErrorResponse

    export const useUpdateServiceGroup = <TData = Awaited<ReturnType<typeof updateServiceGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ServiceGroup},
        TContext
      > => {

      const mutationOptions = getUpdateServiceGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ServiceGroup
 */
export const deleteServiceGroup = (
    id: number,
 ) => {
      
      
      return customMutator<ServiceGroup>(
      {url: `/api/storage/serviceGroup/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteServiceGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteServiceGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteServiceGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteServiceGroup(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteServiceGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceGroup>>>
    
    export type DeleteServiceGroupMutationError = ResponseBase

    export const useDeleteServiceGroup = <TData = Awaited<ReturnType<typeof deleteServiceGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteServiceGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ServiceCard
 */
export const getServiceCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceCard>(
      {url: `/api/storage/serviceCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetServiceCardQueryKey = (id: number,) => {
    return [`/api/storage/serviceCard/${id}`] as const;
    }

    
export const getGetServiceCardQueryOptions = <TData = Awaited<ReturnType<typeof getServiceCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceCard>>> = ({ signal }) => getServiceCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceCardQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceCard>>>
export type GetServiceCardQueryError = ErrorResponse


export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceCard<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getServiceCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceCard>>> = ({ signal }) => getServiceCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceCard>>>
export type GetServiceCardSuspenseQueryError = ErrorResponse


export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceCardSuspense<TData = Awaited<ReturnType<typeof getServiceCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ServiceCard
 */
export const updateServiceCard = (
    id: number,
    serviceCard: ServiceCard,
 ) => {
      
      
      return customMutator<ServiceCard>(
      {url: `/api/storage/serviceCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: serviceCard
    },
      );
    }
  


export const getUpdateServiceCardMutationOptions = <TData = Awaited<ReturnType<typeof updateServiceCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceCard}, TContext>, }
) => {
const mutationKey = ['updateServiceCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceCard>>, {id: number;data: ServiceCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateServiceCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ServiceCard}, TContext>}

    export type UpdateServiceCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceCard>>>
    export type UpdateServiceCardMutationBody = ServiceCard
    export type UpdateServiceCardMutationError = ErrorResponse

    export const useUpdateServiceCard = <TData = Awaited<ReturnType<typeof updateServiceCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ServiceCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ServiceCard},
        TContext
      > => {

      const mutationOptions = getUpdateServiceCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ServiceCard
 */
export const deleteServiceCard = (
    id: number,
 ) => {
      
      
      return customMutator<ServiceCard>(
      {url: `/api/storage/serviceCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteServiceCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteServiceCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteServiceCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteServiceCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteServiceCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceCard>>>
    
    export type DeleteServiceCardMutationError = ResponseBase

    export const useDeleteServiceCard = <TData = Awaited<ReturnType<typeof deleteServiceCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteServiceCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ProductGroup
 */
export const getProductGroup = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductGroup>(
      {url: `/api/storage/productGroup/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProductGroupQueryKey = (id: number,) => {
    return [`/api/storage/productGroup/${id}`] as const;
    }

    
export const getGetProductGroupQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroup>>> = ({ signal }) => getProductGroup(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroup>>>
export type GetProductGroupQueryError = ErrorResponse


export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroup<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroup>>> = ({ signal }) => getProductGroup(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroup>>>
export type GetProductGroupSuspenseQueryError = ErrorResponse


export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupSuspense<TData = Awaited<ReturnType<typeof getProductGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ProductGroup
 */
export const updateProductGroup = (
    id: number,
    productGroup: ProductGroup,
 ) => {
      
      
      return customMutator<ProductGroup>(
      {url: `/api/storage/productGroup/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: productGroup
    },
      );
    }
  


export const getUpdateProductGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateProductGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductGroup}, TContext>, }
) => {
const mutationKey = ['updateProductGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProductGroup>>, {id: number;data: ProductGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProductGroup(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ProductGroup}, TContext>}

    export type UpdateProductGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateProductGroup>>>
    export type UpdateProductGroupMutationBody = ProductGroup
    export type UpdateProductGroupMutationError = ErrorResponse

    export const useUpdateProductGroup = <TData = Awaited<ReturnType<typeof updateProductGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ProductGroup},
        TContext
      > => {

      const mutationOptions = getUpdateProductGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ProductGroup
 */
export const deleteProductGroup = (
    id: number,
 ) => {
      
      
      return customMutator<ProductGroup>(
      {url: `/api/storage/productGroup/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProductGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteProductGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteProductGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProductGroup(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProductGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductGroup>>>
    
    export type DeleteProductGroupMutationError = ResponseBase

    export const useDeleteProductGroup = <TData = Awaited<ReturnType<typeof deleteProductGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProductGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ProductCard
 */
export const getProductCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductCard>(
      {url: `/api/storage/productCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProductCardQueryKey = (id: number,) => {
    return [`/api/storage/productCard/${id}`] as const;
    }

    
export const getGetProductCardQueryOptions = <TData = Awaited<ReturnType<typeof getProductCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductCard>>> = ({ signal }) => getProductCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductCardQueryResult = NonNullable<Awaited<ReturnType<typeof getProductCard>>>
export type GetProductCardQueryError = ErrorResponse


export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductCard<TData = Awaited<ReturnType<typeof getProductCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductCard>>> = ({ signal }) => getProductCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductCard>>>
export type GetProductCardSuspenseQueryError = ErrorResponse


export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductCardSuspense<TData = Awaited<ReturnType<typeof getProductCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ProductCard
 */
export const updateProductCard = (
    id: number,
    productCard: ProductCard,
 ) => {
      
      
      return customMutator<ProductCard>(
      {url: `/api/storage/productCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: productCard
    },
      );
    }
  


export const getUpdateProductCardMutationOptions = <TData = Awaited<ReturnType<typeof updateProductCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductCard}, TContext>, }
) => {
const mutationKey = ['updateProductCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProductCard>>, {id: number;data: ProductCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProductCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ProductCard}, TContext>}

    export type UpdateProductCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateProductCard>>>
    export type UpdateProductCardMutationBody = ProductCard
    export type UpdateProductCardMutationError = ErrorResponse

    export const useUpdateProductCard = <TData = Awaited<ReturnType<typeof updateProductCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ProductCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ProductCard},
        TContext
      > => {

      const mutationOptions = getUpdateProductCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ProductCard
 */
export const deleteProductCard = (
    id: number,
 ) => {
      
      
      return customMutator<ProductCard>(
      {url: `/api/storage/productCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProductCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteProductCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteProductCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProductCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProductCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductCard>>>
    
    export type DeleteProductCardMutationError = ResponseBase

    export const useDeleteProductCard = <TData = Awaited<ReturnType<typeof deleteProductCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProductCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get MaterialGroup
 */
export const getMaterialGroup = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialGroup>(
      {url: `/api/storage/materialGroup/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetMaterialGroupQueryKey = (id: number,) => {
    return [`/api/storage/materialGroup/${id}`] as const;
    }

    
export const getGetMaterialGroupQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroup>>> = ({ signal }) => getMaterialGroup(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroup>>>
export type GetMaterialGroupQueryError = ErrorResponse


export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroup<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroup>>> = ({ signal }) => getMaterialGroup(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroup>>>
export type GetMaterialGroupSuspenseQueryError = ErrorResponse


export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupSuspense<TData = Awaited<ReturnType<typeof getMaterialGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update MaterialGroup
 */
export const updateMaterialGroup = (
    id: number,
    materialGroup: MaterialGroup,
 ) => {
      
      
      return customMutator<MaterialGroup>(
      {url: `/api/storage/materialGroup/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: materialGroup
    },
      );
    }
  


export const getUpdateMaterialGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateMaterialGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialGroup}, TContext>, }
) => {
const mutationKey = ['updateMaterialGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMaterialGroup>>, {id: number;data: MaterialGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMaterialGroup(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: MaterialGroup}, TContext>}

    export type UpdateMaterialGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateMaterialGroup>>>
    export type UpdateMaterialGroupMutationBody = MaterialGroup
    export type UpdateMaterialGroupMutationError = ErrorResponse

    export const useUpdateMaterialGroup = <TData = Awaited<ReturnType<typeof updateMaterialGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: MaterialGroup},
        TContext
      > => {

      const mutationOptions = getUpdateMaterialGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete MaterialGroup
 */
export const deleteMaterialGroup = (
    id: number,
 ) => {
      
      
      return customMutator<MaterialGroup>(
      {url: `/api/storage/materialGroup/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteMaterialGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteMaterialGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteMaterialGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMaterialGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMaterialGroup(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteMaterialGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMaterialGroup>>>
    
    export type DeleteMaterialGroupMutationError = ResponseBase

    export const useDeleteMaterialGroup = <TData = Awaited<ReturnType<typeof deleteMaterialGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMaterialGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get MaterialCard
 */
export const getMaterialCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialCard>(
      {url: `/api/storage/materialCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetMaterialCardQueryKey = (id: number,) => {
    return [`/api/storage/materialCard/${id}`] as const;
    }

    
export const getGetMaterialCardQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialCard>>> = ({ signal }) => getMaterialCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialCardQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialCard>>>
export type GetMaterialCardQueryError = ErrorResponse


export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialCard<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialCard>>> = ({ signal }) => getMaterialCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialCard>>>
export type GetMaterialCardSuspenseQueryError = ErrorResponse


export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialCardSuspense<TData = Awaited<ReturnType<typeof getMaterialCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update MaterialCard
 */
export const updateMaterialCard = (
    id: number,
    materialCard: MaterialCard,
 ) => {
      
      
      return customMutator<MaterialCard>(
      {url: `/api/storage/materialCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: materialCard
    },
      );
    }
  


export const getUpdateMaterialCardMutationOptions = <TData = Awaited<ReturnType<typeof updateMaterialCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialCard}, TContext>, }
) => {
const mutationKey = ['updateMaterialCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMaterialCard>>, {id: number;data: MaterialCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMaterialCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: MaterialCard}, TContext>}

    export type UpdateMaterialCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateMaterialCard>>>
    export type UpdateMaterialCardMutationBody = MaterialCard
    export type UpdateMaterialCardMutationError = ErrorResponse

    export const useUpdateMaterialCard = <TData = Awaited<ReturnType<typeof updateMaterialCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: MaterialCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: MaterialCard},
        TContext
      > => {

      const mutationOptions = getUpdateMaterialCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete MaterialCard
 */
export const deleteMaterialCard = (
    id: number,
 ) => {
      
      
      return customMutator<MaterialCard>(
      {url: `/api/storage/materialCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteMaterialCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteMaterialCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteMaterialCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMaterialCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMaterialCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteMaterialCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMaterialCard>>>
    
    export type DeleteMaterialCardMutationError = ResponseBase

    export const useDeleteMaterialCard = <TData = Awaited<ReturnType<typeof deleteMaterialCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMaterialCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get FixtureGroup
 */
export const getFixtureGroup = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureGroup>(
      {url: `/api/storage/fixtureGroup/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetFixtureGroupQueryKey = (id: number,) => {
    return [`/api/storage/fixtureGroup/${id}`] as const;
    }

    
export const getGetFixtureGroupQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroup>>> = ({ signal }) => getFixtureGroup(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroup>>>
export type GetFixtureGroupQueryError = ErrorResponse


export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroup>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroup<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFixtureGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroup>>> = ({ signal }) => getFixtureGroup(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroup>>>
export type GetFixtureGroupSuspenseQueryError = ErrorResponse


export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupSuspense<TData = Awaited<ReturnType<typeof getFixtureGroup>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroup>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update FixtureGroup
 */
export const updateFixtureGroup = (
    id: number,
    fixtureGroup: FixtureGroup,
 ) => {
      
      
      return customMutator<FixtureGroup>(
      {url: `/api/storage/fixtureGroup/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: fixtureGroup
    },
      );
    }
  


export const getUpdateFixtureGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateFixtureGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureGroup}, TContext>, }
) => {
const mutationKey = ['updateFixtureGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFixtureGroup>>, {id: number;data: FixtureGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  updateFixtureGroup(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: FixtureGroup}, TContext>}

    export type UpdateFixtureGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateFixtureGroup>>>
    export type UpdateFixtureGroupMutationBody = FixtureGroup
    export type UpdateFixtureGroupMutationError = ErrorResponse

    export const useUpdateFixtureGroup = <TData = Awaited<ReturnType<typeof updateFixtureGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: FixtureGroup},
        TContext
      > => {

      const mutationOptions = getUpdateFixtureGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete FixtureGroup
 */
export const deleteFixtureGroup = (
    id: number,
 ) => {
      
      
      return customMutator<FixtureGroup>(
      {url: `/api/storage/fixtureGroup/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteFixtureGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteFixtureGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteFixtureGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFixtureGroup>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteFixtureGroup(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteFixtureGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFixtureGroup>>>
    
    export type DeleteFixtureGroupMutationError = ResponseBase

    export const useDeleteFixtureGroup = <TData = Awaited<ReturnType<typeof deleteFixtureGroup>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteFixtureGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get FixtureCard
 */
export const getFixtureCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureCard>(
      {url: `/api/storage/fixtureCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetFixtureCardQueryKey = (id: number,) => {
    return [`/api/storage/fixtureCard/${id}`] as const;
    }

    
export const getGetFixtureCardQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureCard>>> = ({ signal }) => getFixtureCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureCardQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureCard>>>
export type GetFixtureCardQueryError = ErrorResponse


export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureCard<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFixtureCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureCard>>> = ({ signal }) => getFixtureCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureCard>>>
export type GetFixtureCardSuspenseQueryError = ErrorResponse


export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureCardSuspense<TData = Awaited<ReturnType<typeof getFixtureCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update FixtureCard
 */
export const updateFixtureCard = (
    id: number,
    fixtureCard: FixtureCard,
 ) => {
      
      
      return customMutator<FixtureCard>(
      {url: `/api/storage/fixtureCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: fixtureCard
    },
      );
    }
  


export const getUpdateFixtureCardMutationOptions = <TData = Awaited<ReturnType<typeof updateFixtureCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureCard}, TContext>, }
) => {
const mutationKey = ['updateFixtureCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFixtureCard>>, {id: number;data: FixtureCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateFixtureCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: FixtureCard}, TContext>}

    export type UpdateFixtureCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateFixtureCard>>>
    export type UpdateFixtureCardMutationBody = FixtureCard
    export type UpdateFixtureCardMutationError = ErrorResponse

    export const useUpdateFixtureCard = <TData = Awaited<ReturnType<typeof updateFixtureCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FixtureCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: FixtureCard},
        TContext
      > => {

      const mutationOptions = getUpdateFixtureCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete FixtureCard
 */
export const deleteFixtureCard = (
    id: number,
 ) => {
      
      
      return customMutator<FixtureCard>(
      {url: `/api/storage/fixtureCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteFixtureCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteFixtureCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteFixtureCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFixtureCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteFixtureCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteFixtureCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFixtureCard>>>
    
    export type DeleteFixtureCardMutationError = ResponseBase

    export const useDeleteFixtureCard = <TData = Awaited<ReturnType<typeof deleteFixtureCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteFixtureCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get AssignmentTransaction
 */
export const getAssignmentTransaction = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AssignmentTransaction>(
      {url: `/api/storage/assignmentTransaction/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAssignmentTransactionQueryKey = (id: number,) => {
    return [`/api/storage/assignmentTransaction/${id}`] as const;
    }

    
export const getGetAssignmentTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentTransaction>>> = ({ signal }) => getAssignmentTransaction(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentTransaction>>>
export type GetAssignmentTransactionQueryError = ErrorResponse


export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentTransaction<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentTransactionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssignmentTransactionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentTransaction>>> = ({ signal }) => getAssignmentTransaction(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentTransactionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentTransaction>>>
export type GetAssignmentTransactionSuspenseQueryError = ErrorResponse


export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentTransactionSuspense<TData = Awaited<ReturnType<typeof getAssignmentTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentTransactionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update AssignmentTransaction
 */
export const updateAssignmentTransaction = (
    id: number,
    assignmentTransaction: AssignmentTransaction,
 ) => {
      
      
      return customMutator<AssignmentTransaction>(
      {url: `/api/storage/assignmentTransaction/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assignmentTransaction
    },
      );
    }
  


export const getUpdateAssignmentTransactionMutationOptions = <TData = Awaited<ReturnType<typeof updateAssignmentTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentTransaction}, TContext>, }
) => {
const mutationKey = ['updateAssignmentTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssignmentTransaction>>, {id: number;data: AssignmentTransaction}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAssignmentTransaction(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: AssignmentTransaction}, TContext>}

    export type UpdateAssignmentTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssignmentTransaction>>>
    export type UpdateAssignmentTransactionMutationBody = AssignmentTransaction
    export type UpdateAssignmentTransactionMutationError = ErrorResponse

    export const useUpdateAssignmentTransaction = <TData = Awaited<ReturnType<typeof updateAssignmentTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: AssignmentTransaction},
        TContext
      > => {

      const mutationOptions = getUpdateAssignmentTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete AssignmentTransaction
 */
export const deleteAssignmentTransaction = (
    id: number,
 ) => {
      
      
      return customMutator<AssignmentTransaction>(
      {url: `/api/storage/assignmentTransaction/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAssignmentTransactionMutationOptions = <TData = Awaited<ReturnType<typeof deleteAssignmentTransaction>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteAssignmentTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssignmentTransaction>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAssignmentTransaction(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteAssignmentTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssignmentTransaction>>>
    
    export type DeleteAssignmentTransactionMutationError = ResponseBase

    export const useDeleteAssignmentTransaction = <TData = Awaited<ReturnType<typeof deleteAssignmentTransaction>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAssignmentTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get AssignmentCard
 */
export const getAssignmentCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AssignmentCard>(
      {url: `/api/storage/assignmentCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAssignmentCardQueryKey = (id: number,) => {
    return [`/api/storage/assignmentCard/${id}`] as const;
    }

    
export const getGetAssignmentCardQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentCard>>> = ({ signal }) => getAssignmentCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentCardQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentCard>>>
export type GetAssignmentCardQueryError = ErrorResponse


export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignmentCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentCard<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssignmentCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentCard>>> = ({ signal }) => getAssignmentCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssignmentCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentCard>>>
export type GetAssignmentCardSuspenseQueryError = ErrorResponse


export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssignmentCardSuspense<TData = Awaited<ReturnType<typeof getAssignmentCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssignmentCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssignmentCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update AssignmentCard
 */
export const updateAssignmentCard = (
    id: number,
    assignmentCard: AssignmentCard,
 ) => {
      
      
      return customMutator<AssignmentCard>(
      {url: `/api/storage/assignmentCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assignmentCard
    },
      );
    }
  


export const getUpdateAssignmentCardMutationOptions = <TData = Awaited<ReturnType<typeof updateAssignmentCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentCard}, TContext>, }
) => {
const mutationKey = ['updateAssignmentCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssignmentCard>>, {id: number;data: AssignmentCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAssignmentCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: AssignmentCard}, TContext>}

    export type UpdateAssignmentCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssignmentCard>>>
    export type UpdateAssignmentCardMutationBody = AssignmentCard
    export type UpdateAssignmentCardMutationError = ErrorResponse

    export const useUpdateAssignmentCard = <TData = Awaited<ReturnType<typeof updateAssignmentCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AssignmentCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: AssignmentCard},
        TContext
      > => {

      const mutationOptions = getUpdateAssignmentCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete AssignmentCard
 */
export const deleteAssignmentCard = (
    id: number,
 ) => {
      
      
      return customMutator<AssignmentCard>(
      {url: `/api/storage/assignmentCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAssignmentCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteAssignmentCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteAssignmentCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssignmentCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAssignmentCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteAssignmentCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssignmentCard>>>
    
    export type DeleteAssignmentCardMutationError = ResponseBase

    export const useDeleteAssignmentCard = <TData = Awaited<ReturnType<typeof deleteAssignmentCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAssignmentCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Proposal
 */
export const getProposal = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Proposal>(
      {url: `/api/sales/proposal/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProposalQueryKey = (id: number,) => {
    return [`/api/sales/proposal/${id}`] as const;
    }

    
export const getGetProposalQueryOptions = <TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProposalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProposal>>> = ({ signal }) => getProposal(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProposalQueryResult = NonNullable<Awaited<ReturnType<typeof getProposal>>>
export type GetProposalQueryError = ErrorResponse


export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProposal>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProposal>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProposal<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProposalQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProposalSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProposalQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProposal>>> = ({ signal }) => getProposal(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProposalSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProposal>>>
export type GetProposalSuspenseQueryError = ErrorResponse


export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProposalSuspense<TData = Awaited<ReturnType<typeof getProposal>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProposal>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProposalSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Proposal
 */
export const updateProposal = (
    id: number,
    proposal: Proposal,
 ) => {
      
      
      return customMutator<Proposal>(
      {url: `/api/sales/proposal/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: proposal
    },
      );
    }
  


export const getUpdateProposalMutationOptions = <TData = Awaited<ReturnType<typeof updateProposal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Proposal}, TContext>, }
) => {
const mutationKey = ['updateProposal'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProposal>>, {id: number;data: Proposal}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProposal(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Proposal}, TContext>}

    export type UpdateProposalMutationResult = NonNullable<Awaited<ReturnType<typeof updateProposal>>>
    export type UpdateProposalMutationBody = Proposal
    export type UpdateProposalMutationError = ErrorResponse

    export const useUpdateProposal = <TData = Awaited<ReturnType<typeof updateProposal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Proposal}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Proposal},
        TContext
      > => {

      const mutationOptions = getUpdateProposalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Proposal
 */
export const deleteProposal = (
    id: number,
 ) => {
      
      
      return customMutator<Proposal>(
      {url: `/api/sales/proposal/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProposalMutationOptions = <TData = Awaited<ReturnType<typeof deleteProposal>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteProposal'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProposal>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProposal(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProposalMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProposal>>>
    
    export type DeleteProposalMutationError = ResponseBase

    export const useDeleteProposal = <TData = Awaited<ReturnType<typeof deleteProposal>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProposalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Purchase Order
 */
export const getPurchaseOrder = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PurchaseOrder>(
      {url: `/api/purchasing/purchaseOrder/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetPurchaseOrderQueryKey = (id: number,) => {
    return [`/api/purchasing/purchaseOrder/${id}`] as const;
    }

    
export const getGetPurchaseOrderQueryOptions = <TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPurchaseOrderQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPurchaseOrder>>> = ({ signal }) => getPurchaseOrder(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPurchaseOrderQueryResult = NonNullable<Awaited<ReturnType<typeof getPurchaseOrder>>>
export type GetPurchaseOrderQueryError = ErrorResponse


export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseOrder>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseOrder>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPurchaseOrder<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPurchaseOrderQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPurchaseOrderSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPurchaseOrderQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPurchaseOrder>>> = ({ signal }) => getPurchaseOrder(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPurchaseOrderSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPurchaseOrder>>>
export type GetPurchaseOrderSuspenseQueryError = ErrorResponse


export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPurchaseOrderSuspense<TData = Awaited<ReturnType<typeof getPurchaseOrder>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPurchaseOrder>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPurchaseOrderSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update PurchaseOrder
 */
export const updatePurchaseOrder = (
    id: number,
    purchaseOrder: PurchaseOrder,
 ) => {
      
      
      return customMutator<PurchaseOrder>(
      {url: `/api/purchasing/purchaseOrder/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: purchaseOrder
    },
      );
    }
  


export const getUpdatePurchaseOrderMutationOptions = <TData = Awaited<ReturnType<typeof updatePurchaseOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PurchaseOrder}, TContext>, }
) => {
const mutationKey = ['updatePurchaseOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePurchaseOrder>>, {id: number;data: PurchaseOrder}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePurchaseOrder(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: PurchaseOrder}, TContext>}

    export type UpdatePurchaseOrderMutationResult = NonNullable<Awaited<ReturnType<typeof updatePurchaseOrder>>>
    export type UpdatePurchaseOrderMutationBody = PurchaseOrder
    export type UpdatePurchaseOrderMutationError = ErrorResponse

    export const useUpdatePurchaseOrder = <TData = Awaited<ReturnType<typeof updatePurchaseOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PurchaseOrder}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: PurchaseOrder},
        TContext
      > => {

      const mutationOptions = getUpdatePurchaseOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete PurchaseOrder
 */
export const deletePurchaseOrder = (
    id: number,
 ) => {
      
      
      return customMutator<PurchaseOrder>(
      {url: `/api/purchasing/purchaseOrder/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePurchaseOrderMutationOptions = <TData = Awaited<ReturnType<typeof deletePurchaseOrder>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deletePurchaseOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePurchaseOrder>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deletePurchaseOrder(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeletePurchaseOrderMutationResult = NonNullable<Awaited<ReturnType<typeof deletePurchaseOrder>>>
    
    export type DeletePurchaseOrderMutationError = ResponseBase

    export const useDeletePurchaseOrder = <TData = Awaited<ReturnType<typeof deletePurchaseOrder>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeletePurchaseOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Invoice
 */
export const getInvoice = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Invoice>(
      {url: `/api/purchasing/invoice/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetInvoiceQueryKey = (id: number,) => {
    return [`/api/purchasing/invoice/${id}`] as const;
    }

    
export const getGetInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInvoice>>> = ({ signal }) => getInvoice(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof getInvoice>>>
export type GetInvoiceQueryError = ErrorResponse


export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetInvoice<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetInvoiceQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetInvoiceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInvoice>>> = ({ signal }) => getInvoice(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInvoiceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getInvoice>>>
export type GetInvoiceSuspenseQueryError = ErrorResponse


export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetInvoiceSuspense<TData = Awaited<ReturnType<typeof getInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetInvoiceSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Invoice
 */
export const updateInvoice = (
    id: number,
    invoice: Invoice,
 ) => {
      
      
      return customMutator<Invoice>(
      {url: `/api/purchasing/invoice/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: invoice
    },
      );
    }
  


export const getUpdateInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof updateInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Invoice}, TContext>, }
) => {
const mutationKey = ['updateInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateInvoice>>, {id: number;data: Invoice}> = (props) => {
          const {id,data} = props ?? {};

          return  updateInvoice(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Invoice}, TContext>}

    export type UpdateInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof updateInvoice>>>
    export type UpdateInvoiceMutationBody = Invoice
    export type UpdateInvoiceMutationError = ErrorResponse

    export const useUpdateInvoice = <TData = Awaited<ReturnType<typeof updateInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Invoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Invoice},
        TContext
      > => {

      const mutationOptions = getUpdateInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Invoice by document reference
 */
export const deleteInvoice = (
    id: number,
 ) => {
      
      
      return customMutator<Invoice>(
      {url: `/api/purchasing/invoice/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof deleteInvoice>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteInvoice>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteInvoice(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteInvoice>>>
    
    export type DeleteInvoiceMutationError = unknown

    export const useDeleteInvoice = <TData = Awaited<ReturnType<typeof deleteInvoice>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Current Account Transaction
 */
export const getCurrentAccountTransaction = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccountTransaction>(
      {url: `/api/purchasing/currentAccountTransaction/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurrentAccountTransactionQueryKey = (id: number,) => {
    return [`/api/purchasing/currentAccountTransaction/${id}`] as const;
    }

    
export const getGetCurrentAccountTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountTransaction>>> = ({ signal }) => getCurrentAccountTransaction(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountTransaction>>>
export type GetCurrentAccountTransactionQueryError = ErrorResponse


export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountTransaction<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountTransactionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentAccountTransactionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountTransaction>>> = ({ signal }) => getCurrentAccountTransaction(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountTransactionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountTransaction>>>
export type GetCurrentAccountTransactionSuspenseQueryError = ErrorResponse


export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountTransactionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Current Account Transaction
 */
export const updateCurrentAccountTransaction = (
    id: number,
    currentAccountTransaction: CurrentAccountTransaction,
 ) => {
      
      
      return customMutator<CurrentAccountTransaction>(
      {url: `/api/purchasing/currentAccountTransaction/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: currentAccountTransaction
    },
      );
    }
  


export const getUpdateCurrentAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof updateCurrentAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountTransaction}, TContext>, }
) => {
const mutationKey = ['updateCurrentAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentAccountTransaction>>, {id: number;data: CurrentAccountTransaction}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurrentAccountTransaction(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CurrentAccountTransaction}, TContext>}

    export type UpdateCurrentAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentAccountTransaction>>>
    export type UpdateCurrentAccountTransactionMutationBody = CurrentAccountTransaction
    export type UpdateCurrentAccountTransactionMutationError = ErrorResponse

    export const useUpdateCurrentAccountTransaction = <TData = Awaited<ReturnType<typeof updateCurrentAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CurrentAccountTransaction},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Current Account Transaction by document reference
 */
export const deleteCurrentAccountTransaction = (
    id: number,
 ) => {
      
      
      return customMutator<CurrentAccountTransaction>(
      {url: `/api/purchasing/currentAccountTransaction/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCurrentAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCurrentAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurrentAccountTransaction(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCurrentAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>>
    
    export type DeleteCurrentAccountTransactionMutationError = unknown

    export const useDeleteCurrentAccountTransaction = <TData = Awaited<ReturnType<typeof deleteCurrentAccountTransaction>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurrentAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get CurrentAccountBankAccount
 */
export const getCurrentAccountBankAccount = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccountBankAccount>(
      {url: `/api/purchasing/currentAccountBankAccount/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurrentAccountBankAccountQueryKey = (id: number,) => {
    return [`/api/purchasing/currentAccountBankAccount/${id}`] as const;
    }

    
export const getGetCurrentAccountBankAccountQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>> = ({ signal }) => getCurrentAccountBankAccount(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountBankAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>>
export type GetCurrentAccountBankAccountQueryError = ErrorResponse


export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccountBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountBankAccount<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountBankAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentAccountBankAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>> = ({ signal }) => getCurrentAccountBankAccount(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountBankAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>>
export type GetCurrentAccountBankAccountSuspenseQueryError = ErrorResponse


export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountBankAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccountBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountBankAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update CurrentAccountBankAccount
 */
export const updateCurrentAccountBankAccount = (
    id: number,
    currentAccountBankAccount: CurrentAccountBankAccount,
 ) => {
      
      
      return customMutator<CurrentAccountBankAccount>(
      {url: `/api/purchasing/currentAccountBankAccount/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: currentAccountBankAccount
    },
      );
    }
  


export const getUpdateCurrentAccountBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountBankAccount}, TContext>, }
) => {
const mutationKey = ['updateCurrentAccountBankAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>, {id: number;data: CurrentAccountBankAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurrentAccountBankAccount(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CurrentAccountBankAccount}, TContext>}

    export type UpdateCurrentAccountBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>>
    export type UpdateCurrentAccountBankAccountMutationBody = CurrentAccountBankAccount
    export type UpdateCurrentAccountBankAccountMutationError = ErrorResponse

    export const useUpdateCurrentAccountBankAccount = <TData = Awaited<ReturnType<typeof updateCurrentAccountBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccountBankAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CurrentAccountBankAccount},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentAccountBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete CurrentAccountBankAccount
 */
export const deleteCurrentAccountBankAccount = (
    id: number,
 ) => {
      
      
      return customMutator<CurrentAccountBankAccount>(
      {url: `/api/purchasing/currentAccountBankAccount/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCurrentAccountBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCurrentAccountBankAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurrentAccountBankAccount(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCurrentAccountBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>>
    
    export type DeleteCurrentAccountBankAccountMutationError = ResponseBase

    export const useDeleteCurrentAccountBankAccount = <TData = Awaited<ReturnType<typeof deleteCurrentAccountBankAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurrentAccountBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Current Account
 */
export const getCurrentAccount = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccount>(
      {url: `/api/purchasing/currentAccount/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurrentAccountQueryKey = (id: number,) => {
    return [`/api/purchasing/currentAccount/${id}`] as const;
    }

    
export const getGetCurrentAccountQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccount>>> = ({ signal }) => getCurrentAccount(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccount>>>
export type GetCurrentAccountQueryError = ErrorResponse


export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccount<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAccount>>> = ({ signal }) => getCurrentAccount(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccount>>>
export type GetCurrentAccountSuspenseQueryError = ErrorResponse


export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCurrentAccountSuspense<TData = Awaited<ReturnType<typeof getCurrentAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Current Account
 */
export const updateCurrentAccount = (
    id: number,
    currentAccount: CurrentAccount,
 ) => {
      
      
      return customMutator<CurrentAccount>(
      {url: `/api/purchasing/currentAccount/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: currentAccount
    },
      );
    }
  


export const getUpdateCurrentAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateCurrentAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccount}, TContext>, }
) => {
const mutationKey = ['updateCurrentAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentAccount>>, {id: number;data: CurrentAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurrentAccount(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CurrentAccount}, TContext>}

    export type UpdateCurrentAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentAccount>>>
    export type UpdateCurrentAccountMutationBody = CurrentAccount
    export type UpdateCurrentAccountMutationError = ErrorResponse

    export const useUpdateCurrentAccount = <TData = Awaited<ReturnType<typeof updateCurrentAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CurrentAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CurrentAccount},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Current Account by document reference
 */
export const deleteCurrentAccount = (
    id: number,
 ) => {
      
      
      return customMutator<CurrentAccount>(
      {url: `/api/purchasing/currentAccount/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCurrentAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteCurrentAccount>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCurrentAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrentAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurrentAccount(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCurrentAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrentAccount>>>
    
    export type DeleteCurrentAccountMutationError = unknown

    export const useDeleteCurrentAccount = <TData = Awaited<ReturnType<typeof deleteCurrentAccount>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurrentAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get AdditionalCost
 */
export const getAdditionalCost = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AdditionalCost>(
      {url: `/api/purchasing/additionalcost/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAdditionalCostQueryKey = (id: number,) => {
    return [`/api/purchasing/additionalcost/${id}`] as const;
    }

    
export const getGetAdditionalCostQueryOptions = <TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdditionalCostQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdditionalCost>>> = ({ signal }) => getAdditionalCost(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdditionalCostQueryResult = NonNullable<Awaited<ReturnType<typeof getAdditionalCost>>>
export type GetAdditionalCostQueryError = ErrorResponse


export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdditionalCost>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdditionalCost>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdditionalCost<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdditionalCostQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdditionalCostSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdditionalCostQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdditionalCost>>> = ({ signal }) => getAdditionalCost(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdditionalCostSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdditionalCost>>>
export type GetAdditionalCostSuspenseQueryError = ErrorResponse


export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdditionalCostSuspense<TData = Awaited<ReturnType<typeof getAdditionalCost>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdditionalCost>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdditionalCostSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update AdditionalCost
 */
export const updateAdditionalCost = (
    id: number,
    additionalCost: AdditionalCost,
 ) => {
      
      
      return customMutator<AdditionalCost>(
      {url: `/api/purchasing/additionalcost/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: additionalCost
    },
      );
    }
  


export const getUpdateAdditionalCostMutationOptions = <TData = Awaited<ReturnType<typeof updateAdditionalCost>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AdditionalCost}, TContext>, }
) => {
const mutationKey = ['updateAdditionalCost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdditionalCost>>, {id: number;data: AdditionalCost}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAdditionalCost(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: AdditionalCost}, TContext>}

    export type UpdateAdditionalCostMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdditionalCost>>>
    export type UpdateAdditionalCostMutationBody = AdditionalCost
    export type UpdateAdditionalCostMutationError = ErrorResponse

    export const useUpdateAdditionalCost = <TData = Awaited<ReturnType<typeof updateAdditionalCost>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: AdditionalCost}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: AdditionalCost},
        TContext
      > => {

      const mutationOptions = getUpdateAdditionalCostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete AdditionalCost
 */
export const deleteAdditionalCost = (
    id: number,
 ) => {
      
      
      return customMutator<AdditionalCost>(
      {url: `/api/purchasing/additionalcost/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAdditionalCostMutationOptions = <TData = Awaited<ReturnType<typeof deleteAdditionalCost>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteAdditionalCost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAdditionalCost>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAdditionalCost(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteAdditionalCostMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAdditionalCost>>>
    
    export type DeleteAdditionalCostMutationError = ResponseBase

    export const useDeleteAdditionalCost = <TData = Awaited<ReturnType<typeof deleteAdditionalCost>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAdditionalCostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Project
 */
export const getProject = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Project>(
      {url: `/api/production/project/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProjectQueryKey = (id: number,) => {
    return [`/api/production/project/${id}`] as const;
    }

    
export const getGetProjectQueryOptions = <TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({ signal }) => getProject(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProjectQueryResult = NonNullable<Awaited<ReturnType<typeof getProject>>>
export type GetProjectQueryError = ErrorResponse


export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProjectQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProjectSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({ signal }) => getProject(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProjectSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProject>>>
export type GetProjectSuspenseQueryError = ErrorResponse


export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProjectSuspense<TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProjectSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Project
 */
export const updateProject = (
    id: number,
    project: Project,
 ) => {
      
      
      return customMutator<Project>(
      {url: `/api/production/project/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: project
    },
      );
    }
  


export const getUpdateProjectMutationOptions = <TData = Awaited<ReturnType<typeof updateProject>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Project}, TContext>, }
) => {
const mutationKey = ['updateProject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProject>>, {id: number;data: Project}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProject(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Project}, TContext>}

    export type UpdateProjectMutationResult = NonNullable<Awaited<ReturnType<typeof updateProject>>>
    export type UpdateProjectMutationBody = Project
    export type UpdateProjectMutationError = ErrorResponse

    export const useUpdateProject = <TData = Awaited<ReturnType<typeof updateProject>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Project}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Project},
        TContext
      > => {

      const mutationOptions = getUpdateProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Project
 */
export const deleteProject = (
    id: number,
 ) => {
      
      
      return customMutator<Project>(
      {url: `/api/production/project/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProjectMutationOptions = <TData = Awaited<ReturnType<typeof deleteProject>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteProject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProject>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProject(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteProjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProject>>>
    
    export type DeleteProjectMutationError = ResponseBase

    export const useDeleteProject = <TData = Awaited<ReturnType<typeof deleteProject>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Time Keeping
 */
export const getTimeKeeping = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeKeeping>(
      {url: `/api/hr/timekeeping/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetTimeKeepingQueryKey = (id: number,) => {
    return [`/api/hr/timekeeping/${id}`] as const;
    }

    
export const getGetTimeKeepingQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeeping>>> = ({ signal }) => getTimeKeeping(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeeping>>>
export type GetTimeKeepingQueryError = ErrorResponse


export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeeping>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeeping>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeeping<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeKeepingSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeeping>>> = ({ signal }) => getTimeKeeping(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeeping>>>
export type GetTimeKeepingSuspenseQueryError = ErrorResponse


export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeepingSuspense<TData = Awaited<ReturnType<typeof getTimeKeeping>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeeping>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Time Keeping
 */
export const updateTimeKeeping = (
    id: number,
    timeKeeping: TimeKeeping,
 ) => {
      
      
      return customMutator<TimeKeeping>(
      {url: `/api/hr/timekeeping/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: timeKeeping
    },
      );
    }
  


export const getUpdateTimeKeepingMutationOptions = <TData = Awaited<ReturnType<typeof updateTimeKeeping>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeKeeping}, TContext>, }
) => {
const mutationKey = ['updateTimeKeeping'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTimeKeeping>>, {id: number;data: TimeKeeping}> = (props) => {
          const {id,data} = props ?? {};

          return  updateTimeKeeping(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: TimeKeeping}, TContext>}

    export type UpdateTimeKeepingMutationResult = NonNullable<Awaited<ReturnType<typeof updateTimeKeeping>>>
    export type UpdateTimeKeepingMutationBody = TimeKeeping
    export type UpdateTimeKeepingMutationError = ErrorResponse

    export const useUpdateTimeKeeping = <TData = Awaited<ReturnType<typeof updateTimeKeeping>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeKeeping}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: TimeKeeping},
        TContext
      > => {

      const mutationOptions = getUpdateTimeKeepingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Time Keeping by document reference
 */
export const deleteTimeKeeping = (
    id: number,
 ) => {
      
      
      return customMutator<TimeKeeping>(
      {url: `/api/hr/timekeeping/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteTimeKeepingMutationOptions = <TData = Awaited<ReturnType<typeof deleteTimeKeeping>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteTimeKeeping'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTimeKeeping>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteTimeKeeping(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteTimeKeepingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTimeKeeping>>>
    
    export type DeleteTimeKeepingMutationError = ResponseBase

    export const useDeleteTimeKeeping = <TData = Awaited<ReturnType<typeof deleteTimeKeeping>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteTimeKeepingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Employee
 */
export const getEmployee = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Employee>(
      {url: `/api/hr/employee/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetEmployeeQueryKey = (id: number,) => {
    return [`/api/hr/employee/${id}`] as const;
    }

    
export const getGetEmployeeQueryOptions = <TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployee>>> = ({ signal }) => getEmployee(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployee>>>
export type GetEmployeeQueryError = ErrorResponse


export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployee>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployee>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployee<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetEmployeeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployee>>> = ({ signal }) => getEmployee(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployee>>>
export type GetEmployeeSuspenseQueryError = ErrorResponse


export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeeSuspense<TData = Awaited<ReturnType<typeof getEmployee>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployee>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Employee
 */
export const updateEmployee = (
    id: number,
    employee: Employee,
 ) => {
      
      
      return customMutator<Employee>(
      {url: `/api/hr/employee/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: employee
    },
      );
    }
  


export const getUpdateEmployeeMutationOptions = <TData = Awaited<ReturnType<typeof updateEmployee>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Employee}, TContext>, }
) => {
const mutationKey = ['updateEmployee'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEmployee>>, {id: number;data: Employee}> = (props) => {
          const {id,data} = props ?? {};

          return  updateEmployee(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Employee}, TContext>}

    export type UpdateEmployeeMutationResult = NonNullable<Awaited<ReturnType<typeof updateEmployee>>>
    export type UpdateEmployeeMutationBody = Employee
    export type UpdateEmployeeMutationError = ErrorResponse

    export const useUpdateEmployee = <TData = Awaited<ReturnType<typeof updateEmployee>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Employee}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Employee},
        TContext
      > => {

      const mutationOptions = getUpdateEmployeeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Employee by document reference
 */
export const deleteEmployee = (
    id: number,
 ) => {
      
      
      return customMutator<Employee>(
      {url: `/api/hr/employee/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEmployeeMutationOptions = <TData = Awaited<ReturnType<typeof deleteEmployee>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteEmployee'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEmployee>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteEmployee(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteEmployeeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEmployee>>>
    
    export type DeleteEmployeeMutationError = unknown

    export const useDeleteEmployee = <TData = Awaited<ReturnType<typeof deleteEmployee>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteEmployeeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get TimeOff
 */
export const getTimeOff = (
    id: number,
    timeOffId: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeOff>(
      {url: `/api/hr/employee/${id}/timeoff/${timeOffId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetTimeOffQueryKey = (id: number,
    timeOffId: number,) => {
    return [`/api/hr/employee/${id}/timeoff/${timeOffId}`] as const;
    }

    
export const getGetTimeOffQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffQueryKey(id,timeOffId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOff>>> = ({ signal }) => getTimeOff(id,timeOffId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id && timeOffId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOff>>>
export type GetTimeOffQueryError = ResponseBase


export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOff>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOff>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOff<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffQueryOptions(id,timeOffId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeOffSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffQueryKey(id,timeOffId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOff>>> = ({ signal }) => getTimeOff(id,timeOffId, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOff>>>
export type GetTimeOffSuspenseQueryError = ResponseBase


export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOffSuspense<TData = Awaited<ReturnType<typeof getTimeOff>>, TError = ResponseBase>(
 id: number,
    timeOffId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOff>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffSuspenseQueryOptions(id,timeOffId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Timeoff
 */
export const updateTimeoff = (
    id: number,
    timeOffId: number,
    timeOff: TimeOff,
 ) => {
      
      
      return customMutator<TimeOff>(
      {url: `/api/hr/employee/${id}/timeoff/${timeOffId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: timeOff
    },
      );
    }
  


export const getUpdateTimeoffMutationOptions = <TData = Awaited<ReturnType<typeof updateTimeoff>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number;data: TimeOff}, TContext>, }
) => {
const mutationKey = ['updateTimeoff'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTimeoff>>, {id: number;timeOffId: number;data: TimeOff}> = (props) => {
          const {id,timeOffId,data} = props ?? {};

          return  updateTimeoff(id,timeOffId,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;timeOffId: number;data: TimeOff}, TContext>}

    export type UpdateTimeoffMutationResult = NonNullable<Awaited<ReturnType<typeof updateTimeoff>>>
    export type UpdateTimeoffMutationBody = TimeOff
    export type UpdateTimeoffMutationError = ErrorResponse

    export const useUpdateTimeoff = <TData = Awaited<ReturnType<typeof updateTimeoff>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number;data: TimeOff}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;timeOffId: number;data: TimeOff},
        TContext
      > => {

      const mutationOptions = getUpdateTimeoffMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete TimeOff
 */
export const deleteTimeOff = (
    id: number,
    timeOffId: number,
 ) => {
      
      
      return customMutator<TimeOff>(
      {url: `/api/hr/employee/${id}/timeoff/${timeOffId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteTimeOffMutationOptions = <TData = Awaited<ReturnType<typeof deleteTimeOff>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number}, TContext>, }
) => {
const mutationKey = ['deleteTimeOff'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTimeOff>>, {id: number;timeOffId: number}> = (props) => {
          const {id,timeOffId} = props ?? {};

          return  deleteTimeOff(id,timeOffId,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;timeOffId: number}, TContext>}

    export type DeleteTimeOffMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTimeOff>>>
    
    export type DeleteTimeOffMutationError = ResponseBase

    export const useDeleteTimeOff = <TData = Awaited<ReturnType<typeof deleteTimeOff>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;timeOffId: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;timeOffId: number},
        TContext
      > => {

      const mutationOptions = getDeleteTimeOffMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update Employee Payment
 */
export const updateEmployeePayments = (
    id: number,
    employeePayment: EmployeePayment[],
 ) => {
      
      
      return customMutator<EmployeePayment[]>(
      {url: `/api/hr/employee/${id}/payment`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: employeePayment
    },
      );
    }
  


export const getUpdateEmployeePaymentsMutationOptions = <TData = Awaited<ReturnType<typeof updateEmployeePayments>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, }
) => {
const mutationKey = ['updateEmployeePayments'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEmployeePayments>>, {id: number;data: EmployeePayment[]}> = (props) => {
          const {id,data} = props ?? {};

          return  updateEmployeePayments(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>}

    export type UpdateEmployeePaymentsMutationResult = NonNullable<Awaited<ReturnType<typeof updateEmployeePayments>>>
    export type UpdateEmployeePaymentsMutationBody = EmployeePayment[]
    export type UpdateEmployeePaymentsMutationError = ErrorResponse

    export const useUpdateEmployeePayments = <TData = Awaited<ReturnType<typeof updateEmployeePayments>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeePayment[]},
        TContext
      > => {

      const mutationOptions = getUpdateEmployeePaymentsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Employee Payments
 */
export const addEmployeePayment = (
    id: number,
    employeePayment: EmployeePayment[],
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeePayment[]>(
      {url: `/api/hr/employee/${id}/payment`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: employeePayment, signal
    },
      );
    }
  


export const getAddEmployeePaymentMutationOptions = <TData = Awaited<ReturnType<typeof addEmployeePayment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, }
) => {
const mutationKey = ['addEmployeePayment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addEmployeePayment>>, {id: number;data: EmployeePayment[]}> = (props) => {
          const {id,data} = props ?? {};

          return  addEmployeePayment(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>}

    export type AddEmployeePaymentMutationResult = NonNullable<Awaited<ReturnType<typeof addEmployeePayment>>>
    export type AddEmployeePaymentMutationBody = EmployeePayment[]
    export type AddEmployeePaymentMutationError = ErrorResponse

    export const useAddEmployeePayment = <TData = Awaited<ReturnType<typeof addEmployeePayment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeePayment[]}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeePayment[]},
        TContext
      > => {

      const mutationOptions = getAddEmployeePaymentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update Employee Overtime
 */
export const updateEmployeeOvertimes = (
    id: number,
    employeeOvertime: EmployeeOvertime[],
 ) => {
      
      
      return customMutator<EmployeeOvertime[]>(
      {url: `/api/hr/employee/${id}/overtime`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: employeeOvertime
    },
      );
    }
  


export const getUpdateEmployeeOvertimesMutationOptions = <TData = Awaited<ReturnType<typeof updateEmployeeOvertimes>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, }
) => {
const mutationKey = ['updateEmployeeOvertimes'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEmployeeOvertimes>>, {id: number;data: EmployeeOvertime[]}> = (props) => {
          const {id,data} = props ?? {};

          return  updateEmployeeOvertimes(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>}

    export type UpdateEmployeeOvertimesMutationResult = NonNullable<Awaited<ReturnType<typeof updateEmployeeOvertimes>>>
    export type UpdateEmployeeOvertimesMutationBody = EmployeeOvertime[]
    export type UpdateEmployeeOvertimesMutationError = ErrorResponse

    export const useUpdateEmployeeOvertimes = <TData = Awaited<ReturnType<typeof updateEmployeeOvertimes>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeeOvertime[]},
        TContext
      > => {

      const mutationOptions = getUpdateEmployeeOvertimesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Employee Overtimes
 */
export const addEmployeeOvertimes = (
    id: number,
    employeeOvertime: EmployeeOvertime[],
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeeOvertime[]>(
      {url: `/api/hr/employee/${id}/overtime`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: employeeOvertime, signal
    },
      );
    }
  


export const getAddEmployeeOvertimesMutationOptions = <TData = Awaited<ReturnType<typeof addEmployeeOvertimes>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, }
) => {
const mutationKey = ['addEmployeeOvertimes'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addEmployeeOvertimes>>, {id: number;data: EmployeeOvertime[]}> = (props) => {
          const {id,data} = props ?? {};

          return  addEmployeeOvertimes(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>}

    export type AddEmployeeOvertimesMutationResult = NonNullable<Awaited<ReturnType<typeof addEmployeeOvertimes>>>
    export type AddEmployeeOvertimesMutationBody = EmployeeOvertime[]
    export type AddEmployeeOvertimesMutationError = ErrorResponse

    export const useAddEmployeeOvertimes = <TData = Awaited<ReturnType<typeof addEmployeeOvertimes>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: EmployeeOvertime[]}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: EmployeeOvertime[]},
        TContext
      > => {

      const mutationOptions = getAddEmployeeOvertimesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Bank Branch
 */
export const getBankBranch = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<BankBranch>(
      {url: `/api/finance/bankBranch/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetBankBranchQueryKey = (id: number,) => {
    return [`/api/finance/bankBranch/${id}`] as const;
    }

    
export const getGetBankBranchQueryOptions = <TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankBranch>>> = ({ signal }) => getBankBranch(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankBranchQueryResult = NonNullable<Awaited<ReturnType<typeof getBankBranch>>>
export type GetBankBranchQueryError = unknown


export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankBranch>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankBranch>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankBranch<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankBranchQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBankBranchSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankBranch>>> = ({ signal }) => getBankBranch(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankBranchSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBankBranch>>>
export type GetBankBranchSuspenseQueryError = unknown


export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankBranchSuspense<TData = Awaited<ReturnType<typeof getBankBranch>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankBranchSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Bank Branch
 */
export const updateBankbranch = (
    id: number,
    bankBranch: BankBranch,
 ) => {
      
      
      return customMutator<BankBranch>(
      {url: `/api/finance/bankBranch/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: bankBranch
    },
      );
    }
  


export const getUpdateBankbranchMutationOptions = <TData = Awaited<ReturnType<typeof updateBankbranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankBranch}, TContext>, }
) => {
const mutationKey = ['updateBankbranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBankbranch>>, {id: number;data: BankBranch}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBankbranch(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: BankBranch}, TContext>}

    export type UpdateBankbranchMutationResult = NonNullable<Awaited<ReturnType<typeof updateBankbranch>>>
    export type UpdateBankbranchMutationBody = BankBranch
    export type UpdateBankbranchMutationError = ErrorResponse

    export const useUpdateBankbranch = <TData = Awaited<ReturnType<typeof updateBankbranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankBranch}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: BankBranch},
        TContext
      > => {

      const mutationOptions = getUpdateBankbranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Bank Branch
 */
export const deleteBankBranch = (
    id: number,
 ) => {
      
      
      return customMutator<BankBranch>(
      {url: `/api/finance/bankBranch/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBankBranchMutationOptions = <TData = Awaited<ReturnType<typeof deleteBankBranch>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteBankBranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBankBranch>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBankBranch(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBankBranchMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBankBranch>>>
    
    export type DeleteBankBranchMutationError = ResponseBase

    export const useDeleteBankBranch = <TData = Awaited<ReturnType<typeof deleteBankBranch>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBankBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Bank Account
 */
export const getBankAccount = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<BankAccount>(
      {url: `/api/finance/bankAccount/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetBankAccountQueryKey = (id: number,) => {
    return [`/api/finance/bankAccount/${id}`] as const;
    }

    
export const getGetBankAccountQueryOptions = <TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankAccount>>> = ({ signal }) => getBankAccount(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getBankAccount>>>
export type GetBankAccountQueryError = unknown


export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankAccount<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBankAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankAccount>>> = ({ signal }) => getBankAccount(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBankAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBankAccount>>>
export type GetBankAccountSuspenseQueryError = unknown


export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBankAccountSuspense<TData = Awaited<ReturnType<typeof getBankAccount>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBankAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBankAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Bank Account
 */
export const updateBankAccount = (
    id: number,
    bankAccount: BankAccount,
 ) => {
      
      
      return customMutator<BankAccount>(
      {url: `/api/finance/bankAccount/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: bankAccount
    },
      );
    }
  


export const getUpdateBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankAccount}, TContext>, }
) => {
const mutationKey = ['updateBankAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBankAccount>>, {id: number;data: BankAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBankAccount(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: BankAccount}, TContext>}

    export type UpdateBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateBankAccount>>>
    export type UpdateBankAccountMutationBody = BankAccount
    export type UpdateBankAccountMutationError = ErrorResponse

    export const useUpdateBankAccount = <TData = Awaited<ReturnType<typeof updateBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: BankAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: BankAccount},
        TContext
      > => {

      const mutationOptions = getUpdateBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Bank Account
 */
export const deleteBankAccount = (
    id: number,
 ) => {
      
      
      return customMutator<BankAccount>(
      {url: `/api/finance/bankAccount/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteBankAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteBankAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBankAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBankAccount(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBankAccount>>>
    
    export type DeleteBankAccountMutationError = ResponseBase

    export const useDeleteBankAccount = <TData = Awaited<ReturnType<typeof deleteBankAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Bank
 */
export const getDepartment = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Bank>(
      {url: `/api/finance/bank/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDepartmentQueryKey = (id: number,) => {
    return [`/api/finance/bank/${id}`] as const;
    }

    
export const getGetDepartmentQueryOptions = <TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartmentQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment>>> = ({ signal }) => getDepartment(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartmentQueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment>>>
export type GetDepartmentQueryError = ErrorResponse


export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartment<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartmentQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepartmentSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartmentQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment>>> = ({ signal }) => getDepartment(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartmentSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment>>>
export type GetDepartmentSuspenseQueryError = ErrorResponse


export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartmentSuspense<TData = Awaited<ReturnType<typeof getDepartment>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartmentSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Bank
 */
export const updateBank = (
    id: number,
    bank: Bank,
 ) => {
      
      
      return customMutator<Bank>(
      {url: `/api/finance/bank/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: bank
    },
      );
    }
  


export const getUpdateBankMutationOptions = <TData = Awaited<ReturnType<typeof updateBank>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Bank}, TContext>, }
) => {
const mutationKey = ['updateBank'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBank>>, {id: number;data: Bank}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBank(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Bank}, TContext>}

    export type UpdateBankMutationResult = NonNullable<Awaited<ReturnType<typeof updateBank>>>
    export type UpdateBankMutationBody = Bank
    export type UpdateBankMutationError = ErrorResponse

    export const useUpdateBank = <TData = Awaited<ReturnType<typeof updateBank>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Bank}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Bank},
        TContext
      > => {

      const mutationOptions = getUpdateBankMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete bank
 */
export const deleteBank = (
    id: number,
 ) => {
      
      
      return customMutator<Bank>(
      {url: `/api/finance/bank/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBankMutationOptions = <TData = Awaited<ReturnType<typeof deleteBank>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteBank'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBank>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBank(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBankMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBank>>>
    
    export type DeleteBankMutationError = ResponseBase

    export const useDeleteBank = <TData = Awaited<ReturnType<typeof deleteBank>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBankMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Department
 */
export const getDepartment1 = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Department>(
      {url: `/api/company/department/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDepartment1QueryKey = (id: number,) => {
    return [`/api/company/department/${id}`] as const;
    }

    
export const getGetDepartment1QueryOptions = <TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartment1QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment1>>> = ({ signal }) => getDepartment1(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartment1QueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment1>>>
export type GetDepartment1QueryError = ErrorResponse


export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment1>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepartment1>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartment1<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartment1QueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepartment1SuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartment1QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartment1>>> = ({ signal }) => getDepartment1(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepartment1SuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepartment1>>>
export type GetDepartment1SuspenseQueryError = ErrorResponse


export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepartment1Suspense<TData = Awaited<ReturnType<typeof getDepartment1>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepartment1>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepartment1SuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Department
 */
export const updateDepartment = (
    id: number,
    department: Department,
 ) => {
      
      
      return customMutator<Department>(
      {url: `/api/company/department/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: department
    },
      );
    }
  


export const getUpdateDepartmentMutationOptions = <TData = Awaited<ReturnType<typeof updateDepartment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Department}, TContext>, }
) => {
const mutationKey = ['updateDepartment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDepartment>>, {id: number;data: Department}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDepartment(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Department}, TContext>}

    export type UpdateDepartmentMutationResult = NonNullable<Awaited<ReturnType<typeof updateDepartment>>>
    export type UpdateDepartmentMutationBody = Department
    export type UpdateDepartmentMutationError = ErrorResponse

    export const useUpdateDepartment = <TData = Awaited<ReturnType<typeof updateDepartment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Department}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Department},
        TContext
      > => {

      const mutationOptions = getUpdateDepartmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Department
 */
export const deleteDepartment = (
    id: number,
 ) => {
      
      
      return customMutator<Department>(
      {url: `/api/company/department/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDepartmentMutationOptions = <TData = Awaited<ReturnType<typeof deleteDepartment>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteDepartment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDepartment>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteDepartment(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteDepartmentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDepartment>>>
    
    export type DeleteDepartmentMutationError = ResponseBase

    export const useDeleteDepartment = <TData = Awaited<ReturnType<typeof deleteDepartment>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteDepartmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Branch
 */
export const getBranch = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Branch>(
      {url: `/api/company/branch/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetBranchQueryKey = (id: number,) => {
    return [`/api/company/branch/${id}`] as const;
    }

    
export const getGetBranchQueryOptions = <TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranch>>> = ({ signal }) => getBranch(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBranchQueryResult = NonNullable<Awaited<ReturnType<typeof getBranch>>>
export type GetBranchQueryError = ErrorResponse


export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranch>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranch>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBranchQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBranchSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranch>>> = ({ signal }) => getBranch(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBranchSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBranch>>>
export type GetBranchSuspenseQueryError = ErrorResponse


export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetBranchSuspense<TData = Awaited<ReturnType<typeof getBranch>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBranchSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Branch
 */
export const updateBranch = (
    id: number,
    branch: Branch,
 ) => {
      
      
      return customMutator<Branch>(
      {url: `/api/company/branch/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: branch
    },
      );
    }
  


export const getUpdateBranchMutationOptions = <TData = Awaited<ReturnType<typeof updateBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Branch}, TContext>, }
) => {
const mutationKey = ['updateBranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBranch>>, {id: number;data: Branch}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBranch(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Branch}, TContext>}

    export type UpdateBranchMutationResult = NonNullable<Awaited<ReturnType<typeof updateBranch>>>
    export type UpdateBranchMutationBody = Branch
    export type UpdateBranchMutationError = ErrorResponse

    export const useUpdateBranch = <TData = Awaited<ReturnType<typeof updateBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Branch}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Branch},
        TContext
      > => {

      const mutationOptions = getUpdateBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Branch
 */
export const deleteBranch = (
    id: number,
 ) => {
      
      
      return customMutator<Branch>(
      {url: `/api/company/branch/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBranchMutationOptions = <TData = Awaited<ReturnType<typeof deleteBranch>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteBranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBranch>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBranch(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteBranchMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBranch>>>
    
    export type DeleteBranchMutationError = ResponseBase

    export const useDeleteBranch = <TData = Awaited<ReturnType<typeof deleteBranch>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Section
 */
export const getSection = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Section>(
      {url: `/api/admin/section/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetSectionQueryKey = (id: number,) => {
    return [`/api/admin/section/${id}`] as const;
    }

    
export const getGetSectionQueryOptions = <TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSectionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSection>>> = ({ signal }) => getSection(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSectionQueryResult = NonNullable<Awaited<ReturnType<typeof getSection>>>
export type GetSectionQueryError = ErrorResponse


export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSection>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSection>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSection<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSectionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSectionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSectionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSection>>> = ({ signal }) => getSection(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSectionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSection>>>
export type GetSectionSuspenseQueryError = ErrorResponse


export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSectionSuspense<TData = Awaited<ReturnType<typeof getSection>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSection>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSectionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Section
 */
export const updateSection = (
    id: number,
    section: Section,
 ) => {
      
      
      return customMutator<Section>(
      {url: `/api/admin/section/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: section
    },
      );
    }
  


export const getUpdateSectionMutationOptions = <TData = Awaited<ReturnType<typeof updateSection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Section}, TContext>, }
) => {
const mutationKey = ['updateSection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSection>>, {id: number;data: Section}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSection(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Section}, TContext>}

    export type UpdateSectionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSection>>>
    export type UpdateSectionMutationBody = Section
    export type UpdateSectionMutationError = ErrorResponse

    export const useUpdateSection = <TData = Awaited<ReturnType<typeof updateSection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Section}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Section},
        TContext
      > => {

      const mutationOptions = getUpdateSectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Section
 */
export const deleteSection = (
    id: number,
 ) => {
      
      
      return customMutator<Section>(
      {url: `/api/admin/section/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSectionMutationOptions = <TData = Awaited<ReturnType<typeof deleteSection>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteSection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSection>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteSection(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteSectionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSection>>>
    
    export type DeleteSectionMutationError = ResponseBase

    export const useDeleteSection = <TData = Awaited<ReturnType<typeof deleteSection>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteSectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Role
 */
export const getRole = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Role>(
      {url: `/api/admin/role/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetRoleQueryKey = (id: number,) => {
    return [`/api/admin/role/${id}`] as const;
    }

    
export const getGetRoleQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoleQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleQueryError = ErrorResponse


export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoleQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoleSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleSuspenseQueryError = ErrorResponse


export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoleSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Role
 */
export const updateRole = (
    id: number,
    role: Role,
 ) => {
      
      
      return customMutator<Role>(
      {url: `/api/admin/role/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: role
    },
      );
    }
  


export const getUpdateRoleMutationOptions = <TData = Awaited<ReturnType<typeof updateRole>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Role}, TContext>, }
) => {
const mutationKey = ['updateRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRole>>, {id: number;data: Role}> = (props) => {
          const {id,data} = props ?? {};

          return  updateRole(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Role}, TContext>}

    export type UpdateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateRole>>>
    export type UpdateRoleMutationBody = Role
    export type UpdateRoleMutationError = ErrorResponse

    export const useUpdateRole = <TData = Awaited<ReturnType<typeof updateRole>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Role}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Role},
        TContext
      > => {

      const mutationOptions = getUpdateRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Role
 */
export const deleteRole = (
    id: number,
 ) => {
      
      
      return customMutator<Role>(
      {url: `/api/admin/role/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteRoleMutationOptions = <TData = Awaited<ReturnType<typeof deleteRole>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRole>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteRole(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteRoleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRole>>>
    
    export type DeleteRoleMutationError = ResponseBase

    export const useDeleteRole = <TData = Awaited<ReturnType<typeof deleteRole>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Public Holiday
 */
export const getPublicHoliday = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PublicHoliday>(
      {url: `/api/admin/publicHoliday/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetPublicHolidayQueryKey = (id: number,) => {
    return [`/api/admin/publicHoliday/${id}`] as const;
    }

    
export const getGetPublicHolidayQueryOptions = <TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublicHolidayQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicHoliday>>> = ({ signal }) => getPublicHoliday(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPublicHolidayQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicHoliday>>>
export type GetPublicHolidayQueryError = ErrorResponse


export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicHoliday>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicHoliday>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPublicHoliday<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPublicHolidayQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPublicHolidaySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublicHolidayQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicHoliday>>> = ({ signal }) => getPublicHoliday(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPublicHolidaySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicHoliday>>>
export type GetPublicHolidaySuspenseQueryError = ErrorResponse


export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPublicHolidaySuspense<TData = Awaited<ReturnType<typeof getPublicHoliday>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPublicHoliday>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPublicHolidaySuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Public Holiday
 */
export const updatePublicHoliday = (
    id: number,
    publicHoliday: PublicHoliday,
 ) => {
      
      
      return customMutator<PublicHoliday>(
      {url: `/api/admin/publicHoliday/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: publicHoliday
    },
      );
    }
  


export const getUpdatePublicHolidayMutationOptions = <TData = Awaited<ReturnType<typeof updatePublicHoliday>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PublicHoliday}, TContext>, }
) => {
const mutationKey = ['updatePublicHoliday'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePublicHoliday>>, {id: number;data: PublicHoliday}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePublicHoliday(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: PublicHoliday}, TContext>}

    export type UpdatePublicHolidayMutationResult = NonNullable<Awaited<ReturnType<typeof updatePublicHoliday>>>
    export type UpdatePublicHolidayMutationBody = PublicHoliday
    export type UpdatePublicHolidayMutationError = ErrorResponse

    export const useUpdatePublicHoliday = <TData = Awaited<ReturnType<typeof updatePublicHoliday>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PublicHoliday}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: PublicHoliday},
        TContext
      > => {

      const mutationOptions = getUpdatePublicHolidayMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete PublicHoliday
 */
export const deletePublicHoliday = (
    id: number,
 ) => {
      
      
      return customMutator<PublicHoliday>(
      {url: `/api/admin/publicHoliday/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePublicHolidayMutationOptions = <TData = Awaited<ReturnType<typeof deletePublicHoliday>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deletePublicHoliday'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePublicHoliday>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deletePublicHoliday(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeletePublicHolidayMutationResult = NonNullable<Awaited<ReturnType<typeof deletePublicHoliday>>>
    
    export type DeletePublicHolidayMutationError = ResponseBase

    export const useDeletePublicHoliday = <TData = Awaited<ReturnType<typeof deletePublicHoliday>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeletePublicHolidayMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get PaymentMethod
 */
export const getPaymentMethod = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PaymentMethod>(
      {url: `/api/admin/paymentMethod/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetPaymentMethodQueryKey = (id: number,) => {
    return [`/api/admin/paymentMethod/${id}`] as const;
    }

    
export const getGetPaymentMethodQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentMethodQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentMethod>>> = ({ signal }) => getPaymentMethod(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPaymentMethodQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentMethod>>>
export type GetPaymentMethodQueryError = ErrorResponse


export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentMethod>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentMethod>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPaymentMethod<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPaymentMethodQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPaymentMethodSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentMethodQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentMethod>>> = ({ signal }) => getPaymentMethod(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPaymentMethodSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentMethod>>>
export type GetPaymentMethodSuspenseQueryError = ErrorResponse


export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPaymentMethodSuspense<TData = Awaited<ReturnType<typeof getPaymentMethod>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentMethod>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPaymentMethodSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update PaymentMethod
 */
export const updatePaymentMethod = (
    id: number,
    paymentMethod: PaymentMethod,
 ) => {
      
      
      return customMutator<PaymentMethod>(
      {url: `/api/admin/paymentMethod/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: paymentMethod
    },
      );
    }
  


export const getUpdatePaymentMethodMutationOptions = <TData = Awaited<ReturnType<typeof updatePaymentMethod>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PaymentMethod}, TContext>, }
) => {
const mutationKey = ['updatePaymentMethod'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePaymentMethod>>, {id: number;data: PaymentMethod}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePaymentMethod(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: PaymentMethod}, TContext>}

    export type UpdatePaymentMethodMutationResult = NonNullable<Awaited<ReturnType<typeof updatePaymentMethod>>>
    export type UpdatePaymentMethodMutationBody = PaymentMethod
    export type UpdatePaymentMethodMutationError = ErrorResponse

    export const useUpdatePaymentMethod = <TData = Awaited<ReturnType<typeof updatePaymentMethod>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PaymentMethod}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: PaymentMethod},
        TContext
      > => {

      const mutationOptions = getUpdatePaymentMethodMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete PaymentMethod
 */
export const deletePaymentMethod = (
    id: number,
 ) => {
      
      
      return customMutator<PaymentMethod>(
      {url: `/api/admin/paymentMethod/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePaymentMethodMutationOptions = <TData = Awaited<ReturnType<typeof deletePaymentMethod>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deletePaymentMethod'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePaymentMethod>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deletePaymentMethod(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeletePaymentMethodMutationResult = NonNullable<Awaited<ReturnType<typeof deletePaymentMethod>>>
    
    export type DeletePaymentMethodMutationError = ResponseBase

    export const useDeletePaymentMethod = <TData = Awaited<ReturnType<typeof deletePaymentMethod>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeletePaymentMethodMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Machine
 */
export const getMachine = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Machine>(
      {url: `/api/admin/machine/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetMachineQueryKey = (id: number,) => {
    return [`/api/admin/machine/${id}`] as const;
    }

    
export const getGetMachineQueryOptions = <TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMachineQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMachine>>> = ({ signal }) => getMachine(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMachineQueryResult = NonNullable<Awaited<ReturnType<typeof getMachine>>>
export type GetMachineQueryError = ErrorResponse


export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMachine>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMachine>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMachine<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMachineQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMachineSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMachineQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMachine>>> = ({ signal }) => getMachine(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMachineSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMachine>>>
export type GetMachineSuspenseQueryError = ErrorResponse


export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMachineSuspense<TData = Awaited<ReturnType<typeof getMachine>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMachine>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMachineSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Machine
 */
export const updateMachine = (
    id: number,
    machine: Machine,
 ) => {
      
      
      return customMutator<Machine>(
      {url: `/api/admin/machine/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: machine
    },
      );
    }
  


export const getUpdateMachineMutationOptions = <TData = Awaited<ReturnType<typeof updateMachine>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Machine}, TContext>, }
) => {
const mutationKey = ['updateMachine'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMachine>>, {id: number;data: Machine}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMachine(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Machine}, TContext>}

    export type UpdateMachineMutationResult = NonNullable<Awaited<ReturnType<typeof updateMachine>>>
    export type UpdateMachineMutationBody = Machine
    export type UpdateMachineMutationError = ErrorResponse

    export const useUpdateMachine = <TData = Awaited<ReturnType<typeof updateMachine>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Machine}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Machine},
        TContext
      > => {

      const mutationOptions = getUpdateMachineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Machine
 */
export const deleteMachine = (
    id: number,
 ) => {
      
      
      return customMutator<Machine>(
      {url: `/api/admin/machine/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteMachineMutationOptions = <TData = Awaited<ReturnType<typeof deleteMachine>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteMachine'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMachine>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteMachine(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteMachineMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMachine>>>
    
    export type DeleteMachineMutationError = ResponseBase

    export const useDeleteMachine = <TData = Awaited<ReturnType<typeof deleteMachine>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMachineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Depot
 */
export const getDepot = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Depot>(
      {url: `/api/admin/depot/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDepotQueryKey = (id: number,) => {
    return [`/api/admin/depot/${id}`] as const;
    }

    
export const getGetDepotQueryOptions = <TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepot>>> = ({ signal }) => getDepot(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotQueryResult = NonNullable<Awaited<ReturnType<typeof getDepot>>>
export type GetDepotQueryError = ErrorResponse


export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepot>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepot>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepot<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepotSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepot>>> = ({ signal }) => getDepot(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepot>>>
export type GetDepotSuspenseQueryError = ErrorResponse


export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepotSuspense<TData = Awaited<ReturnType<typeof getDepot>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepot>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Depot
 */
export const updateDepot = (
    id: number,
    depot: Depot,
 ) => {
      
      
      return customMutator<Depot>(
      {url: `/api/admin/depot/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: depot
    },
      );
    }
  


export const getUpdateDepotMutationOptions = <TData = Awaited<ReturnType<typeof updateDepot>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Depot}, TContext>, }
) => {
const mutationKey = ['updateDepot'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDepot>>, {id: number;data: Depot}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDepot(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Depot}, TContext>}

    export type UpdateDepotMutationResult = NonNullable<Awaited<ReturnType<typeof updateDepot>>>
    export type UpdateDepotMutationBody = Depot
    export type UpdateDepotMutationError = ErrorResponse

    export const useUpdateDepot = <TData = Awaited<ReturnType<typeof updateDepot>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Depot}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Depot},
        TContext
      > => {

      const mutationOptions = getUpdateDepotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Depot
 */
export const deleteDepot = (
    id: number,
 ) => {
      
      
      return customMutator<Depot>(
      {url: `/api/admin/depot/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDepotMutationOptions = <TData = Awaited<ReturnType<typeof deleteDepot>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteDepot'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDepot>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteDepot(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteDepotMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDepot>>>
    
    export type DeleteDepotMutationError = ResponseBase

    export const useDeleteDepot = <TData = Awaited<ReturnType<typeof deleteDepot>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteDepotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Company
 */
export const getCompany = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Company>(
      {url: `/api/admin/company/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCompanyQueryKey = (id: number,) => {
    return [`/api/admin/company/${id}`] as const;
    }

    
export const getGetCompanyQueryOptions = <TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCompanyQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompany>>> = ({ signal }) => getCompany(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCompanyQueryResult = NonNullable<Awaited<ReturnType<typeof getCompany>>>
export type GetCompanyQueryError = ErrorResponse


export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompany>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompany>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCompany<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCompanyQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCompanySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCompanyQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompany>>> = ({ signal }) => getCompany(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCompanySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCompany>>>
export type GetCompanySuspenseQueryError = ErrorResponse


export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCompanySuspense<TData = Awaited<ReturnType<typeof getCompany>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompany>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCompanySuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update Company
 */
export const updateCompany = (
    id: number,
    company: Company,
 ) => {
      
      
      return customMutator<Company>(
      {url: `/api/admin/company/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: company
    },
      );
    }
  


export const getUpdateCompanyMutationOptions = <TData = Awaited<ReturnType<typeof updateCompany>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Company}, TContext>, }
) => {
const mutationKey = ['updateCompany'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCompany>>, {id: number;data: Company}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCompany(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Company}, TContext>}

    export type UpdateCompanyMutationResult = NonNullable<Awaited<ReturnType<typeof updateCompany>>>
    export type UpdateCompanyMutationBody = Company
    export type UpdateCompanyMutationError = ErrorResponse

    export const useUpdateCompany = <TData = Awaited<ReturnType<typeof updateCompany>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Company}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Company},
        TContext
      > => {

      const mutationOptions = getUpdateCompanyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete Company
 */
export const deleteCompany = (
    id: number,
 ) => {
      
      
      return customMutator<Company>(
      {url: `/api/admin/company/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCompanyMutationOptions = <TData = Awaited<ReturnType<typeof deleteCompany>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCompany'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCompany>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCompany(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCompanyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCompany>>>
    
    export type DeleteCompanyMutationError = ResponseBase

    export const useDeleteCompany = <TData = Awaited<ReturnType<typeof deleteCompany>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCompanyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ExpenseInvoice
 */
export const getExpenseInvoice = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseInvoice>(
      {url: `/api/accounting/expenseInvoice/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetExpenseInvoiceQueryKey = (id: number,) => {
    return [`/api/accounting/expenseInvoice/${id}`] as const;
    }

    
export const getGetExpenseInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseInvoice>>> = ({ signal }) => getExpenseInvoice(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseInvoice>>>
export type GetExpenseInvoiceQueryError = ErrorResponse


export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseInvoice>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseInvoice<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseInvoiceQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExpenseInvoiceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseInvoice>>> = ({ signal }) => getExpenseInvoice(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseInvoiceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseInvoice>>>
export type GetExpenseInvoiceSuspenseQueryError = ErrorResponse


export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseInvoiceSuspense<TData = Awaited<ReturnType<typeof getExpenseInvoice>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseInvoice>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseInvoiceSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ExpenseInvoice
 */
export const updateExpenseInvoice = (
    id: number,
    expenseInvoice: ExpenseInvoice,
 ) => {
      
      
      return customMutator<ExpenseInvoice>(
      {url: `/api/accounting/expenseInvoice/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: expenseInvoice
    },
      );
    }
  


export const getUpdateExpenseInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof updateExpenseInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseInvoice}, TContext>, }
) => {
const mutationKey = ['updateExpenseInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExpenseInvoice>>, {id: number;data: ExpenseInvoice}> = (props) => {
          const {id,data} = props ?? {};

          return  updateExpenseInvoice(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ExpenseInvoice}, TContext>}

    export type UpdateExpenseInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof updateExpenseInvoice>>>
    export type UpdateExpenseInvoiceMutationBody = ExpenseInvoice
    export type UpdateExpenseInvoiceMutationError = ErrorResponse

    export const useUpdateExpenseInvoice = <TData = Awaited<ReturnType<typeof updateExpenseInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseInvoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ExpenseInvoice},
        TContext
      > => {

      const mutationOptions = getUpdateExpenseInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ExpenseInvoice
 */
export const deleteExpenseInvoice = (
    id: number,
 ) => {
      
      
      return customMutator<ExpenseInvoice>(
      {url: `/api/accounting/expenseInvoice/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteExpenseInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof deleteExpenseInvoice>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteExpenseInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteExpenseInvoice>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteExpenseInvoice(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteExpenseInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteExpenseInvoice>>>
    
    export type DeleteExpenseInvoiceMutationError = ResponseBase

    export const useDeleteExpenseInvoice = <TData = Awaited<ReturnType<typeof deleteExpenseInvoice>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteExpenseInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ExpenseCard
 */
export const getExpenseCard = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseCard>(
      {url: `/api/accounting/expenseCard/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetExpenseCardQueryKey = (id: number,) => {
    return [`/api/accounting/expenseCard/${id}`] as const;
    }

    
export const getGetExpenseCardQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseCard>>> = ({ signal }) => getExpenseCard(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseCardQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseCard>>>
export type GetExpenseCardQueryError = ErrorResponse


export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseCard>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseCard<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseCardQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExpenseCardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseCardQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseCard>>> = ({ signal }) => getExpenseCard(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExpenseCardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseCard>>>
export type GetExpenseCardSuspenseQueryError = ErrorResponse


export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExpenseCardSuspense<TData = Awaited<ReturnType<typeof getExpenseCard>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExpenseCard>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExpenseCardSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update ExpenseCard
 */
export const updateExpenseCard = (
    id: number,
    expenseCard: ExpenseCard,
 ) => {
      
      
      return customMutator<ExpenseCard>(
      {url: `/api/accounting/expenseCard/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: expenseCard
    },
      );
    }
  


export const getUpdateExpenseCardMutationOptions = <TData = Awaited<ReturnType<typeof updateExpenseCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseCard}, TContext>, }
) => {
const mutationKey = ['updateExpenseCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExpenseCard>>, {id: number;data: ExpenseCard}> = (props) => {
          const {id,data} = props ?? {};

          return  updateExpenseCard(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: ExpenseCard}, TContext>}

    export type UpdateExpenseCardMutationResult = NonNullable<Awaited<ReturnType<typeof updateExpenseCard>>>
    export type UpdateExpenseCardMutationBody = ExpenseCard
    export type UpdateExpenseCardMutationError = ErrorResponse

    export const useUpdateExpenseCard = <TData = Awaited<ReturnType<typeof updateExpenseCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: ExpenseCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: ExpenseCard},
        TContext
      > => {

      const mutationOptions = getUpdateExpenseCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete ExpenseCard
 */
export const deleteExpenseCard = (
    id: number,
 ) => {
      
      
      return customMutator<ExpenseCard>(
      {url: `/api/accounting/expenseCard/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteExpenseCardMutationOptions = <TData = Awaited<ReturnType<typeof deleteExpenseCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteExpenseCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteExpenseCard>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteExpenseCard(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteExpenseCardMutationResult = NonNullable<Awaited<ReturnType<typeof deleteExpenseCard>>>
    
    export type DeleteExpenseCardMutationError = ResponseBase

    export const useDeleteExpenseCard = <TData = Awaited<ReturnType<typeof deleteExpenseCard>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteExpenseCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get CashAccountTransaction
 */
export const getCashAccountTransaction = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccountTransaction>(
      {url: `/api/accounting/cashAccountTransaction/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCashAccountTransactionQueryKey = (id: number,) => {
    return [`/api/accounting/cashAccountTransaction/${id}`] as const;
    }

    
export const getGetCashAccountTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccountTransaction>>> = ({ signal }) => getCashAccountTransaction(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccountTransaction>>>
export type GetCashAccountTransactionQueryError = ErrorResponse


export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccountTransaction>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccountTransaction<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountTransactionQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCashAccountTransactionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountTransactionQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccountTransaction>>> = ({ signal }) => getCashAccountTransaction(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountTransactionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccountTransaction>>>
export type GetCashAccountTransactionSuspenseQueryError = ErrorResponse


export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccountTransactionSuspense<TData = Awaited<ReturnType<typeof getCashAccountTransaction>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccountTransaction>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountTransactionSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update CashAccountTransaction
 */
export const updateCashAccountTransaction = (
    id: number,
    cashAccountTransaction: CashAccountTransaction,
 ) => {
      
      
      return customMutator<CashAccountTransaction>(
      {url: `/api/accounting/cashAccountTransaction/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: cashAccountTransaction
    },
      );
    }
  


export const getUpdateCashAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof updateCashAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccountTransaction}, TContext>, }
) => {
const mutationKey = ['updateCashAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCashAccountTransaction>>, {id: number;data: CashAccountTransaction}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCashAccountTransaction(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CashAccountTransaction}, TContext>}

    export type UpdateCashAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof updateCashAccountTransaction>>>
    export type UpdateCashAccountTransactionMutationBody = CashAccountTransaction
    export type UpdateCashAccountTransactionMutationError = ErrorResponse

    export const useUpdateCashAccountTransaction = <TData = Awaited<ReturnType<typeof updateCashAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccountTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CashAccountTransaction},
        TContext
      > => {

      const mutationOptions = getUpdateCashAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete CashAccountTransaction
 */
export const deleteCashAccountTransaction = (
    id: number,
 ) => {
      
      
      return customMutator<CashAccountTransaction>(
      {url: `/api/accounting/cashAccountTransaction/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCashAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof deleteCashAccountTransaction>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCashAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCashAccountTransaction>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCashAccountTransaction(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCashAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCashAccountTransaction>>>
    
    export type DeleteCashAccountTransactionMutationError = ResponseBase

    export const useDeleteCashAccountTransaction = <TData = Awaited<ReturnType<typeof deleteCashAccountTransaction>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCashAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get CashAccount
 */
export const getCashAccount = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccount>(
      {url: `/api/accounting/cashAccount/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCashAccountQueryKey = (id: number,) => {
    return [`/api/accounting/cashAccount/${id}`] as const;
    }

    
export const getGetCashAccountQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccount>>> = ({ signal }) => getCashAccount(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccount>>>
export type GetCashAccountQueryError = ErrorResponse


export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCashAccount>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccount<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCashAccountSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCashAccountQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCashAccount>>> = ({ signal }) => getCashAccount(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCashAccountSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCashAccount>>>
export type GetCashAccountSuspenseQueryError = ErrorResponse


export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCashAccountSuspense<TData = Awaited<ReturnType<typeof getCashAccount>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCashAccount>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCashAccountSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update CashAccount
 */
export const updateCashAccount = (
    id: number,
    cashAccount: CashAccount,
 ) => {
      
      
      return customMutator<CashAccount>(
      {url: `/api/accounting/cashAccount/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: cashAccount
    },
      );
    }
  


export const getUpdateCashAccountMutationOptions = <TData = Awaited<ReturnType<typeof updateCashAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccount}, TContext>, }
) => {
const mutationKey = ['updateCashAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCashAccount>>, {id: number;data: CashAccount}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCashAccount(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: CashAccount}, TContext>}

    export type UpdateCashAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateCashAccount>>>
    export type UpdateCashAccountMutationBody = CashAccount
    export type UpdateCashAccountMutationError = ErrorResponse

    export const useUpdateCashAccount = <TData = Awaited<ReturnType<typeof updateCashAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: CashAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: CashAccount},
        TContext
      > => {

      const mutationOptions = getUpdateCashAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete CashAccount
 */
export const deleteCashAccount = (
    id: number,
 ) => {
      
      
      return customMutator<CashAccount>(
      {url: `/api/accounting/cashAccount/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCashAccountMutationOptions = <TData = Awaited<ReturnType<typeof deleteCashAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
) => {
const mutationKey = ['deleteCashAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCashAccount>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCashAccount(id,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type DeleteCashAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCashAccount>>>
    
    export type DeleteCashAccountMutationError = ResponseBase

    export const useDeleteCashAccount = <TData = Awaited<ReturnType<typeof deleteCashAccount>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCashAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Users. Supports filtering via rsql.
 */
export const users = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Users>(
      {url: `/api/user/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getUsersMutationOptions = <TData = Awaited<ReturnType<typeof users>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['users'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof users>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  users(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type UsersMutationResult = NonNullable<Awaited<ReturnType<typeof users>>>
    export type UsersMutationBody = FilteringRequest
    export type UsersMutationError = ErrorResponse

    export const useUsers = <TData = Awaited<ReturnType<typeof users>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getUsersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const refresh = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<RefreshResponse>(
      {url: `/api/user/refresh`, method: 'POST', signal
    },
      );
    }
  


export const getRefreshMutationOptions = <TData = Awaited<ReturnType<typeof refresh>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, }
) => {
const mutationKey = ['refresh'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refresh>>, void> = () => {
          

          return  refresh()
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type RefreshMutationResult = NonNullable<Awaited<ReturnType<typeof refresh>>>
    
    export type RefreshMutationError = ResponseBase

    export const useRefresh = <TData = Awaited<ReturnType<typeof refresh>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, }
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getRefreshMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const logout = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<Logout200>(
      {url: `/api/user/logout`, method: 'POST', signal
    },
      );
    }
  


export const getLogoutMutationOptions = <TData = Awaited<ReturnType<typeof logout>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, }
) => {
const mutationKey = ['logout'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout()
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = unknown

    export const useLogout = <TData = Awaited<ReturnType<typeof logout>>, TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, }
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Login erp user
 */
export const login = (
    loginRequest: LoginRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<LoginResponse>(
      {url: `/api/user/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      );
    }
  


export const getLoginMutationOptions = <TData = Awaited<ReturnType<typeof login>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: LoginRequest}, TContext>, }
) => {
const mutationKey = ['login'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: LoginRequest}, TContext>}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = ResponseBase

    export const useLogin = <TData = Awaited<ReturnType<typeof login>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: LoginRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Units. Supports filtering via rsql.
 */
export const units = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Units>(
      {url: `/api/storage/units`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getUnitsMutationOptions = <TData = Awaited<ReturnType<typeof units>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['units'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof units>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  units(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type UnitsMutationResult = NonNullable<Awaited<ReturnType<typeof units>>>
    export type UnitsMutationBody = FilteringRequest
    export type UnitsMutationError = ErrorResponse

    export const useUnits = <TData = Awaited<ReturnType<typeof units>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getUnitsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Unit
 */
export const addUnit = (
    unit: Unit,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Unit>(
      {url: `/api/storage/unit`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: unit, signal
    },
      );
    }
  


export const getAddUnitMutationOptions = <TData = Awaited<ReturnType<typeof addUnit>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Unit}, TContext>, }
) => {
const mutationKey = ['addUnit'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUnit>>, {data: Unit}> = (props) => {
          const {data} = props ?? {};

          return  addUnit(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Unit}, TContext>}

    export type AddUnitMutationResult = NonNullable<Awaited<ReturnType<typeof addUnit>>>
    export type AddUnitMutationBody = Unit
    export type AddUnitMutationError = ErrorResponse

    export const useAddUnit = <TData = Awaited<ReturnType<typeof addUnit>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Unit}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Unit},
        TContext
      > => {

      const mutationOptions = getAddUnitMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Shelves. Supports filtering via rsql.
 */
export const shelves = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Shelves>(
      {url: `/api/storage/shelves`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getShelvesMutationOptions = <TData = Awaited<ReturnType<typeof shelves>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['shelves'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof shelves>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  shelves(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ShelvesMutationResult = NonNullable<Awaited<ReturnType<typeof shelves>>>
    export type ShelvesMutationBody = FilteringRequest
    export type ShelvesMutationError = ErrorResponse

    export const useShelves = <TData = Awaited<ReturnType<typeof shelves>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getShelvesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Shelf
 */
export const addShelf = (
    shelf: Shelf,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Shelf>(
      {url: `/api/storage/shelf`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: shelf, signal
    },
      );
    }
  


export const getAddShelfMutationOptions = <TData = Awaited<ReturnType<typeof addShelf>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Shelf}, TContext>, }
) => {
const mutationKey = ['addShelf'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addShelf>>, {data: Shelf}> = (props) => {
          const {data} = props ?? {};

          return  addShelf(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Shelf}, TContext>}

    export type AddShelfMutationResult = NonNullable<Awaited<ReturnType<typeof addShelf>>>
    export type AddShelfMutationBody = Shelf
    export type AddShelfMutationError = ErrorResponse

    export const useAddShelf = <TData = Awaited<ReturnType<typeof addShelf>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Shelf}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Shelf},
        TContext
      > => {

      const mutationOptions = getAddShelfMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List ServiceGroups. Supports filtering via rsql.
 */
export const serviceGroups = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceGroups>(
      {url: `/api/storage/serviceGroups`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getServiceGroupsMutationOptions = <TData = Awaited<ReturnType<typeof serviceGroups>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['serviceGroups'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof serviceGroups>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  serviceGroups(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ServiceGroupsMutationResult = NonNullable<Awaited<ReturnType<typeof serviceGroups>>>
    export type ServiceGroupsMutationBody = FilteringRequest
    export type ServiceGroupsMutationError = ErrorResponse

    export const useServiceGroups = <TData = Awaited<ReturnType<typeof serviceGroups>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getServiceGroupsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ServiceGroup
 */
export const addServiceGroup = (
    serviceGroup: ServiceGroup,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceGroup>(
      {url: `/api/storage/serviceGroup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: serviceGroup, signal
    },
      );
    }
  


export const getAddServiceGroupMutationOptions = <TData = Awaited<ReturnType<typeof addServiceGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceGroup}, TContext>, }
) => {
const mutationKey = ['addServiceGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addServiceGroup>>, {data: ServiceGroup}> = (props) => {
          const {data} = props ?? {};

          return  addServiceGroup(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ServiceGroup}, TContext>}

    export type AddServiceGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addServiceGroup>>>
    export type AddServiceGroupMutationBody = ServiceGroup
    export type AddServiceGroupMutationError = ErrorResponse

    export const useAddServiceGroup = <TData = Awaited<ReturnType<typeof addServiceGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ServiceGroup},
        TContext
      > => {

      const mutationOptions = getAddServiceGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List ServiceCards. Supports filtering via rsql.
 */
export const serviceCards = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceCards>(
      {url: `/api/storage/serviceCards`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getServiceCardsMutationOptions = <TData = Awaited<ReturnType<typeof serviceCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['serviceCards'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof serviceCards>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  serviceCards(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ServiceCardsMutationResult = NonNullable<Awaited<ReturnType<typeof serviceCards>>>
    export type ServiceCardsMutationBody = FilteringRequest
    export type ServiceCardsMutationError = ErrorResponse

    export const useServiceCards = <TData = Awaited<ReturnType<typeof serviceCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getServiceCardsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ServiceCard
 */
export const addServiceCard = (
    serviceCard: ServiceCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceCard>(
      {url: `/api/storage/serviceCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: serviceCard, signal
    },
      );
    }
  


export const getAddServiceCardMutationOptions = <TData = Awaited<ReturnType<typeof addServiceCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceCard}, TContext>, }
) => {
const mutationKey = ['addServiceCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addServiceCard>>, {data: ServiceCard}> = (props) => {
          const {data} = props ?? {};

          return  addServiceCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ServiceCard}, TContext>}

    export type AddServiceCardMutationResult = NonNullable<Awaited<ReturnType<typeof addServiceCard>>>
    export type AddServiceCardMutationBody = ServiceCard
    export type AddServiceCardMutationError = ErrorResponse

    export const useAddServiceCard = <TData = Awaited<ReturnType<typeof addServiceCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ServiceCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ServiceCard},
        TContext
      > => {

      const mutationOptions = getAddServiceCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List ProductGroups. Supports filtering via rsql.
 */
export const productGroups = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductGroups>(
      {url: `/api/storage/productGroups`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getProductGroupsMutationOptions = <TData = Awaited<ReturnType<typeof productGroups>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['productGroups'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof productGroups>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  productGroups(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ProductGroupsMutationResult = NonNullable<Awaited<ReturnType<typeof productGroups>>>
    export type ProductGroupsMutationBody = FilteringRequest
    export type ProductGroupsMutationError = ErrorResponse

    export const useProductGroups = <TData = Awaited<ReturnType<typeof productGroups>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getProductGroupsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ProductGroup
 */
export const addProductGroup = (
    productGroup: ProductGroup,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductGroup>(
      {url: `/api/storage/productGroup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productGroup, signal
    },
      );
    }
  


export const getAddProductGroupMutationOptions = <TData = Awaited<ReturnType<typeof addProductGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductGroup}, TContext>, }
) => {
const mutationKey = ['addProductGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProductGroup>>, {data: ProductGroup}> = (props) => {
          const {data} = props ?? {};

          return  addProductGroup(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ProductGroup}, TContext>}

    export type AddProductGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addProductGroup>>>
    export type AddProductGroupMutationBody = ProductGroup
    export type AddProductGroupMutationError = ErrorResponse

    export const useAddProductGroup = <TData = Awaited<ReturnType<typeof addProductGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ProductGroup},
        TContext
      > => {

      const mutationOptions = getAddProductGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List ProductCards. Supports filtering via rsql.
 */
export const productCards = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductCards>(
      {url: `/api/storage/productCards`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getProductCardsMutationOptions = <TData = Awaited<ReturnType<typeof productCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['productCards'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof productCards>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  productCards(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ProductCardsMutationResult = NonNullable<Awaited<ReturnType<typeof productCards>>>
    export type ProductCardsMutationBody = FilteringRequest
    export type ProductCardsMutationError = ErrorResponse

    export const useProductCards = <TData = Awaited<ReturnType<typeof productCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getProductCardsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ProductCard
 */
export const addProductCard = (
    productCard: ProductCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductCard>(
      {url: `/api/storage/productCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productCard, signal
    },
      );
    }
  


export const getAddProductCardMutationOptions = <TData = Awaited<ReturnType<typeof addProductCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductCard}, TContext>, }
) => {
const mutationKey = ['addProductCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProductCard>>, {data: ProductCard}> = (props) => {
          const {data} = props ?? {};

          return  addProductCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ProductCard}, TContext>}

    export type AddProductCardMutationResult = NonNullable<Awaited<ReturnType<typeof addProductCard>>>
    export type AddProductCardMutationBody = ProductCard
    export type AddProductCardMutationError = ErrorResponse

    export const useAddProductCard = <TData = Awaited<ReturnType<typeof addProductCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ProductCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ProductCard},
        TContext
      > => {

      const mutationOptions = getAddProductCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List MaterialGroups. Supports filtering via rsql.
 */
export const materialGroups = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialGroups>(
      {url: `/api/storage/materialGroups`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getMaterialGroupsMutationOptions = <TData = Awaited<ReturnType<typeof materialGroups>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['materialGroups'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof materialGroups>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  materialGroups(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type MaterialGroupsMutationResult = NonNullable<Awaited<ReturnType<typeof materialGroups>>>
    export type MaterialGroupsMutationBody = FilteringRequest
    export type MaterialGroupsMutationError = ErrorResponse

    export const useMaterialGroups = <TData = Awaited<ReturnType<typeof materialGroups>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getMaterialGroupsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new MaterialGroup
 */
export const addMaterialGroup = (
    materialGroup: MaterialGroup,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialGroup>(
      {url: `/api/storage/materialGroup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: materialGroup, signal
    },
      );
    }
  


export const getAddMaterialGroupMutationOptions = <TData = Awaited<ReturnType<typeof addMaterialGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialGroup}, TContext>, }
) => {
const mutationKey = ['addMaterialGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMaterialGroup>>, {data: MaterialGroup}> = (props) => {
          const {data} = props ?? {};

          return  addMaterialGroup(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: MaterialGroup}, TContext>}

    export type AddMaterialGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addMaterialGroup>>>
    export type AddMaterialGroupMutationBody = MaterialGroup
    export type AddMaterialGroupMutationError = ErrorResponse

    export const useAddMaterialGroup = <TData = Awaited<ReturnType<typeof addMaterialGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: MaterialGroup},
        TContext
      > => {

      const mutationOptions = getAddMaterialGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List MaterialCards. Supports filtering via rsql.
 */
export const materialCards = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialCards>(
      {url: `/api/storage/materialCards`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getMaterialCardsMutationOptions = <TData = Awaited<ReturnType<typeof materialCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['materialCards'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof materialCards>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  materialCards(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type MaterialCardsMutationResult = NonNullable<Awaited<ReturnType<typeof materialCards>>>
    export type MaterialCardsMutationBody = FilteringRequest
    export type MaterialCardsMutationError = ErrorResponse

    export const useMaterialCards = <TData = Awaited<ReturnType<typeof materialCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getMaterialCardsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new MaterialCard
 */
export const addMaterialCard = (
    materialCard: MaterialCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialCard>(
      {url: `/api/storage/materialCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: materialCard, signal
    },
      );
    }
  


export const getAddMaterialCardMutationOptions = <TData = Awaited<ReturnType<typeof addMaterialCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialCard}, TContext>, }
) => {
const mutationKey = ['addMaterialCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMaterialCard>>, {data: MaterialCard}> = (props) => {
          const {data} = props ?? {};

          return  addMaterialCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: MaterialCard}, TContext>}

    export type AddMaterialCardMutationResult = NonNullable<Awaited<ReturnType<typeof addMaterialCard>>>
    export type AddMaterialCardMutationBody = MaterialCard
    export type AddMaterialCardMutationError = ErrorResponse

    export const useAddMaterialCard = <TData = Awaited<ReturnType<typeof addMaterialCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: MaterialCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: MaterialCard},
        TContext
      > => {

      const mutationOptions = getAddMaterialCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Fixture Groups. Supports filtering via rsql.
 */
export const fixtureGroups = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureGroups>(
      {url: `/api/storage/fixtureGroups`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getFixtureGroupsMutationOptions = <TData = Awaited<ReturnType<typeof fixtureGroups>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['fixtureGroups'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof fixtureGroups>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  fixtureGroups(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type FixtureGroupsMutationResult = NonNullable<Awaited<ReturnType<typeof fixtureGroups>>>
    export type FixtureGroupsMutationBody = FilteringRequest
    export type FixtureGroupsMutationError = ErrorResponse

    export const useFixtureGroups = <TData = Awaited<ReturnType<typeof fixtureGroups>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getFixtureGroupsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new FixtureGroup
 */
export const addFixtureGroup = (
    fixtureGroup: FixtureGroup,
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureGroup>(
      {url: `/api/storage/fixtureGroup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: fixtureGroup, signal
    },
      );
    }
  


export const getAddFixtureGroupMutationOptions = <TData = Awaited<ReturnType<typeof addFixtureGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureGroup}, TContext>, }
) => {
const mutationKey = ['addFixtureGroup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFixtureGroup>>, {data: FixtureGroup}> = (props) => {
          const {data} = props ?? {};

          return  addFixtureGroup(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FixtureGroup}, TContext>}

    export type AddFixtureGroupMutationResult = NonNullable<Awaited<ReturnType<typeof addFixtureGroup>>>
    export type AddFixtureGroupMutationBody = FixtureGroup
    export type AddFixtureGroupMutationError = ErrorResponse

    export const useAddFixtureGroup = <TData = Awaited<ReturnType<typeof addFixtureGroup>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureGroup}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FixtureGroup},
        TContext
      > => {

      const mutationOptions = getAddFixtureGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List FixtureCards. Supports filtering via rsql.
 */
export const fixtureCards = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureCards>(
      {url: `/api/storage/fixtureCards`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getFixtureCardsMutationOptions = <TData = Awaited<ReturnType<typeof fixtureCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['fixtureCards'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof fixtureCards>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  fixtureCards(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type FixtureCardsMutationResult = NonNullable<Awaited<ReturnType<typeof fixtureCards>>>
    export type FixtureCardsMutationBody = FilteringRequest
    export type FixtureCardsMutationError = ErrorResponse

    export const useFixtureCards = <TData = Awaited<ReturnType<typeof fixtureCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getFixtureCardsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new FixtureCard
 */
export const addFixtureCard = (
    fixtureCard: FixtureCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureCard>(
      {url: `/api/storage/fixtureCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: fixtureCard, signal
    },
      );
    }
  


export const getAddFixtureCardMutationOptions = <TData = Awaited<ReturnType<typeof addFixtureCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureCard}, TContext>, }
) => {
const mutationKey = ['addFixtureCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFixtureCard>>, {data: FixtureCard}> = (props) => {
          const {data} = props ?? {};

          return  addFixtureCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FixtureCard}, TContext>}

    export type AddFixtureCardMutationResult = NonNullable<Awaited<ReturnType<typeof addFixtureCard>>>
    export type AddFixtureCardMutationBody = FixtureCard
    export type AddFixtureCardMutationError = ErrorResponse

    export const useAddFixtureCard = <TData = Awaited<ReturnType<typeof addFixtureCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FixtureCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FixtureCard},
        TContext
      > => {

      const mutationOptions = getAddFixtureCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List AssignmentTransactions. Supports filtering via rsql.
 */
export const assignmentTransactions = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AssignmentTransactions>(
      {url: `/api/storage/assignmentTransactions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getAssignmentTransactionsMutationOptions = <TData = Awaited<ReturnType<typeof assignmentTransactions>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['assignmentTransactions'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignmentTransactions>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  assignmentTransactions(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type AssignmentTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof assignmentTransactions>>>
    export type AssignmentTransactionsMutationBody = FilteringRequest
    export type AssignmentTransactionsMutationError = ErrorResponse

    export const useAssignmentTransactions = <TData = Awaited<ReturnType<typeof assignmentTransactions>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getAssignmentTransactionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new AssignmentTransaction
 */
export const addAssignmentTransaction = (
    assignmentTransaction: AssignmentTransaction,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AssignmentTransaction>(
      {url: `/api/storage/assignmentTransaction`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assignmentTransaction, signal
    },
      );
    }
  


export const getAddAssignmentTransactionMutationOptions = <TData = Awaited<ReturnType<typeof addAssignmentTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentTransaction}, TContext>, }
) => {
const mutationKey = ['addAssignmentTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAssignmentTransaction>>, {data: AssignmentTransaction}> = (props) => {
          const {data} = props ?? {};

          return  addAssignmentTransaction(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: AssignmentTransaction}, TContext>}

    export type AddAssignmentTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof addAssignmentTransaction>>>
    export type AddAssignmentTransactionMutationBody = AssignmentTransaction
    export type AddAssignmentTransactionMutationError = ErrorResponse

    export const useAddAssignmentTransaction = <TData = Awaited<ReturnType<typeof addAssignmentTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: AssignmentTransaction},
        TContext
      > => {

      const mutationOptions = getAddAssignmentTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List AssignmentCards. Supports filtering via rsql.
 */
export const assignmentCards = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AssignmentCards>(
      {url: `/api/storage/assignmentCards`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getAssignmentCardsMutationOptions = <TData = Awaited<ReturnType<typeof assignmentCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['assignmentCards'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignmentCards>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  assignmentCards(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type AssignmentCardsMutationResult = NonNullable<Awaited<ReturnType<typeof assignmentCards>>>
    export type AssignmentCardsMutationBody = FilteringRequest
    export type AssignmentCardsMutationError = ErrorResponse

    export const useAssignmentCards = <TData = Awaited<ReturnType<typeof assignmentCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getAssignmentCardsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new AssignmentCard
 */
export const addAssignmentCard = (
    assignmentCard: AssignmentCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AssignmentCard>(
      {url: `/api/storage/assignmentCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assignmentCard, signal
    },
      );
    }
  


export const getAddAssignmentCardMutationOptions = <TData = Awaited<ReturnType<typeof addAssignmentCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentCard}, TContext>, }
) => {
const mutationKey = ['addAssignmentCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAssignmentCard>>, {data: AssignmentCard}> = (props) => {
          const {data} = props ?? {};

          return  addAssignmentCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: AssignmentCard}, TContext>}

    export type AddAssignmentCardMutationResult = NonNullable<Awaited<ReturnType<typeof addAssignmentCard>>>
    export type AddAssignmentCardMutationBody = AssignmentCard
    export type AddAssignmentCardMutationError = ErrorResponse

    export const useAddAssignmentCard = <TData = Awaited<ReturnType<typeof addAssignmentCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AssignmentCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: AssignmentCard},
        TContext
      > => {

      const mutationOptions = getAddAssignmentCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Proposals. Supports filtering via rsql.
 */
export const proposals = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Proposals>(
      {url: `/api/sales/proposals`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getProposalsMutationOptions = <TData = Awaited<ReturnType<typeof proposals>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['proposals'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof proposals>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  proposals(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ProposalsMutationResult = NonNullable<Awaited<ReturnType<typeof proposals>>>
    export type ProposalsMutationBody = FilteringRequest
    export type ProposalsMutationError = ErrorResponse

    export const useProposals = <TData = Awaited<ReturnType<typeof proposals>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getProposalsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Proposal
 */
export const addProposal = (
    proposal: Proposal,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Proposal>(
      {url: `/api/sales/proposal`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: proposal, signal
    },
      );
    }
  


export const getAddProposalMutationOptions = <TData = Awaited<ReturnType<typeof addProposal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Proposal}, TContext>, }
) => {
const mutationKey = ['addProposal'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProposal>>, {data: Proposal}> = (props) => {
          const {data} = props ?? {};

          return  addProposal(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Proposal}, TContext>}

    export type AddProposalMutationResult = NonNullable<Awaited<ReturnType<typeof addProposal>>>
    export type AddProposalMutationBody = Proposal
    export type AddProposalMutationError = ErrorResponse

    export const useAddProposal = <TData = Awaited<ReturnType<typeof addProposal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Proposal}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Proposal},
        TContext
      > => {

      const mutationOptions = getAddProposalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List PurchaseOrders. Supports filtering via rsql.
 */
export const purchaseOrders = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PurchaseOrders>(
      {url: `/api/purchasing/purchaseOrders`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getPurchaseOrdersMutationOptions = <TData = Awaited<ReturnType<typeof purchaseOrders>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['purchaseOrders'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof purchaseOrders>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  purchaseOrders(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type PurchaseOrdersMutationResult = NonNullable<Awaited<ReturnType<typeof purchaseOrders>>>
    export type PurchaseOrdersMutationBody = FilteringRequest
    export type PurchaseOrdersMutationError = ErrorResponse

    export const usePurchaseOrders = <TData = Awaited<ReturnType<typeof purchaseOrders>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getPurchaseOrdersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new PurchaseOrder
 */
export const addPurchaseOrder = (
    purchaseOrder: PurchaseOrder,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PurchaseOrder>(
      {url: `/api/purchasing/purchaseOrder`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: purchaseOrder, signal
    },
      );
    }
  


export const getAddPurchaseOrderMutationOptions = <TData = Awaited<ReturnType<typeof addPurchaseOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PurchaseOrder}, TContext>, }
) => {
const mutationKey = ['addPurchaseOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPurchaseOrder>>, {data: PurchaseOrder}> = (props) => {
          const {data} = props ?? {};

          return  addPurchaseOrder(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: PurchaseOrder}, TContext>}

    export type AddPurchaseOrderMutationResult = NonNullable<Awaited<ReturnType<typeof addPurchaseOrder>>>
    export type AddPurchaseOrderMutationBody = PurchaseOrder
    export type AddPurchaseOrderMutationError = ErrorResponse

    export const useAddPurchaseOrder = <TData = Awaited<ReturnType<typeof addPurchaseOrder>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PurchaseOrder}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: PurchaseOrder},
        TContext
      > => {

      const mutationOptions = getAddPurchaseOrderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Invoices. Supports filtering via rsql.
 */
export const getInvoices = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Invoices>(
      {url: `/api/purchasing/invoices`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getGetInvoicesMutationOptions = <TData = Awaited<ReturnType<typeof getInvoices>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['getInvoices'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getInvoices>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  getInvoices(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type GetInvoicesMutationResult = NonNullable<Awaited<ReturnType<typeof getInvoices>>>
    export type GetInvoicesMutationBody = FilteringRequest
    export type GetInvoicesMutationError = ErrorResponse

    export const useGetInvoices = <TData = Awaited<ReturnType<typeof getInvoices>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getGetInvoicesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Invoice
 */
export const addInvoice = (
    invoice: Invoice,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Invoice>(
      {url: `/api/purchasing/invoice`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoice, signal
    },
      );
    }
  


export const getAddInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof addInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, }
) => {
const mutationKey = ['addInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addInvoice>>, {data: Invoice}> = (props) => {
          const {data} = props ?? {};

          return  addInvoice(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Invoice}, TContext>}

    export type AddInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof addInvoice>>>
    export type AddInvoiceMutationBody = Invoice
    export type AddInvoiceMutationError = ErrorResponse

    export const useAddInvoice = <TData = Awaited<ReturnType<typeof addInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Invoice},
        TContext
      > => {

      const mutationOptions = getAddInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Invoice Total
 */
export const calculateInvoiceTotal = (
    invoice: Invoice,
 signal?: AbortSignal
) => {
      
      
      return customMutator<InvoiceCalculationResult>(
      {url: `/api/purchasing/invoice/calculateTotal`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoice, signal
    },
      );
    }
  


export const getCalculateInvoiceTotalMutationOptions = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, }
) => {
const mutationKey = ['calculateInvoiceTotal'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateInvoiceTotal>>, {data: Invoice}> = (props) => {
          const {data} = props ?? {};

          return  calculateInvoiceTotal(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Invoice}, TContext>}

    export type CalculateInvoiceTotalMutationResult = NonNullable<Awaited<ReturnType<typeof calculateInvoiceTotal>>>
    export type CalculateInvoiceTotalMutationBody = Invoice
    export type CalculateInvoiceTotalMutationError = ErrorResponse

    export const useCalculateInvoiceTotal = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Invoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Invoice},
        TContext
      > => {

      const mutationOptions = getCalculateInvoiceTotalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Current Accounts. Supports filtering via rsql.
 */
export const currentAccounts = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccounts>(
      {url: `/api/purchasing/currentAccounts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getCurrentAccountsMutationOptions = <TData = Awaited<ReturnType<typeof currentAccounts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['currentAccounts'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof currentAccounts>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  currentAccounts(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type CurrentAccountsMutationResult = NonNullable<Awaited<ReturnType<typeof currentAccounts>>>
    export type CurrentAccountsMutationBody = FilteringRequest
    export type CurrentAccountsMutationError = ErrorResponse

    export const useCurrentAccounts = <TData = Awaited<ReturnType<typeof currentAccounts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getCurrentAccountsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Current Account
 */
export const addCurrentAccount = (
    currentAccount: CurrentAccount,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccount>(
      {url: `/api/purchasing/currentAccount`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: currentAccount, signal
    },
      );
    }
  


export const getAddCurrentAccountMutationOptions = <TData = Awaited<ReturnType<typeof addCurrentAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccount}, TContext>, }
) => {
const mutationKey = ['addCurrentAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCurrentAccount>>, {data: CurrentAccount}> = (props) => {
          const {data} = props ?? {};

          return  addCurrentAccount(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CurrentAccount}, TContext>}

    export type AddCurrentAccountMutationResult = NonNullable<Awaited<ReturnType<typeof addCurrentAccount>>>
    export type AddCurrentAccountMutationBody = CurrentAccount
    export type AddCurrentAccountMutationError = ErrorResponse

    export const useAddCurrentAccount = <TData = Awaited<ReturnType<typeof addCurrentAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CurrentAccount},
        TContext
      > => {

      const mutationOptions = getAddCurrentAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Current Account Transactions. Supports filtering via rsql.
 */
export const getCurrentAccountTransactions = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccountTransactions>(
      {url: `/api/purchasing/currentAccountTransactions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getGetCurrentAccountTransactionsMutationOptions = <TData = Awaited<ReturnType<typeof getCurrentAccountTransactions>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['getCurrentAccountTransactions'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getCurrentAccountTransactions>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  getCurrentAccountTransactions(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type GetCurrentAccountTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof getCurrentAccountTransactions>>>
    export type GetCurrentAccountTransactionsMutationBody = FilteringRequest
    export type GetCurrentAccountTransactionsMutationError = ErrorResponse

    export const useGetCurrentAccountTransactions = <TData = Awaited<ReturnType<typeof getCurrentAccountTransactions>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getGetCurrentAccountTransactionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Current Account Transaction
 */
export const addCurrentAccountTransaction = (
    currentAccountTransaction: CurrentAccountTransaction,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccountTransaction>(
      {url: `/api/purchasing/currentAccountTransaction`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: currentAccountTransaction, signal
    },
      );
    }
  


export const getAddCurrentAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof addCurrentAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountTransaction}, TContext>, }
) => {
const mutationKey = ['addCurrentAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCurrentAccountTransaction>>, {data: CurrentAccountTransaction}> = (props) => {
          const {data} = props ?? {};

          return  addCurrentAccountTransaction(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CurrentAccountTransaction}, TContext>}

    export type AddCurrentAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof addCurrentAccountTransaction>>>
    export type AddCurrentAccountTransactionMutationBody = CurrentAccountTransaction
    export type AddCurrentAccountTransactionMutationError = ErrorResponse

    export const useAddCurrentAccountTransaction = <TData = Awaited<ReturnType<typeof addCurrentAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CurrentAccountTransaction},
        TContext
      > => {

      const mutationOptions = getAddCurrentAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List CurrentAccountBankAccounts. Supports filtering via rsql.
 */
export const currentAccountBankAccounts = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccountBankAccounts>(
      {url: `/api/purchasing/currentAccountBankAccounts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getCurrentAccountBankAccountsMutationOptions = <TData = Awaited<ReturnType<typeof currentAccountBankAccounts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['currentAccountBankAccounts'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof currentAccountBankAccounts>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  currentAccountBankAccounts(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type CurrentAccountBankAccountsMutationResult = NonNullable<Awaited<ReturnType<typeof currentAccountBankAccounts>>>
    export type CurrentAccountBankAccountsMutationBody = FilteringRequest
    export type CurrentAccountBankAccountsMutationError = ErrorResponse

    export const useCurrentAccountBankAccounts = <TData = Awaited<ReturnType<typeof currentAccountBankAccounts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getCurrentAccountBankAccountsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new CurrentAccountBankAccount
 */
export const addCurrentAccountBankAccount = (
    currentAccountBankAccount: CurrentAccountBankAccount,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CurrentAccountBankAccount>(
      {url: `/api/purchasing/currentAccountBankAccount`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: currentAccountBankAccount, signal
    },
      );
    }
  


export const getAddCurrentAccountBankAccountMutationOptions = <TData = Awaited<ReturnType<typeof addCurrentAccountBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountBankAccount}, TContext>, }
) => {
const mutationKey = ['addCurrentAccountBankAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCurrentAccountBankAccount>>, {data: CurrentAccountBankAccount}> = (props) => {
          const {data} = props ?? {};

          return  addCurrentAccountBankAccount(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CurrentAccountBankAccount}, TContext>}

    export type AddCurrentAccountBankAccountMutationResult = NonNullable<Awaited<ReturnType<typeof addCurrentAccountBankAccount>>>
    export type AddCurrentAccountBankAccountMutationBody = CurrentAccountBankAccount
    export type AddCurrentAccountBankAccountMutationError = ErrorResponse

    export const useAddCurrentAccountBankAccount = <TData = Awaited<ReturnType<typeof addCurrentAccountBankAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CurrentAccountBankAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CurrentAccountBankAccount},
        TContext
      > => {

      const mutationOptions = getAddCurrentAccountBankAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List AdditionalCosts. Supports filtering via rsql.
 */
export const additionalcosts = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AdditionalCosts>(
      {url: `/api/purchasing/additionalcosts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getAdditionalcostsMutationOptions = <TData = Awaited<ReturnType<typeof additionalcosts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['additionalcosts'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof additionalcosts>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  additionalcosts(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type AdditionalcostsMutationResult = NonNullable<Awaited<ReturnType<typeof additionalcosts>>>
    export type AdditionalcostsMutationBody = FilteringRequest
    export type AdditionalcostsMutationError = ErrorResponse

    export const useAdditionalcosts = <TData = Awaited<ReturnType<typeof additionalcosts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getAdditionalcostsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new AdditionalCost
 */
export const addAdditionalCost = (
    additionalCost: AdditionalCost,
 signal?: AbortSignal
) => {
      
      
      return customMutator<AdditionalCost>(
      {url: `/api/purchasing/additionalcost`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: additionalCost, signal
    },
      );
    }
  


export const getAddAdditionalCostMutationOptions = <TData = Awaited<ReturnType<typeof addAdditionalCost>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AdditionalCost}, TContext>, }
) => {
const mutationKey = ['addAdditionalCost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAdditionalCost>>, {data: AdditionalCost}> = (props) => {
          const {data} = props ?? {};

          return  addAdditionalCost(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: AdditionalCost}, TContext>}

    export type AddAdditionalCostMutationResult = NonNullable<Awaited<ReturnType<typeof addAdditionalCost>>>
    export type AddAdditionalCostMutationBody = AdditionalCost
    export type AddAdditionalCostMutationError = ErrorResponse

    export const useAddAdditionalCost = <TData = Awaited<ReturnType<typeof addAdditionalCost>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: AdditionalCost}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: AdditionalCost},
        TContext
      > => {

      const mutationOptions = getAddAdditionalCostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Projects. Supports filtering via rsql.
 */
export const projects = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Projects>(
      {url: `/api/production/projects`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getProjectsMutationOptions = <TData = Awaited<ReturnType<typeof projects>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['projects'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projects>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  projects(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ProjectsMutationResult = NonNullable<Awaited<ReturnType<typeof projects>>>
    export type ProjectsMutationBody = FilteringRequest
    export type ProjectsMutationError = ErrorResponse

    export const useProjects = <TData = Awaited<ReturnType<typeof projects>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getProjectsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Project
 */
export const addProject = (
    project: Project,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Project>(
      {url: `/api/production/project`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: project, signal
    },
      );
    }
  


export const getAddProjectMutationOptions = <TData = Awaited<ReturnType<typeof addProject>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Project}, TContext>, }
) => {
const mutationKey = ['addProject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addProject>>, {data: Project}> = (props) => {
          const {data} = props ?? {};

          return  addProject(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Project}, TContext>}

    export type AddProjectMutationResult = NonNullable<Awaited<ReturnType<typeof addProject>>>
    export type AddProjectMutationBody = Project
    export type AddProjectMutationError = ErrorResponse

    export const useAddProject = <TData = Awaited<ReturnType<typeof addProject>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Project}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Project},
        TContext
      > => {

      const mutationOptions = getAddProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List TimeKeepings. Supports filtering via rsql.
 */
export const timeKeepings = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeKeepings>(
      {url: `/api/hr/timekeepings`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getTimeKeepingsMutationOptions = <TData = Awaited<ReturnType<typeof timeKeepings>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['timeKeepings'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timeKeepings>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  timeKeepings(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type TimeKeepingsMutationResult = NonNullable<Awaited<ReturnType<typeof timeKeepings>>>
    export type TimeKeepingsMutationBody = FilteringRequest
    export type TimeKeepingsMutationError = ErrorResponse

    export const useTimeKeepings = <TData = Awaited<ReturnType<typeof timeKeepings>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getTimeKeepingsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create new Time Keeping
 */
export const createTimeKeeping = (
    timeKeeping: TimeKeeping,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeKeeping>(
      {url: `/api/hr/timekeeping`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: timeKeeping, signal
    },
      );
    }
  


export const getCreateTimeKeepingMutationOptions = <TData = Awaited<ReturnType<typeof createTimeKeeping>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, }
) => {
const mutationKey = ['createTimeKeeping'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTimeKeeping>>, {data: TimeKeeping}> = (props) => {
          const {data} = props ?? {};

          return  createTimeKeeping(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>}

    export type CreateTimeKeepingMutationResult = NonNullable<Awaited<ReturnType<typeof createTimeKeeping>>>
    export type CreateTimeKeepingMutationBody = TimeKeeping
    export type CreateTimeKeepingMutationError = ErrorResponse

    export const useCreateTimeKeeping = <TData = Awaited<ReturnType<typeof createTimeKeeping>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: TimeKeeping},
        TContext
      > => {

      const mutationOptions = getCreateTimeKeepingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Time Keeping Total
 */
export const calculateTimeKeepingTotal = (
    timeKeeping: TimeKeeping,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeKeepingCalculationResult>(
      {url: `/api/hr/timekeeping/calculateTotal`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: timeKeeping, signal
    },
      );
    }
  


export const getCalculateTimeKeepingTotalMutationOptions = <TData = Awaited<ReturnType<typeof calculateTimeKeepingTotal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, }
) => {
const mutationKey = ['calculateTimeKeepingTotal'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateTimeKeepingTotal>>, {data: TimeKeeping}> = (props) => {
          const {data} = props ?? {};

          return  calculateTimeKeepingTotal(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>}

    export type CalculateTimeKeepingTotalMutationResult = NonNullable<Awaited<ReturnType<typeof calculateTimeKeepingTotal>>>
    export type CalculateTimeKeepingTotalMutationBody = TimeKeeping
    export type CalculateTimeKeepingTotalMutationError = ErrorResponse

    export const useCalculateTimeKeepingTotal = <TData = Awaited<ReturnType<typeof calculateTimeKeepingTotal>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: TimeKeeping}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: TimeKeeping},
        TContext
      > => {

      const mutationOptions = getCalculateTimeKeepingTotalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Employees. Supports filtering via rsql.
 */
export const employees = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Employees>(
      {url: `/api/hr/employees`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getEmployeesMutationOptions = <TData = Awaited<ReturnType<typeof employees>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['employees'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof employees>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  employees(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type EmployeesMutationResult = NonNullable<Awaited<ReturnType<typeof employees>>>
    export type EmployeesMutationBody = FilteringRequest
    export type EmployeesMutationError = ErrorResponse

    export const useEmployees = <TData = Awaited<ReturnType<typeof employees>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getEmployeesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Employee TimeOff Statuses. Supports filtering via rsql.
 */
export const employeeTimeOffStatuses = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeOffStatuses>(
      {url: `/api/hr/employees/timeoffstatuses`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getEmployeeTimeOffStatusesMutationOptions = <TData = Awaited<ReturnType<typeof employeeTimeOffStatuses>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['employeeTimeOffStatuses'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof employeeTimeOffStatuses>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  employeeTimeOffStatuses(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type EmployeeTimeOffStatusesMutationResult = NonNullable<Awaited<ReturnType<typeof employeeTimeOffStatuses>>>
    export type EmployeeTimeOffStatusesMutationBody = FilteringRequest
    export type EmployeeTimeOffStatusesMutationError = ErrorResponse

    export const useEmployeeTimeOffStatuses = <TData = Awaited<ReturnType<typeof employeeTimeOffStatuses>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getEmployeeTimeOffStatusesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Employee
 */
export const addEmployee = (
    employee: Employee,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Employee>(
      {url: `/api/hr/employee`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: employee, signal
    },
      );
    }
  


export const getAddEmployeeMutationOptions = <TData = Awaited<ReturnType<typeof addEmployee>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Employee}, TContext>, }
) => {
const mutationKey = ['addEmployee'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addEmployee>>, {data: Employee}> = (props) => {
          const {data} = props ?? {};

          return  addEmployee(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Employee}, TContext>}

    export type AddEmployeeMutationResult = NonNullable<Awaited<ReturnType<typeof addEmployee>>>
    export type AddEmployeeMutationBody = Employee
    export type AddEmployeeMutationError = ErrorResponse

    export const useAddEmployee = <TData = Awaited<ReturnType<typeof addEmployee>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Employee}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Employee},
        TContext
      > => {

      const mutationOptions = getAddEmployeeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Employee timeoffs. Supports filtering via rsql.
 */
export const timeoffs = (
    id: number,
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeOffs>(
      {url: `/api/hr/employee/${id}/timeoffs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getTimeoffsMutationOptions = <TData = Awaited<ReturnType<typeof timeoffs>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['timeoffs'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timeoffs>>, {id: number;data: FilteringRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  timeoffs(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: FilteringRequest}, TContext>}

    export type TimeoffsMutationResult = NonNullable<Awaited<ReturnType<typeof timeoffs>>>
    export type TimeoffsMutationBody = FilteringRequest
    export type TimeoffsMutationError = ErrorResponse

    export const useTimeoffs = <TData = Awaited<ReturnType<typeof timeoffs>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getTimeoffsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new TimeOff
 */
export const addTimeOff = (
    id: number,
    timeOff: TimeOff,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeOff>(
      {url: `/api/hr/employee/${id}/timeoff`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: timeOff, signal
    },
      );
    }
  


export const getAddTimeOffMutationOptions = <TData = Awaited<ReturnType<typeof addTimeOff>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeOff}, TContext>, }
) => {
const mutationKey = ['addTimeOff'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTimeOff>>, {id: number;data: TimeOff}> = (props) => {
          const {id,data} = props ?? {};

          return  addTimeOff(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: TimeOff}, TContext>}

    export type AddTimeOffMutationResult = NonNullable<Awaited<ReturnType<typeof addTimeOff>>>
    export type AddTimeOffMutationBody = TimeOff
    export type AddTimeOffMutationError = ErrorResponse

    export const useAddTimeOff = <TData = Awaited<ReturnType<typeof addTimeOff>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: TimeOff}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: TimeOff},
        TContext
      > => {

      const mutationOptions = getAddTimeOffMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Employee - Employee Payments. Supports filtering via rsql.
 */
export const employeePayments = (
    id: number,
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeePayments>(
      {url: `/api/hr/employee/${id}/payments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getEmployeePaymentsMutationOptions = <TData = Awaited<ReturnType<typeof employeePayments>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['employeePayments'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof employeePayments>>, {id: number;data: FilteringRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  employeePayments(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: FilteringRequest}, TContext>}

    export type EmployeePaymentsMutationResult = NonNullable<Awaited<ReturnType<typeof employeePayments>>>
    export type EmployeePaymentsMutationBody = FilteringRequest
    export type EmployeePaymentsMutationError = ErrorResponse

    export const useEmployeePayments = <TData = Awaited<ReturnType<typeof employeePayments>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getEmployeePaymentsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Employee - Employee Overtimes. Supports filtering via rsql.
 */
export const employeeOvertimes = (
    id: number,
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeeOvertimes>(
      {url: `/api/hr/employee/${id}/overtimes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getEmployeeOvertimesMutationOptions = <TData = Awaited<ReturnType<typeof employeeOvertimes>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['employeeOvertimes'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof employeeOvertimes>>, {id: number;data: FilteringRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  employeeOvertimes(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: FilteringRequest}, TContext>}

    export type EmployeeOvertimesMutationResult = NonNullable<Awaited<ReturnType<typeof employeeOvertimes>>>
    export type EmployeeOvertimesMutationBody = FilteringRequest
    export type EmployeeOvertimesMutationError = ErrorResponse

    export const useEmployeeOvertimes = <TData = Awaited<ReturnType<typeof employeeOvertimes>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getEmployeeOvertimesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * EmployeePayments view. Supports filtering via rsql using Employee.
 */
export const employeePaymentsStatusView = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeePayments>(
      {url: `/api/hr/employee/payments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getEmployeePaymentsStatusViewMutationOptions = <TData = Awaited<ReturnType<typeof employeePaymentsStatusView>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['employeePaymentsStatusView'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof employeePaymentsStatusView>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  employeePaymentsStatusView(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type EmployeePaymentsStatusViewMutationResult = NonNullable<Awaited<ReturnType<typeof employeePaymentsStatusView>>>
    export type EmployeePaymentsStatusViewMutationBody = FilteringRequest
    export type EmployeePaymentsStatusViewMutationError = ErrorResponse

    export const useEmployeePaymentsStatusView = <TData = Awaited<ReturnType<typeof employeePaymentsStatusView>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getEmployeePaymentsStatusViewMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * EmployeeOvertimes view. Supports filtering via rsql using Employee.
 */
export const employeeOvertimesStatusView = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeeOvertimes>(
      {url: `/api/hr/employee/overtimes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getEmployeeOvertimesStatusViewMutationOptions = <TData = Awaited<ReturnType<typeof employeeOvertimesStatusView>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['employeeOvertimesStatusView'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof employeeOvertimesStatusView>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  employeeOvertimesStatusView(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type EmployeeOvertimesStatusViewMutationResult = NonNullable<Awaited<ReturnType<typeof employeeOvertimesStatusView>>>
    export type EmployeeOvertimesStatusViewMutationBody = FilteringRequest
    export type EmployeeOvertimesStatusViewMutationError = ErrorResponse

    export const useEmployeeOvertimesStatusView = <TData = Awaited<ReturnType<typeof employeeOvertimesStatusView>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getEmployeeOvertimesStatusViewMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Banks. Supports filtering via rsql.
 */
export const banks = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Banks>(
      {url: `/api/finance/banks`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getBanksMutationOptions = <TData = Awaited<ReturnType<typeof banks>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['banks'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof banks>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  banks(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type BanksMutationResult = NonNullable<Awaited<ReturnType<typeof banks>>>
    export type BanksMutationBody = FilteringRequest
    export type BanksMutationError = ErrorResponse

    export const useBanks = <TData = Awaited<ReturnType<typeof banks>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getBanksMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Bank
 */
export const addBank = (
    bank: Bank,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Bank>(
      {url: `/api/finance/bank`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bank, signal
    },
      );
    }
  


export const getAddBankMutationOptions = <TData = Awaited<ReturnType<typeof addBank>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Bank}, TContext>, }
) => {
const mutationKey = ['addBank'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBank>>, {data: Bank}> = (props) => {
          const {data} = props ?? {};

          return  addBank(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Bank}, TContext>}

    export type AddBankMutationResult = NonNullable<Awaited<ReturnType<typeof addBank>>>
    export type AddBankMutationBody = Bank
    export type AddBankMutationError = ErrorResponse

    export const useAddBank = <TData = Awaited<ReturnType<typeof addBank>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Bank}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Bank},
        TContext
      > => {

      const mutationOptions = getAddBankMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Bank Branches. Supports filtering via rsql.
 */
export const bankBranches = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<BankBranches>(
      {url: `/api/finance/bankBranches`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getBankBranchesMutationOptions = <TData = Awaited<ReturnType<typeof bankBranches>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['bankBranches'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bankBranches>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  bankBranches(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type BankBranchesMutationResult = NonNullable<Awaited<ReturnType<typeof bankBranches>>>
    export type BankBranchesMutationBody = FilteringRequest
    export type BankBranchesMutationError = ErrorResponse

    export const useBankBranches = <TData = Awaited<ReturnType<typeof bankBranches>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getBankBranchesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Bank Branch
 */
export const addBankBranch = (
    bankBranch: BankBranch,
 signal?: AbortSignal
) => {
      
      
      return customMutator<BankBranch>(
      {url: `/api/finance/bankBranch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bankBranch, signal
    },
      );
    }
  


export const getAddBankBranchMutationOptions = <TData = Awaited<ReturnType<typeof addBankBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankBranch}, TContext>, }
) => {
const mutationKey = ['addBankBranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBankBranch>>, {data: BankBranch}> = (props) => {
          const {data} = props ?? {};

          return  addBankBranch(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BankBranch}, TContext>}

    export type AddBankBranchMutationResult = NonNullable<Awaited<ReturnType<typeof addBankBranch>>>
    export type AddBankBranchMutationBody = BankBranch
    export type AddBankBranchMutationError = ErrorResponse

    export const useAddBankBranch = <TData = Awaited<ReturnType<typeof addBankBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankBranch}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: BankBranch},
        TContext
      > => {

      const mutationOptions = getAddBankBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Bank Accounts. Supports filtering via rsql.
 */
export const bankAccounts = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<BankAccounts>(
      {url: `/api/finance/bankAccounts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getBankAccountsMutationOptions = <TData = Awaited<ReturnType<typeof bankAccounts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['bankAccounts'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bankAccounts>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  bankAccounts(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type BankAccountsMutationResult = NonNullable<Awaited<ReturnType<typeof bankAccounts>>>
    export type BankAccountsMutationBody = FilteringRequest
    export type BankAccountsMutationError = ErrorResponse

    export const useBankAccounts = <TData = Awaited<ReturnType<typeof bankAccounts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getBankAccountsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Bank Account
 */
export const addBankBranch1 = (
    bankAccount: BankAccount,
 signal?: AbortSignal
) => {
      
      
      return customMutator<BankAccount>(
      {url: `/api/finance/bankAccount`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bankAccount, signal
    },
      );
    }
  


export const getAddBankBranch1MutationOptions = <TData = Awaited<ReturnType<typeof addBankBranch1>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankAccount}, TContext>, }
) => {
const mutationKey = ['addBankBranch1'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBankBranch1>>, {data: BankAccount}> = (props) => {
          const {data} = props ?? {};

          return  addBankBranch1(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BankAccount}, TContext>}

    export type AddBankBranch1MutationResult = NonNullable<Awaited<ReturnType<typeof addBankBranch1>>>
    export type AddBankBranch1MutationBody = BankAccount
    export type AddBankBranch1MutationError = ErrorResponse

    export const useAddBankBranch1 = <TData = Awaited<ReturnType<typeof addBankBranch1>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BankAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: BankAccount},
        TContext
      > => {

      const mutationOptions = getAddBankBranch1MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Departments. Supports filtering via rsql.
 */
export const departments = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Departments>(
      {url: `/api/company/departments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getDepartmentsMutationOptions = <TData = Awaited<ReturnType<typeof departments>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['departments'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof departments>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  departments(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type DepartmentsMutationResult = NonNullable<Awaited<ReturnType<typeof departments>>>
    export type DepartmentsMutationBody = FilteringRequest
    export type DepartmentsMutationError = ErrorResponse

    export const useDepartments = <TData = Awaited<ReturnType<typeof departments>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getDepartmentsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Department
 */
export const addDepartment = (
    department: Department,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Department>(
      {url: `/api/company/department`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: department, signal
    },
      );
    }
  


export const getAddDepartmentMutationOptions = <TData = Awaited<ReturnType<typeof addDepartment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Department}, TContext>, }
) => {
const mutationKey = ['addDepartment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addDepartment>>, {data: Department}> = (props) => {
          const {data} = props ?? {};

          return  addDepartment(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Department}, TContext>}

    export type AddDepartmentMutationResult = NonNullable<Awaited<ReturnType<typeof addDepartment>>>
    export type AddDepartmentMutationBody = Department
    export type AddDepartmentMutationError = ErrorResponse

    export const useAddDepartment = <TData = Awaited<ReturnType<typeof addDepartment>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Department}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Department},
        TContext
      > => {

      const mutationOptions = getAddDepartmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Branches. Supports filtering via rsql.
 */
export const branches = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Branches>(
      {url: `/api/company/branches`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getBranchesMutationOptions = <TData = Awaited<ReturnType<typeof branches>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['branches'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof branches>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  branches(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type BranchesMutationResult = NonNullable<Awaited<ReturnType<typeof branches>>>
    export type BranchesMutationBody = FilteringRequest
    export type BranchesMutationError = ErrorResponse

    export const useBranches = <TData = Awaited<ReturnType<typeof branches>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getBranchesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Branch
 */
export const addBranch = (
    branch: Branch,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Branch>(
      {url: `/api/company/branch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: branch, signal
    },
      );
    }
  


export const getAddBranchMutationOptions = <TData = Awaited<ReturnType<typeof addBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Branch}, TContext>, }
) => {
const mutationKey = ['addBranch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBranch>>, {data: Branch}> = (props) => {
          const {data} = props ?? {};

          return  addBranch(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Branch}, TContext>}

    export type AddBranchMutationResult = NonNullable<Awaited<ReturnType<typeof addBranch>>>
    export type AddBranchMutationBody = Branch
    export type AddBranchMutationError = ErrorResponse

    export const useAddBranch = <TData = Awaited<ReturnType<typeof addBranch>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Branch}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Branch},
        TContext
      > => {

      const mutationOptions = getAddBranchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Sections. Supports filtering via rsql.
 */
export const sections = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Sections>(
      {url: `/api/admin/sections`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getSectionsMutationOptions = <TData = Awaited<ReturnType<typeof sections>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['sections'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sections>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  sections(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type SectionsMutationResult = NonNullable<Awaited<ReturnType<typeof sections>>>
    export type SectionsMutationBody = FilteringRequest
    export type SectionsMutationError = ErrorResponse

    export const useSections = <TData = Awaited<ReturnType<typeof sections>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getSectionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Section
 */
export const addSection = (
    section: Section,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Section>(
      {url: `/api/admin/section`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: section, signal
    },
      );
    }
  


export const getAddSectionMutationOptions = <TData = Awaited<ReturnType<typeof addSection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Section}, TContext>, }
) => {
const mutationKey = ['addSection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addSection>>, {data: Section}> = (props) => {
          const {data} = props ?? {};

          return  addSection(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Section}, TContext>}

    export type AddSectionMutationResult = NonNullable<Awaited<ReturnType<typeof addSection>>>
    export type AddSectionMutationBody = Section
    export type AddSectionMutationError = ErrorResponse

    export const useAddSection = <TData = Awaited<ReturnType<typeof addSection>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Section}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Section},
        TContext
      > => {

      const mutationOptions = getAddSectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Roles. Supports filtering via rsql.
 */
export const roles = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Roles>(
      {url: `/api/admin/roles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getRolesMutationOptions = <TData = Awaited<ReturnType<typeof roles>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['roles'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof roles>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  roles(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type RolesMutationResult = NonNullable<Awaited<ReturnType<typeof roles>>>
    export type RolesMutationBody = FilteringRequest
    export type RolesMutationError = ErrorResponse

    export const useRoles = <TData = Awaited<ReturnType<typeof roles>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getRolesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Role
 */
export const addRole = (
    role: Role,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Role>(
      {url: `/api/admin/role`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: role, signal
    },
      );
    }
  


export const getAddRoleMutationOptions = <TData = Awaited<ReturnType<typeof addRole>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Role}, TContext>, }
) => {
const mutationKey = ['addRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addRole>>, {data: Role}> = (props) => {
          const {data} = props ?? {};

          return  addRole(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Role}, TContext>}

    export type AddRoleMutationResult = NonNullable<Awaited<ReturnType<typeof addRole>>>
    export type AddRoleMutationBody = Role
    export type AddRoleMutationError = ErrorResponse

    export const useAddRole = <TData = Awaited<ReturnType<typeof addRole>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Role}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Role},
        TContext
      > => {

      const mutationOptions = getAddRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Public Holidays. Supports filtering via rsql.
 */
export const publicHolidays = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PublicHolidays>(
      {url: `/api/admin/publicHolidays`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getPublicHolidaysMutationOptions = <TData = Awaited<ReturnType<typeof publicHolidays>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['publicHolidays'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof publicHolidays>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  publicHolidays(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type PublicHolidaysMutationResult = NonNullable<Awaited<ReturnType<typeof publicHolidays>>>
    export type PublicHolidaysMutationBody = FilteringRequest
    export type PublicHolidaysMutationError = ErrorResponse

    export const usePublicHolidays = <TData = Awaited<ReturnType<typeof publicHolidays>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getPublicHolidaysMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Public Holiday
 */
export const addPublicHoliday = (
    publicHoliday: PublicHoliday,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PublicHoliday>(
      {url: `/api/admin/publicHoliday`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: publicHoliday, signal
    },
      );
    }
  


export const getAddPublicHolidayMutationOptions = <TData = Awaited<ReturnType<typeof addPublicHoliday>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PublicHoliday}, TContext>, }
) => {
const mutationKey = ['addPublicHoliday'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPublicHoliday>>, {data: PublicHoliday}> = (props) => {
          const {data} = props ?? {};

          return  addPublicHoliday(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: PublicHoliday}, TContext>}

    export type AddPublicHolidayMutationResult = NonNullable<Awaited<ReturnType<typeof addPublicHoliday>>>
    export type AddPublicHolidayMutationBody = PublicHoliday
    export type AddPublicHolidayMutationError = ErrorResponse

    export const useAddPublicHoliday = <TData = Awaited<ReturnType<typeof addPublicHoliday>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PublicHoliday}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: PublicHoliday},
        TContext
      > => {

      const mutationOptions = getAddPublicHolidayMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List PaymentMethods. Supports filtering via rsql.
 */
export const paymentMethods = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PaymentMethods>(
      {url: `/api/admin/paymentMethods`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getPaymentMethodsMutationOptions = <TData = Awaited<ReturnType<typeof paymentMethods>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['paymentMethods'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentMethods>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  paymentMethods(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type PaymentMethodsMutationResult = NonNullable<Awaited<ReturnType<typeof paymentMethods>>>
    export type PaymentMethodsMutationBody = FilteringRequest
    export type PaymentMethodsMutationError = ErrorResponse

    export const usePaymentMethods = <TData = Awaited<ReturnType<typeof paymentMethods>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getPaymentMethodsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new PaymentMethod
 */
export const addPaymentMethod = (
    paymentMethod: PaymentMethod,
 signal?: AbortSignal
) => {
      
      
      return customMutator<PaymentMethod>(
      {url: `/api/admin/paymentMethod`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: paymentMethod, signal
    },
      );
    }
  


export const getAddPaymentMethodMutationOptions = <TData = Awaited<ReturnType<typeof addPaymentMethod>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PaymentMethod}, TContext>, }
) => {
const mutationKey = ['addPaymentMethod'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPaymentMethod>>, {data: PaymentMethod}> = (props) => {
          const {data} = props ?? {};

          return  addPaymentMethod(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: PaymentMethod}, TContext>}

    export type AddPaymentMethodMutationResult = NonNullable<Awaited<ReturnType<typeof addPaymentMethod>>>
    export type AddPaymentMethodMutationBody = PaymentMethod
    export type AddPaymentMethodMutationError = ErrorResponse

    export const useAddPaymentMethod = <TData = Awaited<ReturnType<typeof addPaymentMethod>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: PaymentMethod}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: PaymentMethod},
        TContext
      > => {

      const mutationOptions = getAddPaymentMethodMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Machines. Supports filtering via rsql.
 */
export const machines = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Machines>(
      {url: `/api/admin/machines`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getMachinesMutationOptions = <TData = Awaited<ReturnType<typeof machines>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['machines'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof machines>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  machines(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type MachinesMutationResult = NonNullable<Awaited<ReturnType<typeof machines>>>
    export type MachinesMutationBody = FilteringRequest
    export type MachinesMutationError = ErrorResponse

    export const useMachines = <TData = Awaited<ReturnType<typeof machines>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getMachinesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Machine
 */
export const addMachine = (
    machine: Machine,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Machine>(
      {url: `/api/admin/machine`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: machine, signal
    },
      );
    }
  


export const getAddMachineMutationOptions = <TData = Awaited<ReturnType<typeof addMachine>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Machine}, TContext>, }
) => {
const mutationKey = ['addMachine'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMachine>>, {data: Machine}> = (props) => {
          const {data} = props ?? {};

          return  addMachine(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Machine}, TContext>}

    export type AddMachineMutationResult = NonNullable<Awaited<ReturnType<typeof addMachine>>>
    export type AddMachineMutationBody = Machine
    export type AddMachineMutationError = ErrorResponse

    export const useAddMachine = <TData = Awaited<ReturnType<typeof addMachine>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Machine}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Machine},
        TContext
      > => {

      const mutationOptions = getAddMachineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Depots. Supports filtering via rsql.
 */
export const depots = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Depots>(
      {url: `/api/admin/depots`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getDepotsMutationOptions = <TData = Awaited<ReturnType<typeof depots>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['depots'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof depots>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  depots(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type DepotsMutationResult = NonNullable<Awaited<ReturnType<typeof depots>>>
    export type DepotsMutationBody = FilteringRequest
    export type DepotsMutationError = ErrorResponse

    export const useDepots = <TData = Awaited<ReturnType<typeof depots>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getDepotsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Depot
 */
export const addDepot = (
    depot: Depot,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Depot>(
      {url: `/api/admin/depot`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: depot, signal
    },
      );
    }
  


export const getAddDepotMutationOptions = <TData = Awaited<ReturnType<typeof addDepot>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Depot}, TContext>, }
) => {
const mutationKey = ['addDepot'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addDepot>>, {data: Depot}> = (props) => {
          const {data} = props ?? {};

          return  addDepot(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Depot}, TContext>}

    export type AddDepotMutationResult = NonNullable<Awaited<ReturnType<typeof addDepot>>>
    export type AddDepotMutationBody = Depot
    export type AddDepotMutationError = ErrorResponse

    export const useAddDepot = <TData = Awaited<ReturnType<typeof addDepot>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Depot}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Depot},
        TContext
      > => {

      const mutationOptions = getAddDepotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new Company
 */
export const addCompany = (
    company: Company,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Company>(
      {url: `/api/admin/company`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: company, signal
    },
      );
    }
  


export const getAddCompanyMutationOptions = <TData = Awaited<ReturnType<typeof addCompany>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Company}, TContext>, }
) => {
const mutationKey = ['addCompany'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCompany>>, {data: Company}> = (props) => {
          const {data} = props ?? {};

          return  addCompany(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Company}, TContext>}

    export type AddCompanyMutationResult = NonNullable<Awaited<ReturnType<typeof addCompany>>>
    export type AddCompanyMutationBody = Company
    export type AddCompanyMutationError = ErrorResponse

    export const useAddCompany = <TData = Awaited<ReturnType<typeof addCompany>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Company}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: Company},
        TContext
      > => {

      const mutationOptions = getAddCompanyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List Companies. Supports filtering via rsql.
 */
export const companies = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<Companies>(
      {url: `/api/admin/companies`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getCompaniesMutationOptions = <TData = Awaited<ReturnType<typeof companies>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['companies'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof companies>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  companies(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type CompaniesMutationResult = NonNullable<Awaited<ReturnType<typeof companies>>>
    export type CompaniesMutationBody = FilteringRequest
    export type CompaniesMutationError = ErrorResponse

    export const useCompanies = <TData = Awaited<ReturnType<typeof companies>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getCompaniesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List ExpenseInvoices. Supports filtering via rsql.
 */
export const expenseInvoices = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseInvoices>(
      {url: `/api/accounting/expenseInvoices`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getExpenseInvoicesMutationOptions = <TData = Awaited<ReturnType<typeof expenseInvoices>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['expenseInvoices'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof expenseInvoices>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  expenseInvoices(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ExpenseInvoicesMutationResult = NonNullable<Awaited<ReturnType<typeof expenseInvoices>>>
    export type ExpenseInvoicesMutationBody = FilteringRequest
    export type ExpenseInvoicesMutationError = ErrorResponse

    export const useExpenseInvoices = <TData = Awaited<ReturnType<typeof expenseInvoices>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getExpenseInvoicesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ExpenseInvoice
 */
export const addExpenseInvoice = (
    expenseInvoice: ExpenseInvoice,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseInvoice>(
      {url: `/api/accounting/expenseInvoice`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: expenseInvoice, signal
    },
      );
    }
  


export const getAddExpenseInvoiceMutationOptions = <TData = Awaited<ReturnType<typeof addExpenseInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, }
) => {
const mutationKey = ['addExpenseInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addExpenseInvoice>>, {data: ExpenseInvoice}> = (props) => {
          const {data} = props ?? {};

          return  addExpenseInvoice(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>}

    export type AddExpenseInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof addExpenseInvoice>>>
    export type AddExpenseInvoiceMutationBody = ExpenseInvoice
    export type AddExpenseInvoiceMutationError = ErrorResponse

    export const useAddExpenseInvoice = <TData = Awaited<ReturnType<typeof addExpenseInvoice>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ExpenseInvoice},
        TContext
      > => {

      const mutationOptions = getAddExpenseInvoiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Invoice Total
 */
export const calculateInvoiceTotal1 = (
    expenseInvoice: ExpenseInvoice,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseInvoiceCalculationResult>(
      {url: `/api/accounting/expenseInvoice/calculateTotal`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: expenseInvoice, signal
    },
      );
    }
  


export const getCalculateInvoiceTotal1MutationOptions = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal1>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, }
) => {
const mutationKey = ['calculateInvoiceTotal1'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateInvoiceTotal1>>, {data: ExpenseInvoice}> = (props) => {
          const {data} = props ?? {};

          return  calculateInvoiceTotal1(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>}

    export type CalculateInvoiceTotal1MutationResult = NonNullable<Awaited<ReturnType<typeof calculateInvoiceTotal1>>>
    export type CalculateInvoiceTotal1MutationBody = ExpenseInvoice
    export type CalculateInvoiceTotal1MutationError = ErrorResponse

    export const useCalculateInvoiceTotal1 = <TData = Awaited<ReturnType<typeof calculateInvoiceTotal1>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseInvoice}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ExpenseInvoice},
        TContext
      > => {

      const mutationOptions = getCalculateInvoiceTotal1MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List ExpenseCards. Supports filtering via rsql.
 */
export const expenseCards = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseCards>(
      {url: `/api/accounting/expenseCards`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getExpenseCardsMutationOptions = <TData = Awaited<ReturnType<typeof expenseCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['expenseCards'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof expenseCards>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  expenseCards(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type ExpenseCardsMutationResult = NonNullable<Awaited<ReturnType<typeof expenseCards>>>
    export type ExpenseCardsMutationBody = FilteringRequest
    export type ExpenseCardsMutationError = ErrorResponse

    export const useExpenseCards = <TData = Awaited<ReturnType<typeof expenseCards>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getExpenseCardsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new ExpenseCard
 */
export const addExpenseCard = (
    expenseCard: ExpenseCard,
 signal?: AbortSignal
) => {
      
      
      return customMutator<ExpenseCard>(
      {url: `/api/accounting/expenseCard`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: expenseCard, signal
    },
      );
    }
  


export const getAddExpenseCardMutationOptions = <TData = Awaited<ReturnType<typeof addExpenseCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseCard}, TContext>, }
) => {
const mutationKey = ['addExpenseCard'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addExpenseCard>>, {data: ExpenseCard}> = (props) => {
          const {data} = props ?? {};

          return  addExpenseCard(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: ExpenseCard}, TContext>}

    export type AddExpenseCardMutationResult = NonNullable<Awaited<ReturnType<typeof addExpenseCard>>>
    export type AddExpenseCardMutationBody = ExpenseCard
    export type AddExpenseCardMutationError = ErrorResponse

    export const useAddExpenseCard = <TData = Awaited<ReturnType<typeof addExpenseCard>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: ExpenseCard}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: ExpenseCard},
        TContext
      > => {

      const mutationOptions = getAddExpenseCardMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List CashAccounts. Supports filtering via rsql.
 */
export const cashAccounts = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccounts>(
      {url: `/api/accounting/cashAccounts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getCashAccountsMutationOptions = <TData = Awaited<ReturnType<typeof cashAccounts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['cashAccounts'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cashAccounts>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  cashAccounts(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type CashAccountsMutationResult = NonNullable<Awaited<ReturnType<typeof cashAccounts>>>
    export type CashAccountsMutationBody = FilteringRequest
    export type CashAccountsMutationError = ErrorResponse

    export const useCashAccounts = <TData = Awaited<ReturnType<typeof cashAccounts>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getCashAccountsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new CashAccount
 */
export const addCashAccount = (
    cashAccount: CashAccount,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccount>(
      {url: `/api/accounting/cashAccount`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cashAccount, signal
    },
      );
    }
  


export const getAddCashAccountMutationOptions = <TData = Awaited<ReturnType<typeof addCashAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccount}, TContext>, }
) => {
const mutationKey = ['addCashAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCashAccount>>, {data: CashAccount}> = (props) => {
          const {data} = props ?? {};

          return  addCashAccount(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CashAccount}, TContext>}

    export type AddCashAccountMutationResult = NonNullable<Awaited<ReturnType<typeof addCashAccount>>>
    export type AddCashAccountMutationBody = CashAccount
    export type AddCashAccountMutationError = ErrorResponse

    export const useAddCashAccount = <TData = Awaited<ReturnType<typeof addCashAccount>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccount}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CashAccount},
        TContext
      > => {

      const mutationOptions = getAddCashAccountMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List CashAccountTransactions. Supports filtering via rsql.
 */
export const cashAccountTransactions = (
    filteringRequest: FilteringRequest,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccountTransactions>(
      {url: `/api/accounting/cashAccountTransactions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: filteringRequest, signal
    },
      );
    }
  


export const getCashAccountTransactionsMutationOptions = <TData = Awaited<ReturnType<typeof cashAccountTransactions>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
) => {
const mutationKey = ['cashAccountTransactions'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cashAccountTransactions>>, {data: FilteringRequest}> = (props) => {
          const {data} = props ?? {};

          return  cashAccountTransactions(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>}

    export type CashAccountTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof cashAccountTransactions>>>
    export type CashAccountTransactionsMutationBody = FilteringRequest
    export type CashAccountTransactionsMutationError = ErrorResponse

    export const useCashAccountTransactions = <TData = Awaited<ReturnType<typeof cashAccountTransactions>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: FilteringRequest}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: FilteringRequest},
        TContext
      > => {

      const mutationOptions = getCashAccountTransactionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add new CashAccountTransaction
 */
export const addCashAccountTransaction = (
    cashAccountTransaction: CashAccountTransaction,
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccountTransaction>(
      {url: `/api/accounting/cashAccountTransaction`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cashAccountTransaction, signal
    },
      );
    }
  


export const getAddCashAccountTransactionMutationOptions = <TData = Awaited<ReturnType<typeof addCashAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransaction}, TContext>, }
) => {
const mutationKey = ['addCashAccountTransaction'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCashAccountTransaction>>, {data: CashAccountTransaction}> = (props) => {
          const {data} = props ?? {};

          return  addCashAccountTransaction(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CashAccountTransaction}, TContext>}

    export type AddCashAccountTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof addCashAccountTransaction>>>
    export type AddCashAccountTransactionMutationBody = CashAccountTransaction
    export type AddCashAccountTransactionMutationError = ErrorResponse

    export const useAddCashAccountTransaction = <TData = Awaited<ReturnType<typeof addCashAccountTransaction>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransaction}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CashAccountTransaction},
        TContext
      > => {

      const mutationOptions = getAddCashAccountTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Calculate Balance
 */
export const calculateBalance = (
    cashAccountTransactionEntity: CashAccountTransactionEntity[],
 signal?: AbortSignal
) => {
      
      
      return customMutator<CashAccountBalanceResult>(
      {url: `/api/accounting/accounting/calculateBalance`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cashAccountTransactionEntity, signal
    },
      );
    }
  


export const getCalculateBalanceMutationOptions = <TData = Awaited<ReturnType<typeof calculateBalance>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransactionEntity[]}, TContext>, }
) => {
const mutationKey = ['calculateBalance'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateBalance>>, {data: CashAccountTransactionEntity[]}> = (props) => {
          const {data} = props ?? {};

          return  calculateBalance(data,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CashAccountTransactionEntity[]}, TContext>}

    export type CalculateBalanceMutationResult = NonNullable<Awaited<ReturnType<typeof calculateBalance>>>
    export type CalculateBalanceMutationBody = CashAccountTransactionEntity[]
    export type CalculateBalanceMutationError = ErrorResponse

    export const useCalculateBalance = <TData = Awaited<ReturnType<typeof calculateBalance>>, TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CashAccountTransactionEntity[]}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {data: CashAccountTransactionEntity[]},
        TContext
      > => {

      const mutationOptions = getCalculateBalanceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get ServiceGroup Tree
 */
export const getServiceGroupTree = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<ServiceGroupTree>(
      {url: `/api/storage/serviceGroup/tree`, method: 'GET', signal
    },
      );
    }
  

export const getGetServiceGroupTreeQueryKey = () => {
    return [`/api/storage/serviceGroup/tree`] as const;
    }

    
export const getGetServiceGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroupTree>>> = ({ signal }) => getServiceGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroupTree>>>
export type GetServiceGroupTreeQueryError = unknown


export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupTree<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceGroupTree>>> = ({ signal }) => getServiceGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetServiceGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceGroupTree>>>
export type GetServiceGroupTreeSuspenseQueryError = unknown


export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetServiceGroupTreeSuspense<TData = Awaited<ReturnType<typeof getServiceGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getServiceGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetServiceGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get ProductGroup Tree
 */
export const getProductGroupTree = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<ProductGroupTree>(
      {url: `/api/storage/productGroup/tree`, method: 'GET', signal
    },
      );
    }
  

export const getGetProductGroupTreeQueryKey = () => {
    return [`/api/storage/productGroup/tree`] as const;
    }

    
export const getGetProductGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroupTree>>> = ({ signal }) => getProductGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroupTree>>>
export type GetProductGroupTreeQueryError = unknown


export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupTree<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProductGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductGroupTree>>> = ({ signal }) => getProductGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProductGroupTree>>>
export type GetProductGroupTreeSuspenseQueryError = unknown


export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProductGroupTreeSuspense<TData = Awaited<ReturnType<typeof getProductGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProductGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get MaterialGroup Tree
 */
export const getMaterialGroupTree = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<MaterialGroupTreeDataResponse>(
      {url: `/api/storage/materialGroup/tree`, method: 'GET', signal
    },
      );
    }
  

export const getGetMaterialGroupTreeQueryKey = () => {
    return [`/api/storage/materialGroup/tree`] as const;
    }

    
export const getGetMaterialGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroupTree>>> = ({ signal }) => getMaterialGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroupTree>>>
export type GetMaterialGroupTreeQueryError = unknown


export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterialGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupTree<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialGroupTree>>> = ({ signal }) => getMaterialGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMaterialGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterialGroupTree>>>
export type GetMaterialGroupTreeSuspenseQueryError = unknown


export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMaterialGroupTreeSuspense<TData = Awaited<ReturnType<typeof getMaterialGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMaterialGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMaterialGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get FixtureGroup Tree
 */
export const getFixtureGroupTree = (
    
 signal?: AbortSignal
) => {
      
      
      return customMutator<FixtureGroupTree>(
      {url: `/api/storage/fixtureGroup/tree`, method: 'GET', signal
    },
      );
    }
  

export const getGetFixtureGroupTreeQueryKey = () => {
    return [`/api/storage/fixtureGroup/tree`] as const;
    }

    
export const getGetFixtureGroupTreeQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroupTree>>> = ({ signal }) => getFixtureGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroupTree>>>
export type GetFixtureGroupTreeQueryError = unknown


export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFixtureGroupTree>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupTree<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupTreeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFixtureGroupTreeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFixtureGroupTreeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFixtureGroupTree>>> = ({ signal }) => getFixtureGroupTree(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFixtureGroupTreeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFixtureGroupTree>>>
export type GetFixtureGroupTreeSuspenseQueryError = unknown


export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFixtureGroupTreeSuspense<TData = Awaited<ReturnType<typeof getFixtureGroupTree>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFixtureGroupTree>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFixtureGroupTreeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get Draft Time Keeping for Employee
 */
export const getTimeKeepingDraft = (
    id: number,
    year: number,
    month: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeKeeping>(
      {url: `/api/hr/timekeeping/draft/employee/${id}/year/${year}/month/${month}`, method: 'GET', signal
    },
      );
    }
  

export const getGetTimeKeepingDraftQueryKey = (id: number,
    year: number,
    month: number,) => {
    return [`/api/hr/timekeeping/draft/employee/${id}/year/${year}/month/${month}`] as const;
    }

    
export const getGetTimeKeepingDraftQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingDraftQueryKey(id,year,month);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeepingDraft>>> = ({ signal }) => getTimeKeepingDraft(id,year,month, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id && year && month), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingDraftQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeepingDraft>>>
export type GetTimeKeepingDraftQueryError = ErrorResponse


export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeepingDraft>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeKeepingDraft>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeepingDraft<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingDraftQueryOptions(id,year,month,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeKeepingDraftSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeKeepingDraftQueryKey(id,year,month);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeKeepingDraft>>> = ({ signal }) => getTimeKeepingDraft(id,year,month, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeKeepingDraftSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeKeepingDraft>>>
export type GetTimeKeepingDraftSuspenseQueryError = ErrorResponse


export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeKeepingDraftSuspense<TData = Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError = ErrorResponse>(
 id: number,
    year: number,
    month: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeKeepingDraft>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeKeepingDraftSuspenseQueryOptions(id,year,month,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get TimeOff Status
 */
export const getTimeOffStatus = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<TimeOffStatus>(
      {url: `/api/hr/employee/${id}/timeoffstatus`, method: 'GET', signal
    },
      );
    }
  

export const getGetTimeOffStatusQueryKey = (id: number,) => {
    return [`/api/hr/employee/${id}/timeoffstatus`] as const;
    }

    
export const getGetTimeOffStatusQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffStatusQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOffStatus>>> = ({ signal }) => getTimeOffStatus(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOffStatus>>>
export type GetTimeOffStatusQueryError = ErrorResponse


export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOffStatus>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeOffStatus>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOffStatus<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffStatusQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimeOffStatusSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimeOffStatusQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeOffStatus>>> = ({ signal }) => getTimeOffStatus(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimeOffStatusSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeOffStatus>>>
export type GetTimeOffStatusSuspenseQueryError = ErrorResponse


export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeOffStatusSuspense<TData = Awaited<ReturnType<typeof getTimeOffStatus>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeOffStatus>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimeOffStatusSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get Employee Payment
 */
export const getEmployeePayment = (
    id: number,
    employeePaymentId: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeePayment>(
      {url: `/api/hr/employee/${id}/payment/${employeePaymentId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetEmployeePaymentQueryKey = (id: number,
    employeePaymentId: number,) => {
    return [`/api/hr/employee/${id}/payment/${employeePaymentId}`] as const;
    }

    
export const getGetEmployeePaymentQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeePaymentQueryKey(id,employeePaymentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeePayment>>> = ({ signal }) => getEmployeePayment(id,employeePaymentId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id && employeePaymentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeePaymentQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeePayment>>>
export type GetEmployeePaymentQueryError = unknown


export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeePayment>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeePayment>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeePayment<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeePaymentQueryOptions(id,employeePaymentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetEmployeePaymentSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeePaymentQueryKey(id,employeePaymentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeePayment>>> = ({ signal }) => getEmployeePayment(id,employeePaymentId, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeePaymentSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeePayment>>>
export type GetEmployeePaymentSuspenseQueryError = unknown


export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeePaymentSuspense<TData = Awaited<ReturnType<typeof getEmployeePayment>>, TError = unknown>(
 id: number,
    employeePaymentId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeePayment>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeePaymentSuspenseQueryOptions(id,employeePaymentId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete Employee Payment
 */
export const deleteEmployeePayment = (
    id: number,
    employeePaymentId: number,
 ) => {
      
      
      return customMutator<EmployeePayment>(
      {url: `/api/hr/employee/${id}/payment/${employeePaymentId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEmployeePaymentMutationOptions = <TData = Awaited<ReturnType<typeof deleteEmployeePayment>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;employeePaymentId: number}, TContext>, }
) => {
const mutationKey = ['deleteEmployeePayment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEmployeePayment>>, {id: number;employeePaymentId: number}> = (props) => {
          const {id,employeePaymentId} = props ?? {};

          return  deleteEmployeePayment(id,employeePaymentId,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;employeePaymentId: number}, TContext>}

    export type DeleteEmployeePaymentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEmployeePayment>>>
    
    export type DeleteEmployeePaymentMutationError = ResponseBase

    export const useDeleteEmployeePayment = <TData = Awaited<ReturnType<typeof deleteEmployeePayment>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;employeePaymentId: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;employeePaymentId: number},
        TContext
      > => {

      const mutationOptions = getDeleteEmployeePaymentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get Employee Overtime
 */
export const getEmployeeOvertime = (
    id: number,
    overtimeId: number,
 signal?: AbortSignal
) => {
      
      
      return customMutator<EmployeeOvertime>(
      {url: `/api/hr/employee/${id}/overtime/${overtimeId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetEmployeeOvertimeQueryKey = (id: number,
    overtimeId: number,) => {
    return [`/api/hr/employee/${id}/overtime/${overtimeId}`] as const;
    }

    
export const getGetEmployeeOvertimeQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeOvertimeQueryKey(id,overtimeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeeOvertime>>> = ({ signal }) => getEmployeeOvertime(id,overtimeId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id && overtimeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeOvertimeQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeeOvertime>>>
export type GetEmployeeOvertimeQueryError = unknown


export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeeOvertime>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmployeeOvertime>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeeOvertime<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeOvertimeQueryOptions(id,overtimeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetEmployeeOvertimeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmployeeOvertimeQueryKey(id,overtimeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeeOvertime>>> = ({ signal }) => getEmployeeOvertime(id,overtimeId, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmployeeOvertimeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEmployeeOvertime>>>
export type GetEmployeeOvertimeSuspenseQueryError = unknown


export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetEmployeeOvertimeSuspense<TData = Awaited<ReturnType<typeof getEmployeeOvertime>>, TError = unknown>(
 id: number,
    overtimeId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEmployeeOvertime>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmployeeOvertimeSuspenseQueryOptions(id,overtimeId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete Employee Overtime
 */
export const deleteEmployeeOvertime = (
    id: number,
    overtimeId: number,
 ) => {
      
      
      return customMutator<EmployeeOvertime>(
      {url: `/api/hr/employee/${id}/overtime/${overtimeId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEmployeeOvertimeMutationOptions = <TData = Awaited<ReturnType<typeof deleteEmployeeOvertime>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;overtimeId: number}, TContext>, }
) => {
const mutationKey = ['deleteEmployeeOvertime'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEmployeeOvertime>>, {id: number;overtimeId: number}> = (props) => {
          const {id,overtimeId} = props ?? {};

          return  deleteEmployeeOvertime(id,overtimeId,)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;overtimeId: number}, TContext>}

    export type DeleteEmployeeOvertimeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEmployeeOvertime>>>
    
    export type DeleteEmployeeOvertimeMutationError = ResponseBase

    export const useDeleteEmployeeOvertime = <TData = Awaited<ReturnType<typeof deleteEmployeeOvertime>>, TError = ResponseBase,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;overtimeId: number}, TContext>, }
): UseMutationResult<
        TData,
        TError,
        {id: number;overtimeId: number},
        TContext
      > => {

      const mutationOptions = getDeleteEmployeeOvertimeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
